

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>OpenTitan error fileset (24 entries) &mdash; Verible status report  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/contentui.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/contentui.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Incorrect formatting (39 entries)" href="examined_bugs.html" />
    <link rel="prev" title="Correct formatting (39 entries)" href="examined_confirmed.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Verible status report
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ot.html">OpenTitan formatting status</a></li>
<li class="toctree-l1"><a class="reference internal" href="style.html">LowRISC style compliance report</a></li>
<li class="toctree-l1"><a class="reference internal" href="verible_zero_effort.html">OpenTitan no-change fileset (0 entries)</a></li>
<li class="toctree-l1"><a class="reference internal" href="examined_confirmed.html">Correct formatting (39 entries)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">OpenTitan error fileset (24 entries)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#hw-dv-sv-cip-lib-seq-lib-cip-base-vseq-sv">hw/dv/sv/cip_lib/seq_lib/cip_base_vseq.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-dv-sv-cip-lib-seq-lib-cip-base-vseq-tl-errors-svh">hw/dv/sv/cip_lib/seq_lib/cip_base_vseq__tl_errors.svh</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-dv-sv-mem-bkdr-util-mem-bkdr-util-rom-sv">hw/dv/sv/mem_bkdr_util/mem_bkdr_util__rom.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-dv-sv-mem-bkdr-util-mem-bkdr-util-otp-sv">hw/dv/sv/mem_bkdr_util/mem_bkdr_util__otp.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-dv-sv-mem-bkdr-util-mem-bkdr-util-sram-sv">hw/dv/sv/mem_bkdr_util/mem_bkdr_util__sram.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-dv-sv-tl-agent-tl-seq-item-sv">hw/dv/sv/tl_agent/tl_seq_item.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-edn-dv-env-edn-env-cfg-sv">hw/ip/edn/dv/env/edn_env_cfg.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-flash-ctrl-dv-env-seq-lib-flash-ctrl-base-vseq-sv">hw/ip/flash_ctrl/dv/env/seq_lib/flash_ctrl_base_vseq.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-gpio-dv-env-gpio-scoreboard-sv">hw/ip/gpio/dv/env/gpio_scoreboard.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-rv-timer-dv-env-rv-timer-scoreboard-sv">hw/ip/rv_timer/dv/env/rv_timer_scoreboard.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-rv-timer-dv-env-seq-lib-rv-timer-base-vseq-sv">hw/ip/rv_timer/dv/env/seq_lib/rv_timer_base_vseq.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-otp-ctrl-dv-tb-sv">hw/ip/otp_ctrl/dv/tb.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-otp-ctrl-dv-env-otp-ctrl-env-sv">hw/ip/otp_ctrl/dv/env/otp_ctrl_env.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-otp-ctrl-dv-env-otp-ctrl-scoreboard-sv">hw/ip/otp_ctrl/dv/env/otp_ctrl_scoreboard.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-otp-ctrl-dv-env-otp-ctrl-if-sv">hw/ip/otp_ctrl/dv/env/otp_ctrl_if.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-lc-ctrl-dv-tb-sv">hw/ip/lc_ctrl/dv/tb.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-lc-ctrl-dv-env-lc-ctrl-scoreboard-sv">hw/ip/lc_ctrl/dv/env/lc_ctrl_scoreboard.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-lc-ctrl-dv-env-lc-ctrl-env-sv">hw/ip/lc_ctrl/dv/env/lc_ctrl_env.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-spi-device-rtl-spi-device-sv">hw/ip/spi_device/rtl/spi_device.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-uart-dv-env-seq-lib-uart-base-vseq-sv">hw/ip/uart/dv/env/seq_lib/uart_base_vseq.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-pinmux-rtl-pinmux-wkup-sv">hw/ip/pinmux/rtl/pinmux_wkup.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-kmac-dv-env-kmac-env-cov-sv">hw/ip/kmac/dv/env/kmac_env_cov.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-kmac-dv-env-kmac-scoreboard-sv">hw/ip/kmac/dv/env/kmac_scoreboard.sv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hw-ip-keymgr-dv-env-keymgr-scoreboard-sv">hw/ip/keymgr/dv/env/keymgr_scoreboard.sv</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examined_bugs.html">Incorrect formatting (39 entries)</a></li>
<li class="toctree-l1"><a class="reference internal" href="examined_unconfirmed.html">Unconfirmed formatting (119 entries)</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Verible status report</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>OpenTitan error fileset (24 entries)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/error.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="opentitan-error-fileset-24-entries">
<h1>OpenTitan error fileset (24 entries)<a class="headerlink" href="#opentitan-error-fileset-24-entries" title="Permalink to this headline">¶</a></h1>
<table class="docutils align-default">
<colgroup>
<col style="width: 69%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Filename</p></th>
<th class="head"><p>Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#error-hw-dv-sv-cip-lib-seq-lib-cip-base-vseq-sv"><span class="std std-ref">hw/dv/sv/cip_lib/seq_lib/cip_base_vseq.sv</span></a></p></td>
<td><p>Syntax error</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#error-hw-dv-sv-cip-lib-seq-lib-cip-base-vseq-tl-errors-svh"><span class="std std-ref">hw/dv/sv/cip_lib/seq_lib/cip_base_vseq__tl_errors.svh</span></a></p></td>
<td><p>Syntax error</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#error-hw-dv-sv-mem-bkdr-util-mem-bkdr-util-rom-sv"><span class="std std-ref">hw/dv/sv/mem_bkdr_util/mem_bkdr_util__rom.sv</span></a></p></td>
<td><p>Syntax error</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#error-hw-dv-sv-mem-bkdr-util-mem-bkdr-util-otp-sv"><span class="std std-ref">hw/dv/sv/mem_bkdr_util/mem_bkdr_util__otp.sv</span></a></p></td>
<td><p>Syntax error</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#error-hw-dv-sv-mem-bkdr-util-mem-bkdr-util-sram-sv"><span class="std std-ref">hw/dv/sv/mem_bkdr_util/mem_bkdr_util__sram.sv</span></a></p></td>
<td><p>Syntax error</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#error-hw-dv-sv-tl-agent-tl-seq-item-sv"><span class="std std-ref">hw/dv/sv/tl_agent/tl_seq_item.sv</span></a></p></td>
<td><p>Unknown</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#error-hw-ip-edn-dv-env-edn-env-cfg-sv"><span class="std std-ref">hw/ip/edn/dv/env/edn_env_cfg.sv</span></a></p></td>
<td><p>Syntax error</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#error-hw-ip-flash-ctrl-dv-env-seq-lib-flash-ctrl-base-vseq-sv"><span class="std std-ref">hw/ip/flash_ctrl/dv/env/seq_lib/flash_ctrl_base_vseq.sv</span></a></p></td>
<td><p>Unknown</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#error-hw-ip-gpio-dv-env-gpio-scoreboard-sv"><span class="std std-ref">hw/ip/gpio/dv/env/gpio_scoreboard.sv</span></a></p></td>
<td><p>Unknown</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#error-hw-ip-rv-timer-dv-env-rv-timer-scoreboard-sv"><span class="std std-ref">hw/ip/rv_timer/dv/env/rv_timer_scoreboard.sv</span></a></p></td>
<td><p>Unknown</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#error-hw-ip-rv-timer-dv-env-seq-lib-rv-timer-base-vseq-sv"><span class="std std-ref">hw/ip/rv_timer/dv/env/seq_lib/rv_timer_base_vseq.sv</span></a></p></td>
<td><p>Unknown</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#error-hw-ip-otp-ctrl-dv-tb-sv"><span class="std std-ref">hw/ip/otp_ctrl/dv/tb.sv</span></a></p></td>
<td><p>Unknown</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#error-hw-ip-otp-ctrl-dv-env-otp-ctrl-env-sv"><span class="std std-ref">hw/ip/otp_ctrl/dv/env/otp_ctrl_env.sv</span></a></p></td>
<td><p>Unknown</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#error-hw-ip-otp-ctrl-dv-env-otp-ctrl-scoreboard-sv"><span class="std std-ref">hw/ip/otp_ctrl/dv/env/otp_ctrl_scoreboard.sv</span></a></p></td>
<td><p>Lexically different</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#error-hw-ip-otp-ctrl-dv-env-otp-ctrl-if-sv"><span class="std std-ref">hw/ip/otp_ctrl/dv/env/otp_ctrl_if.sv</span></a></p></td>
<td><p>Internal bug</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#error-hw-ip-lc-ctrl-dv-tb-sv"><span class="std std-ref">hw/ip/lc_ctrl/dv/tb.sv</span></a></p></td>
<td><p>Unknown</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#error-hw-ip-lc-ctrl-dv-env-lc-ctrl-scoreboard-sv"><span class="std std-ref">hw/ip/lc_ctrl/dv/env/lc_ctrl_scoreboard.sv</span></a></p></td>
<td><p>Lexically different</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#error-hw-ip-lc-ctrl-dv-env-lc-ctrl-env-sv"><span class="std std-ref">hw/ip/lc_ctrl/dv/env/lc_ctrl_env.sv</span></a></p></td>
<td><p>Unknown</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#error-hw-ip-spi-device-rtl-spi-device-sv"><span class="std std-ref">hw/ip/spi_device/rtl/spi_device.sv</span></a></p></td>
<td><p>Unknown</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#error-hw-ip-uart-dv-env-seq-lib-uart-base-vseq-sv"><span class="std std-ref">hw/ip/uart/dv/env/seq_lib/uart_base_vseq.sv</span></a></p></td>
<td><p>Lexically different</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#error-hw-ip-pinmux-rtl-pinmux-wkup-sv"><span class="std std-ref">hw/ip/pinmux/rtl/pinmux_wkup.sv</span></a></p></td>
<td><p>Unknown</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#error-hw-ip-kmac-dv-env-kmac-env-cov-sv"><span class="std std-ref">hw/ip/kmac/dv/env/kmac_env_cov.sv</span></a></p></td>
<td><p>Syntax error</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#error-hw-ip-kmac-dv-env-kmac-scoreboard-sv"><span class="std std-ref">hw/ip/kmac/dv/env/kmac_scoreboard.sv</span></a></p></td>
<td><p>Lexically different</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#error-hw-ip-keymgr-dv-env-keymgr-scoreboard-sv"><span class="std std-ref">hw/ip/keymgr/dv/env/keymgr_scoreboard.sv</span></a></p></td>
<td><p>Lexically different</p></td>
</tr>
</tbody>
</table>
<div class="section" id="hw-dv-sv-cip-lib-seq-lib-cip-base-vseq-sv">
<span id="error-hw-dv-sv-cip-lib-seq-lib-cip-base-vseq-sv"></span><h2>hw/dv/sv/cip_lib/seq_lib/cip_base_vseq.sv<a class="headerlink" href="#hw-dv-sv-cip-lib-seq-lib-cip-base-vseq-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span> <span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">924</span><span class="p">:</span><span class="mi">67</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&#39;{&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="hw-dv-sv-cip-lib-seq-lib-cip-base-vseq-tl-errors-svh">
<span id="error-hw-dv-sv-cip-lib-seq-lib-cip-base-vseq-tl-errors-svh"></span><h2>hw/dv/sv/cip_lib/seq_lib/cip_base_vseq__tl_errors.svh<a class="headerlink" href="#hw-dv-sv-cip-lib-seq-lib-cip-base-vseq-tl-errors-svh" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span> <span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;task&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;if&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;repeat&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">39</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;if&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">50</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">55</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;repeat&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">67</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">73</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;.&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">74</span><span class="p">:</span><span class="mi">19</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;(&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">75</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;foreach&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">80</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;if&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">100</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">104</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;repeat&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">109</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">116</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;repeat&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">123</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;if&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">134</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">140</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;repeat&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">144</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;if&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">154</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">160</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;repeat&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">164</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;if&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">173</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">185</span><span class="p">:</span><span class="mi">19</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;(&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">187</span><span class="p">:</span><span class="mi">44</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;(&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">188</span><span class="p">:</span><span class="mi">19</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;(&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">189</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endtask&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">209</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;if&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">214</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">219</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;foreach&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">223</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">228</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">228</span><span class="p">:</span><span class="mi">29</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;=&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">228</span><span class="p">:</span><span class="mi">48</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">244</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;:&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">245</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;:&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">248</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;.&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">251</span><span class="p">:</span><span class="mi">40</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;:&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">252</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;:&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">253</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;:&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">254</span><span class="p">:</span><span class="mi">15</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endcase&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">259</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">265</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;.&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">266</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">273</span><span class="p">:</span><span class="mi">19</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;(&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">276</span><span class="p">:</span><span class="mi">44</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;(&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">278</span><span class="p">:</span><span class="mi">19</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;(&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">279</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endtask&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">284</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">284</span><span class="p">:</span><span class="mi">29</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;=&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">284</span><span class="p">:</span><span class="mi">48</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">292</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">300</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;#&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">307</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;randcase&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">311</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;:&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">315</span><span class="p">:</span><span class="mi">11</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">327</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;repeat&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">329</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">cip_lib</span><span class="o">/</span><span class="n">seq_lib</span><span class="o">/</span><span class="n">cip_base_vseq__tl_errors</span><span class="o">.</span><span class="n">svh</span><span class="p">:</span><span class="mi">335</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="hw-dv-sv-mem-bkdr-util-mem-bkdr-util-rom-sv">
<span id="error-hw-dv-sv-mem-bkdr-util-mem-bkdr-util-rom-sv"></span><h2>hw/dv/sv/mem_bkdr_util/mem_bkdr_util__rom.sv<a class="headerlink" href="#hw-dv-sv-mem-bkdr-util-mem-bkdr-util-rom-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span> <span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">11</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;function&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">32</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">39</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">44</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">49</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;if&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">51</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">58</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">58</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">58</span><span class="p">:</span><span class="mi">28</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">60</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">63</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">63</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">63</span><span class="p">:</span><span class="mi">28</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">65</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__rom</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">68</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endfunction&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="hw-dv-sv-mem-bkdr-util-mem-bkdr-util-otp-sv">
<span id="error-hw-dv-sv-mem-bkdr-util-mem-bkdr-util-otp-sv"></span><h2>hw/dv/sv/mem_bkdr_util/mem_bkdr_util__otp.sv<a class="headerlink" href="#hw-dv-sv-mem-bkdr-util-mem-bkdr-util-otp-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span> <span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">8</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;function&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;+=&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">11</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span><span class="mi">45</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;+=&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">29</span><span class="p">:</span><span class="mi">12</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;(&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">31</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">31</span><span class="p">:</span><span class="mi">43</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;+=&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">12</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;(&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">39</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;(&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__otp</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">40</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endfunction&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="hw-dv-sv-mem-bkdr-util-mem-bkdr-util-sram-sv">
<span id="error-hw-dv-sv-mem-bkdr-util-mem-bkdr-util-sram-sv"></span><h2>hw/dv/sv/mem_bkdr_util/mem_bkdr_util__sram.sv<a class="headerlink" href="#hw-dv-sv-mem-bkdr-util-mem-bkdr-util-sram-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span> <span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">8</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;function&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">25</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">31</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">31</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">31</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">45</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;return&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endfunction&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">63</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">63</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">63</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">65</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">71</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">71</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">71</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">73</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">74</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">74</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">76</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">85</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;return&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">86</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endfunction&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">102</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">102</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">102</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">104</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">110</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">110</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">110</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">112</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">113</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">113</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">115</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">124</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;return&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">126</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endfunction&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">143</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">143</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">143</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">145</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">151</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">151</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">151</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">153</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">154</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">154</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">156</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">165</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;return&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">167</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endfunction&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">185</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">185</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">185</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">187</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">200</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">200</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">200</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">202</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">203</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">203</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">205</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">209</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endfunction&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">227</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">227</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">227</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">229</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">242</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">242</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">242</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">244</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">245</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">245</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">247</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">251</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endfunction&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">269</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">269</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">269</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">271</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">284</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">284</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">284</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">286</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">287</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">287</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">289</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">293</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endfunction&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">311</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">311</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">311</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">313</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">326</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">326</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">326</span><span class="p">:</span><span class="mi">34</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">328</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">329</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">329</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">331</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">sv</span><span class="o">/</span><span class="n">mem_bkdr_util</span><span class="o">/</span><span class="n">mem_bkdr_util__sram</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">335</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endfunction&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="hw-dv-sv-tl-agent-tl-seq-item-sv">
<span id="error-hw-dv-sv-tl-agent-tl-seq-item-sv"></span><h2>hw/dv/sv/tl_agent/tl_seq_item.sv<a class="headerlink" href="#hw-dv-sv-tl-agent-tl-seq-item-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/dv/sv/tl_agent/tl_seq_item.sv: Re-formatted text does not match formatted text; formatting failed to converge!  Please file a bug.
Original: --lines:
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// ---------------------------------------------
// TileLink sequence item
// ---------------------------------------------

// use macro to write constraint in order to reuse in functions:
// get_exp_d_error and randomize_a_chan_with_protocol_error
`define chk_prot_a_opcode \
  a_opcode inside {Get, PutFullData, PutPartialData}

// For PutFullData message, mask needs to match with size
`define chk_prot_mask_w_PutFullData \
  a_opcode != PutFullData || $countones(a_mask) == (1 &lt;&lt; a_size)

// mask must align with addr, same as below
//   a_addr[1:0] == 1 -&gt; a_mask[0]   == 0;
//   a_addr[1:0] == 2 -&gt; a_mask[1:0] == 0;
//   a_addr[1:0] == 3 -&gt; a_mask[2:0] == 0;
`define chk_prot_addr_mask_align \
  MaskWidth&#39;(a_mask &lt;&lt; (4 - a_addr[SizeWidth-1:0])) == 0

// mask must be within enabled lanes
// prevent cases: addr: 0h, size: 1, mask: &#39;b1100; addr: 0h, size: 0, mask: &#39;b1000
`define chk_prot_mask_in_enabled_lanes \
  ((a_mask &gt;&gt; a_addr[SizeWidth-1:0]) &gt;&gt; (1 &lt;&lt; a_size)) == 0

// Address must be aligned to the a_size (2 ** a_size bytes)
`define chk_prot_addr_size_align \
  (a_addr &lt;&lt; (AddrWidth - a_size)) == 0

// max size is 2
`define chk_prot_max_size \
  a_size &lt;= 2

class tl_seq_item extends uvm_sequence_item;

  rand bit [AddrWidth - 1   : 0] a_addr;
  rand bit [DataWidth - 1   : 0] a_data;
  rand bit [MaskWidth - 1   : 0] a_mask;
  rand bit [SizeWidth - 1   : 0] a_size;
  rand bit [2:0]                 a_param;
  rand bit [SourceWidth - 1 : 0] a_source;
  rand bit [OpcodeWidth - 1 : 0] a_opcode;
  rand bit [AUserWidth - 1 : 0]  a_user;

  rand bit [2:0]                 d_param;
  rand bit [DataWidth - 1   : 0] d_data;
  rand bit [SourceWidth - 1 : 0] d_source;
  rand bit [SizeWidth - 1   : 0] d_size;
  rand bit [OpcodeWidth - 1 : 0] d_opcode;
  rand bit                       d_error;
  rand bit [DUserWidth - 1 : 0]  d_user;
  rand bit                       d_sink;

  // host mode delays
  rand int unsigned               a_valid_delay;
  rand int unsigned               a_valid_len;

  // device mode delays
  rand int unsigned               d_valid_delay;
  rand int unsigned               d_valid_len;

  // Indicates a_source val is overridden.
  //
  // a_source is randomized and set in tl_host_base_seq::finish_item() to facilitate late
  // randomization. If this bit is set, the a_source is assumed to be set to a fixed value instead.
  // It is possible that this fixed value might match one of the pending reqs in the that has not
  // yet completed. The driver can then use this bit to add more delays if needed before sending
  // this request, to avoid protocol violation.
  bit                             a_source_is_overridden;

  // after given valid_len, end the req/rsp if it&#39;s not accepted, which allows seq to switch
  // content and test unaccepted item shouldn&#39;t be used in design
  bit                             req_abort_after_a_valid_len;
  bit                             rsp_abort_after_d_valid_len;
  // True if the item is completed, not aborted
  bit                             req_completed;
  bit                             rsp_completed;

  // param is reserved for future use, must be zero
  constraint param_c {
    a_param == 0;
    d_param == 0;
  }

  constraint no_d_error_c {
    soft d_error == 0;
  }

  constraint a_valid_len_c {
    soft a_valid_len inside {[1:10]};
  }

  constraint d_valid_len_c {
    soft d_valid_len inside {[1:10]};
  }

  constraint valid_delay_c {
    soft a_valid_delay inside {[0:50]};
    soft d_valid_delay inside {[0:50]};
  }

  constraint d_opcode_c {
    d_opcode inside {AccessAckData, AccessAck};
  }

  constraint a_opcode_c {
    `chk_prot_a_opcode;
  }

  // mask must be contiguous, e.g. &#39;b1001, &#39;b1010 aren&#39;t allowed
  constraint mask_contiguous_c {
    $countones(a_mask ^ {a_mask[MaskWidth-2:0], 1&#39;b0}) &lt;= 2;
  }

  constraint mask_w_PutFullData_c {
    `chk_prot_mask_w_PutFullData;
  }

  constraint addr_mask_align_c {
    `chk_prot_addr_mask_align;
  }

  constraint mask_in_enabled_lanes_c {
    `chk_prot_mask_in_enabled_lanes;
  }

  constraint addr_size_align_c {
    `chk_prot_addr_size_align;
  }

  // size can&#39;t be more than 2
  constraint max_size_c {
    `chk_prot_max_size;
  }

  `uvm_object_utils_begin(tl_seq_item)
    `uvm_field_int  (a_addr,              UVM_DEFAULT)
    `uvm_field_int  (a_data,              UVM_DEFAULT)
    `uvm_field_int  (a_mask,              UVM_DEFAULT)
    `uvm_field_int  (a_size,              UVM_DEFAULT)
    `uvm_field_int  (a_param,             UVM_DEFAULT)
    `uvm_field_int  (a_source,            UVM_DEFAULT)
    `uvm_field_int  (a_opcode,            UVM_DEFAULT)
    `uvm_field_int  (a_user,              UVM_DEFAULT)
    `uvm_field_int  (d_param,             UVM_DEFAULT)
    `uvm_field_int  (d_source,            UVM_DEFAULT)
    `uvm_field_int  (d_data,              UVM_DEFAULT)
    `uvm_field_int  (d_size,              UVM_DEFAULT)
    `uvm_field_int  (d_opcode,            UVM_DEFAULT)
    `uvm_field_int  (d_error,             UVM_DEFAULT)
    `uvm_field_int  (d_sink,              UVM_DEFAULT)
    `uvm_field_int  (d_user,              UVM_DEFAULT)
    `uvm_field_int  (a_source_is_overridden, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int  (a_valid_delay,       UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int  (d_valid_delay,       UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int  (a_valid_len,         UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int  (d_valid_len,         UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int  (req_abort_after_a_valid_len, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int  (rsp_abort_after_d_valid_len, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int  (req_completed,       UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int  (rsp_completed,       UVM_DEFAULT | UVM_NOPACK)
  `uvm_object_utils_end

  function new (string name = &quot;&quot;);
    super.new(name);
  endfunction : new

  virtual function string convert2string();
    string str;
    string a_opcode_name, d_opcode_name;
    tl_a_op_e a_op_e;
    tl_d_op_e d_op_e;
    if ($cast(a_op_e, a_opcode)) a_opcode_name = a_op_e.name();
    else                         a_opcode_name = $sformatf(&quot;Invalid, value: %0d&quot;, a_opcode);
    if ($cast(d_op_e, d_opcode)) d_opcode_name = d_op_e.name();
    else                         d_opcode_name = $sformatf(&quot;Invalid, value: %0d&quot;, d_opcode);

    str = {$sformatf(&quot;a_addr = 0x%0h &quot;, a_addr),
           $sformatf(&quot;a_data = 0x%0h &quot;, a_data),
           $sformatf(&quot;a_mask = 0x%0h &quot;, a_mask),
           $sformatf(&quot;a_size = 0x%0h &quot;, a_size),
           $sformatf(&quot;a_param = 0x%0h &quot;, a_param),
           $sformatf(&quot;a_source = 0x%0h &quot;, a_source),
           $sformatf(&quot;a_opcode = %0s &quot;, a_opcode_name),
           $sformatf(&quot;a_user = 0x%0h &quot;, a_user),
           $sformatf(&quot;d_data = 0x%0h &quot;, d_data),
           $sformatf(&quot;d_size = 0x%0h &quot;, d_size),
           $sformatf(&quot;d_param = 0x%0h &quot;, d_param),
           $sformatf(&quot;d_source = 0x%0h &quot;, d_source),
           $sformatf(&quot;d_opcode = %0s &quot;, d_opcode_name),
           $sformatf(&quot;d_error = %0b &quot;, d_error),
           $sformatf(&quot;d_user = %0b &quot;, d_user),
           $sformatf(&quot;d_sink = %0b &quot;, d_sink),
           $sformatf(&quot;req_abort_after_a_valid_len = %0b &quot;, req_abort_after_a_valid_len),
           $sformatf(&quot;rsp_abort_after_d_valid_len = %0b &quot;, rsp_abort_after_d_valid_len),
           $sformatf(&quot;req_completed = %0b &quot;, req_completed),
           $sformatf(&quot;rsp_completed = %0b &quot;, rsp_completed)};
    return str;
  endfunction

  function void disable_a_chan_randomization();
    a_addr.rand_mode(0);
    a_data.rand_mode(0);
    a_mask.rand_mode(0);
    a_size.rand_mode(0);
    a_param.rand_mode(0);
    a_source.rand_mode(0);
    a_opcode.rand_mode(0);
  endfunction

  // calculate d_error based on values of a_chan
  function bit get_exp_d_error();
    return get_error_a_opcode_invalid() || get_error_PutFullData_mask_size_mismatched() ||
           get_error_addr_mask_misaligned() || get_error_addr_size_misaligned() ||
           get_error_mask_not_in_enabled_lanes() || get_error_size_over_max();
  endfunction

  function bit get_error_a_opcode_invalid();
    return !(`chk_prot_a_opcode);
  endfunction

  function bit get_error_PutFullData_mask_size_mismatched();
    return !(`chk_prot_mask_w_PutFullData);
  endfunction

  function bit get_error_addr_mask_misaligned();
    return !(`chk_prot_addr_mask_align);
  endfunction

  function bit get_error_addr_size_misaligned();
    return !(`chk_prot_addr_size_align);
  endfunction

  function bit get_error_mask_not_in_enabled_lanes();
    return !(`chk_prot_mask_in_enabled_lanes);
  endfunction

  function bit get_error_size_over_max();
    return !(`chk_prot_max_size);
  endfunction // get_error_size_over_max

  function void disable_a_chan_protocol_constraint();
    a_opcode_c.constraint_mode(0);
    mask_contiguous_c.constraint_mode(0);
    mask_w_PutFullData_c.constraint_mode(0);
    addr_mask_align_c.constraint_mode(0);
    mask_in_enabled_lanes_c.constraint_mode(0);
    addr_size_align_c.constraint_mode(0);
    max_size_c.constraint_mode(0);
  endfunction

  // randomly disable constraint_mode for a chan
  // at least one constraint_mode needs to be disabled to make sure protocol is violated
  function void randomize_a_chan_with_protocol_error();
    bit cm_a_opcode, cm_mask_w_PutFullData;
    bit cm_addr_mask_align, cm_mask_in_enabled_lanes, cm_addr_size_align, cm_max_size;
    `DV_CHECK_FATAL(std::randomize(cm_a_opcode, cm_mask_w_PutFullData,
                                   cm_addr_mask_align, cm_mask_in_enabled_lanes,
                                   cm_addr_size_align, cm_max_size) with {
                                   // at least one constraint_mode is off
                                   !(cm_a_opcode &amp;&amp; cm_mask_w_PutFullData &amp;&amp;
                                   cm_addr_mask_align &amp;&amp; cm_mask_in_enabled_lanes &amp;&amp;
                                   cm_addr_size_align &amp;&amp; cm_max_size);
                                   })
    a_opcode_c.constraint_mode(cm_a_opcode);
    mask_w_PutFullData_c.constraint_mode(cm_mask_w_PutFullData);
    addr_mask_align_c.constraint_mode(cm_addr_mask_align);
    mask_in_enabled_lanes_c.constraint_mode(cm_mask_in_enabled_lanes);
    addr_size_align_c.constraint_mode(cm_addr_size_align);
    max_size_c.constraint_mode(cm_max_size);
    `DV_CHECK_FATAL(
        // at least one `chk_prot_* is violated
        randomize() with {!cm_a_opcode              &amp;&amp; !(`chk_prot_a_opcode)              ||
                          !cm_mask_w_PutFullData    &amp;&amp; !(`chk_prot_mask_w_PutFullData)    ||
                          !cm_addr_mask_align       &amp;&amp; !(`chk_prot_addr_mask_align)       ||
                          !cm_mask_in_enabled_lanes &amp;&amp; !(`chk_prot_mask_in_enabled_lanes) ||
                          !cm_addr_size_align       &amp;&amp; !(`chk_prot_addr_size_align)       ||
                          !cm_max_size              &amp;&amp; !(`chk_prot_max_size);})
  endfunction

  // Find whether this seq item is a read or a write.
  virtual function bit is_write();
    return (a_opcode inside {PutFullData, PutPartialData});
  endfunction

  // Check if d_opcode is appropriate for the given a_opcode. This check assumes that the
  // response packet has been appended with the corresponding request.
  virtual function bit check_opcodes(bit throw_error = 1&#39;b1);
    // for read, return AccessAckData; for write or error opcode, return AccessAck
    tl_d_op_e exp_d_opcode = a_opcode == Get ? tlul_pkg::AccessAckData : tlul_pkg::AccessAck;
    check_opcodes = (d_opcode == int&#39;(exp_d_opcode));
    if (!check_opcodes &amp;&amp; throw_error) begin
      `uvm_error(`gfn, $sformatf(&quot;d_opcode: %0d &amp; exp_d_opcode: %0d mismatch&quot;,
                                  d_opcode, exp_d_opcode))
    end
  endfunction

  // Check if packet parameters are ok.
  virtual function bit is_ok(bit throw_error = 1&#39;b1);
    is_ok = 1&#39;b1;
    is_ok &amp;= check_opcodes(throw_error);
    // addr and data channels should have the same source
    is_ok &amp;= (a_source == d_source);
    if (!is_ok &amp;&amp; throw_error)
      `uvm_error(`gfn, $sformatf(&quot;a_source: 0x%0h &amp; d_source: 0x%0h mismatch&quot;, a_source, d_source))
  endfunction

  // Compute and check the integrity of the a_channel payload.
  //
  // The TL agent is generic and adheres to the TLUL spec, which does not define
  // how the integrity of the payload on each channel is computed / checked. That
  // is up to the chip implementation. Typically, parity / ECC scheme is used, with
  // the redundant bits transmitted through *_user.
  //
  // Returns 1 if the integrity of a_channel is maintained, 0 otherwise. This base
  // class implementation vacuously returns 1.
  virtual function bit is_a_chan_intg_ok(bit throw_error = 1&#39;b1);
    return 1;
  endfunction

  // d_channel version of the function above
  virtual function bit is_d_chan_intg_ok(bit throw_error = 1&#39;b1);
    return 1;
  endfunction
endclass

`undef chk_prot_a_opcode
`undef chk_prot_mask_w_PutFullData
`undef chk_prot_addr_mask_align
`undef chk_prot_mask_in_enabled_lanes
`undef chk_prot_addr_size_align
`undef chk_prot_max_size
Formatted:
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// ---------------------------------------------
// TileLink sequence item
// ---------------------------------------------

// use macro to write constraint in order to reuse in functions:
// get_exp_d_error and randomize_a_chan_with_protocol_error
`define chk_prot_a_opcode \
  a_opcode inside {Get, PutFullData, PutPartialData}

// For PutFullData message, mask needs to match with size
`define chk_prot_mask_w_PutFullData \
  a_opcode != PutFullData || $countones(a_mask) == (1 &lt;&lt; a_size)

// mask must align with addr, same as below
//   a_addr[1:0] == 1 -&gt; a_mask[0]   == 0;
//   a_addr[1:0] == 2 -&gt; a_mask[1:0] == 0;
//   a_addr[1:0] == 3 -&gt; a_mask[2:0] == 0;
`define chk_prot_addr_mask_align \
  MaskWidth&#39;(a_mask &lt;&lt; (4 - a_addr[SizeWidth-1:0])) == 0

// mask must be within enabled lanes
// prevent cases: addr: 0h, size: 1, mask: &#39;b1100; addr: 0h, size: 0, mask: &#39;b1000
`define chk_prot_mask_in_enabled_lanes \
  ((a_mask &gt;&gt; a_addr[SizeWidth-1:0]) &gt;&gt; (1 &lt;&lt; a_size)) == 0

// Address must be aligned to the a_size (2 ** a_size bytes)
`define chk_prot_addr_size_align \
  (a_addr &lt;&lt; (AddrWidth - a_size)) == 0

// max size is 2
`define chk_prot_max_size \
  a_size &lt;= 2

class tl_seq_item extends uvm_sequence_item;

  rand bit [AddrWidth - 1 : 0]   a_addr;
  rand bit [DataWidth - 1 : 0]   a_data;
  rand bit [MaskWidth - 1 : 0]   a_mask;
  rand bit [SizeWidth - 1 : 0]   a_size;
  rand bit [2:0]                 a_param;
  rand bit [SourceWidth - 1 : 0] a_source;
  rand bit [OpcodeWidth - 1 : 0] a_opcode;
  rand bit [AUserWidth - 1 : 0]  a_user;

  rand bit [2:0]                 d_param;
  rand bit [DataWidth - 1 : 0]   d_data;
  rand bit [SourceWidth - 1 : 0] d_source;
  rand bit [SizeWidth - 1 : 0]   d_size;
  rand bit [OpcodeWidth - 1 : 0] d_opcode;
  rand bit                       d_error;
  rand bit [DUserWidth - 1 : 0]  d_user;
  rand bit                       d_sink;

  // host mode delays
  rand int unsigned              a_valid_delay;
  rand int unsigned              a_valid_len;

  // device mode delays
  rand int unsigned              d_valid_delay;
  rand int unsigned              d_valid_len;

  // Indicates a_source val is overridden.
  //
  // a_source is randomized and set in tl_host_base_seq::finish_item() to facilitate late
  // randomization. If this bit is set, the a_source is assumed to be set to a fixed value instead.
  // It is possible that this fixed value might match one of the pending reqs in the that has not
  // yet completed. The driver can then use this bit to add more delays if needed before sending
  // this request, to avoid protocol violation.
  bit                            a_source_is_overridden;

  // after given valid_len, end the req/rsp if it&#39;s not accepted, which allows seq to switch
  // content and test unaccepted item shouldn&#39;t be used in design
  bit                            req_abort_after_a_valid_len;
  bit                            rsp_abort_after_d_valid_len;
  // True if the item is completed, not aborted
  bit                            req_completed;
  bit                            rsp_completed;

  // param is reserved for future use, must be zero
  constraint param_c {
    a_param == 0;
    d_param == 0;
  }

  constraint no_d_error_c {soft d_error == 0;}

  constraint a_valid_len_c {soft a_valid_len inside {[1 : 10]};}

  constraint d_valid_len_c {soft d_valid_len inside {[1 : 10]};}

  constraint valid_delay_c {
    soft a_valid_delay inside {[0 : 50]};
    soft d_valid_delay inside {[0 : 50]};
  }

  constraint d_opcode_c {d_opcode inside {AccessAckData, AccessAck};}

  constraint a_opcode_c {`chk_prot_a_opcode;}

  // mask must be contiguous, e.g. &#39;b1001, &#39;b1010 aren&#39;t allowed
  constraint mask_contiguous_c {
    $countones(
        a_mask ^ {a_mask[MaskWidth-2:0], 1&#39;b0}
    ) &lt;= 2;
  }

  constraint mask_w_PutFullData_c {`chk_prot_mask_w_PutFullData;}

  constraint addr_mask_align_c {`chk_prot_addr_mask_align;}

  constraint mask_in_enabled_lanes_c {`chk_prot_mask_in_enabled_lanes;}

  constraint addr_size_align_c {`chk_prot_addr_size_align;}

  // size can&#39;t be more than 2
  constraint max_size_c {`chk_prot_max_size;}

  `uvm_object_utils_begin(tl_seq_item)
    `uvm_field_int(a_addr, UVM_DEFAULT)
    `uvm_field_int(a_data, UVM_DEFAULT)
    `uvm_field_int(a_mask, UVM_DEFAULT)
    `uvm_field_int(a_size, UVM_DEFAULT)
    `uvm_field_int(a_param, UVM_DEFAULT)
    `uvm_field_int(a_source, UVM_DEFAULT)
    `uvm_field_int(a_opcode, UVM_DEFAULT)
    `uvm_field_int(a_user, UVM_DEFAULT)
    `uvm_field_int(d_param, UVM_DEFAULT)
    `uvm_field_int(d_source, UVM_DEFAULT)
    `uvm_field_int(d_data, UVM_DEFAULT)
    `uvm_field_int(d_size, UVM_DEFAULT)
    `uvm_field_int(d_opcode, UVM_DEFAULT)
    `uvm_field_int(d_error, UVM_DEFAULT)
    `uvm_field_int(d_sink, UVM_DEFAULT)
    `uvm_field_int(d_user, UVM_DEFAULT)
    `uvm_field_int(a_source_is_overridden, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(a_valid_delay, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(d_valid_delay, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(a_valid_len, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(d_valid_len, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(req_abort_after_a_valid_len, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(rsp_abort_after_d_valid_len, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(req_completed, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(rsp_completed, UVM_DEFAULT | UVM_NOPACK)
  `uvm_object_utils_end

  function new(string name = &quot;&quot;);
    super.new(name);
  endfunction : new

  virtual function string convert2string();
    string str;
    string a_opcode_name, d_opcode_name;
    tl_a_op_e a_op_e;
    tl_d_op_e d_op_e;
    if ($cast(a_op_e, a_opcode)) a_opcode_name = a_op_e.name();
    else a_opcode_name = $sformatf(&quot;Invalid, value: %0d&quot;, a_opcode);
    if ($cast(d_op_e, d_opcode)) d_opcode_name = d_op_e.name();
    else d_opcode_name = $sformatf(&quot;Invalid, value: %0d&quot;, d_opcode);

    str = {
      $sformatf(&quot;a_addr = 0x%0h &quot;, a_addr),
      $sformatf(&quot;a_data = 0x%0h &quot;, a_data),
      $sformatf(&quot;a_mask = 0x%0h &quot;, a_mask),
      $sformatf(&quot;a_size = 0x%0h &quot;, a_size),
      $sformatf(&quot;a_param = 0x%0h &quot;, a_param),
      $sformatf(&quot;a_source = 0x%0h &quot;, a_source),
      $sformatf(&quot;a_opcode = %0s &quot;, a_opcode_name),
      $sformatf(&quot;a_user = 0x%0h &quot;, a_user),
      $sformatf(&quot;d_data = 0x%0h &quot;, d_data),
      $sformatf(&quot;d_size = 0x%0h &quot;, d_size),
      $sformatf(&quot;d_param = 0x%0h &quot;, d_param),
      $sformatf(&quot;d_source = 0x%0h &quot;, d_source),
      $sformatf(&quot;d_opcode = %0s &quot;, d_opcode_name),
      $sformatf(&quot;d_error = %0b &quot;, d_error),
      $sformatf(&quot;d_user = %0b &quot;, d_user),
      $sformatf(&quot;d_sink = %0b &quot;, d_sink),
      $sformatf(&quot;req_abort_after_a_valid_len = %0b &quot;, req_abort_after_a_valid_len),
      $sformatf(&quot;rsp_abort_after_d_valid_len = %0b &quot;, rsp_abort_after_d_valid_len),
      $sformatf(&quot;req_completed = %0b &quot;, req_completed),
      $sformatf(&quot;rsp_completed = %0b &quot;, rsp_completed)
    };
    return str;
  endfunction

  function void disable_a_chan_randomization();
    a_addr.rand_mode(0);
    a_data.rand_mode(0);
    a_mask.rand_mode(0);
    a_size.rand_mode(0);
    a_param.rand_mode(0);
    a_source.rand_mode(0);
    a_opcode.rand_mode(0);
  endfunction

  // calculate d_error based on values of a_chan
  function bit get_exp_d_error();
    return get_error_a_opcode_invalid() || get_error_PutFullData_mask_size_mismatched() ||
           get_error_addr_mask_misaligned() || get_error_addr_size_misaligned() ||
           get_error_mask_not_in_enabled_lanes() || get_error_size_over_max();
  endfunction

  function bit get_error_a_opcode_invalid();
    return !(`chk_prot_a_opcode);
  endfunction

  function bit get_error_PutFullData_mask_size_mismatched();
    return !(`chk_prot_mask_w_PutFullData);
  endfunction

  function bit get_error_addr_mask_misaligned();
    return !(`chk_prot_addr_mask_align);
  endfunction

  function bit get_error_addr_size_misaligned();
    return !(`chk_prot_addr_size_align);
  endfunction

  function bit get_error_mask_not_in_enabled_lanes();
    return !(`chk_prot_mask_in_enabled_lanes);
  endfunction

  function bit get_error_size_over_max();
    return !(`chk_prot_max_size);
  endfunction  // get_error_size_over_max

  function void disable_a_chan_protocol_constraint();
    a_opcode_c.constraint_mode(0);
    mask_contiguous_c.constraint_mode(0);
    mask_w_PutFullData_c.constraint_mode(0);
    addr_mask_align_c.constraint_mode(0);
    mask_in_enabled_lanes_c.constraint_mode(0);
    addr_size_align_c.constraint_mode(0);
    max_size_c.constraint_mode(0);
  endfunction

  // randomly disable constraint_mode for a chan
  // at least one constraint_mode needs to be disabled to make sure protocol is violated
  function void randomize_a_chan_with_protocol_error();
    bit cm_a_opcode, cm_mask_w_PutFullData;
    bit cm_addr_mask_align, cm_mask_in_enabled_lanes, cm_addr_size_align, cm_max_size;
    `DV_CHECK_FATAL(std::randomize(
                    cm_a_opcode,
                    cm_mask_w_PutFullData,
                    cm_addr_mask_align,
                    cm_mask_in_enabled_lanes,
                    cm_addr_size_align,
                    cm_max_size
                    ) with {
                    // at least one constraint_mode is off
                    !(cm_a_opcode &amp;&amp; cm_mask_w_PutFullData &amp;&amp;
                                   cm_addr_mask_align &amp;&amp; cm_mask_in_enabled_lanes &amp;&amp;
                                   cm_addr_size_align &amp;&amp; cm_max_size);
                    })
    a_opcode_c.constraint_mode(cm_a_opcode);
    mask_w_PutFullData_c.constraint_mode(cm_mask_w_PutFullData);
    addr_mask_align_c.constraint_mode(cm_addr_mask_align);
    mask_in_enabled_lanes_c.constraint_mode(cm_mask_in_enabled_lanes);
    addr_size_align_c.constraint_mode(cm_addr_size_align);
    max_size_c.constraint_mode(cm_max_size);
    `DV_CHECK_FATAL(  // at least one `chk_prot_* is violated
                    randomize() with {
                    !cm_a_opcode              &amp;&amp; !(`chk_prot_a_opcode)              ||
                          !cm_mask_w_PutFullData    &amp;&amp; !(`chk_prot_mask_w_PutFullData)    ||
                          !cm_addr_mask_align       &amp;&amp; !(`chk_prot_addr_mask_align)       ||
                          !cm_mask_in_enabled_lanes &amp;&amp; !(`chk_prot_mask_in_enabled_lanes) ||
                          !cm_addr_size_align       &amp;&amp; !(`chk_prot_addr_size_align)       ||
                          !cm_max_size              &amp;&amp; !(`chk_prot_max_size);
                    })
  endfunction

  // Find whether this seq item is a read or a write.
  virtual function bit is_write();
    return (a_opcode inside {PutFullData, PutPartialData});
  endfunction

  // Check if d_opcode is appropriate for the given a_opcode. This check assumes that the
  // response packet has been appended with the corresponding request.
  virtual function bit check_opcodes(bit throw_error = 1&#39;b1);
    // for read, return AccessAckData; for write or error opcode, return AccessAck
    tl_d_op_e exp_d_opcode = a_opcode == Get ? tlul_pkg::AccessAckData : tlul_pkg::AccessAck;
    check_opcodes = (d_opcode == int&#39;(exp_d_opcode));
    if (!check_opcodes &amp;&amp; throw_error) begin
      `uvm_error(`gfn, $sformatf(
                 &quot;d_opcode: %0d &amp; exp_d_opcode: %0d mismatch&quot;, d_opcode, exp_d_opcode))
    end
  endfunction

  // Check if packet parameters are ok.
  virtual function bit is_ok(bit throw_error = 1&#39;b1);
    is_ok = 1&#39;b1;
    is_ok &amp;= check_opcodes(throw_error);
    // addr and data channels should have the same source
    is_ok &amp;= (a_source == d_source);
    if (!is_ok &amp;&amp; throw_error)
      `uvm_error(`gfn, $sformatf(&quot;a_source: 0x%0h &amp; d_source: 0x%0h mismatch&quot;, a_source, d_source))
  endfunction

  // Compute and check the integrity of the a_channel payload.
  //
  // The TL agent is generic and adheres to the TLUL spec, which does not define
  // how the integrity of the payload on each channel is computed / checked. That
  // is up to the chip implementation. Typically, parity / ECC scheme is used, with
  // the redundant bits transmitted through *_user.
  //
  // Returns 1 if the integrity of a_channel is maintained, 0 otherwise. This base
  // class implementation vacuously returns 1.
  virtual function bit is_a_chan_intg_ok(bit throw_error = 1&#39;b1);
    return 1;
  endfunction

  // d_channel version of the function above
  virtual function bit is_d_chan_intg_ok(bit throw_error = 1&#39;b1);
    return 1;
  endfunction
endclass

`undef chk_prot_a_opcode
`undef chk_prot_mask_w_PutFullData
`undef chk_prot_addr_mask_align
`undef chk_prot_mask_in_enabled_lanes
`undef chk_prot_addr_size_align
`undef chk_prot_max_size
Re-formatted:
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// ---------------------------------------------
// TileLink sequence item
// ---------------------------------------------

// use macro to write constraint in order to reuse in functions:
// get_exp_d_error and randomize_a_chan_with_protocol_error
`define chk_prot_a_opcode \
  a_opcode inside {Get, PutFullData, PutPartialData}

// For PutFullData message, mask needs to match with size
`define chk_prot_mask_w_PutFullData \
  a_opcode != PutFullData || $countones(a_mask) == (1 &lt;&lt; a_size)

// mask must align with addr, same as below
//   a_addr[1:0] == 1 -&gt; a_mask[0]   == 0;
//   a_addr[1:0] == 2 -&gt; a_mask[1:0] == 0;
//   a_addr[1:0] == 3 -&gt; a_mask[2:0] == 0;
`define chk_prot_addr_mask_align \
  MaskWidth&#39;(a_mask &lt;&lt; (4 - a_addr[SizeWidth-1:0])) == 0

// mask must be within enabled lanes
// prevent cases: addr: 0h, size: 1, mask: &#39;b1100; addr: 0h, size: 0, mask: &#39;b1000
`define chk_prot_mask_in_enabled_lanes \
  ((a_mask &gt;&gt; a_addr[SizeWidth-1:0]) &gt;&gt; (1 &lt;&lt; a_size)) == 0

// Address must be aligned to the a_size (2 ** a_size bytes)
`define chk_prot_addr_size_align \
  (a_addr &lt;&lt; (AddrWidth - a_size)) == 0

// max size is 2
`define chk_prot_max_size \
  a_size &lt;= 2

class tl_seq_item extends uvm_sequence_item;

  rand bit [AddrWidth - 1 : 0]   a_addr;
  rand bit [DataWidth - 1 : 0]   a_data;
  rand bit [MaskWidth - 1 : 0]   a_mask;
  rand bit [SizeWidth - 1 : 0]   a_size;
  rand bit [2:0]                 a_param;
  rand bit [SourceWidth - 1 : 0] a_source;
  rand bit [OpcodeWidth - 1 : 0] a_opcode;
  rand bit [AUserWidth - 1 : 0]  a_user;

  rand bit [2:0]                 d_param;
  rand bit [DataWidth - 1 : 0]   d_data;
  rand bit [SourceWidth - 1 : 0] d_source;
  rand bit [SizeWidth - 1 : 0]   d_size;
  rand bit [OpcodeWidth - 1 : 0] d_opcode;
  rand bit                       d_error;
  rand bit [DUserWidth - 1 : 0]  d_user;
  rand bit                       d_sink;

  // host mode delays
  rand int unsigned              a_valid_delay;
  rand int unsigned              a_valid_len;

  // device mode delays
  rand int unsigned              d_valid_delay;
  rand int unsigned              d_valid_len;

  // Indicates a_source val is overridden.
  //
  // a_source is randomized and set in tl_host_base_seq::finish_item() to facilitate late
  // randomization. If this bit is set, the a_source is assumed to be set to a fixed value instead.
  // It is possible that this fixed value might match one of the pending reqs in the that has not
  // yet completed. The driver can then use this bit to add more delays if needed before sending
  // this request, to avoid protocol violation.
  bit                            a_source_is_overridden;

  // after given valid_len, end the req/rsp if it&#39;s not accepted, which allows seq to switch
  // content and test unaccepted item shouldn&#39;t be used in design
  bit                            req_abort_after_a_valid_len;
  bit                            rsp_abort_after_d_valid_len;
  // True if the item is completed, not aborted
  bit                            req_completed;
  bit                            rsp_completed;

  // param is reserved for future use, must be zero
  constraint param_c {
    a_param == 0;
    d_param == 0;
  }

  constraint no_d_error_c {soft d_error == 0;}

  constraint a_valid_len_c {soft a_valid_len inside {[1 : 10]};}

  constraint d_valid_len_c {soft d_valid_len inside {[1 : 10]};}

  constraint valid_delay_c {
    soft a_valid_delay inside {[0 : 50]};
    soft d_valid_delay inside {[0 : 50]};
  }

  constraint d_opcode_c {d_opcode inside {AccessAckData, AccessAck};}

  constraint a_opcode_c {`chk_prot_a_opcode;}

  // mask must be contiguous, e.g. &#39;b1001, &#39;b1010 aren&#39;t allowed
  constraint mask_contiguous_c {
    $countones(
        a_mask ^ {a_mask[MaskWidth-2:0], 1&#39;b0}
    ) &lt;= 2;
  }

  constraint mask_w_PutFullData_c {`chk_prot_mask_w_PutFullData;}

  constraint addr_mask_align_c {`chk_prot_addr_mask_align;}

  constraint mask_in_enabled_lanes_c {`chk_prot_mask_in_enabled_lanes;}

  constraint addr_size_align_c {`chk_prot_addr_size_align;}

  // size can&#39;t be more than 2
  constraint max_size_c {`chk_prot_max_size;}

  `uvm_object_utils_begin(tl_seq_item)
    `uvm_field_int(a_addr, UVM_DEFAULT)
    `uvm_field_int(a_data, UVM_DEFAULT)
    `uvm_field_int(a_mask, UVM_DEFAULT)
    `uvm_field_int(a_size, UVM_DEFAULT)
    `uvm_field_int(a_param, UVM_DEFAULT)
    `uvm_field_int(a_source, UVM_DEFAULT)
    `uvm_field_int(a_opcode, UVM_DEFAULT)
    `uvm_field_int(a_user, UVM_DEFAULT)
    `uvm_field_int(d_param, UVM_DEFAULT)
    `uvm_field_int(d_source, UVM_DEFAULT)
    `uvm_field_int(d_data, UVM_DEFAULT)
    `uvm_field_int(d_size, UVM_DEFAULT)
    `uvm_field_int(d_opcode, UVM_DEFAULT)
    `uvm_field_int(d_error, UVM_DEFAULT)
    `uvm_field_int(d_sink, UVM_DEFAULT)
    `uvm_field_int(d_user, UVM_DEFAULT)
    `uvm_field_int(a_source_is_overridden, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(a_valid_delay, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(d_valid_delay, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(a_valid_len, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(d_valid_len, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(req_abort_after_a_valid_len, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(rsp_abort_after_d_valid_len, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(req_completed, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(rsp_completed, UVM_DEFAULT | UVM_NOPACK)
  `uvm_object_utils_end

  function new(string name = &quot;&quot;);
    super.new(name);
  endfunction : new

  virtual function string convert2string();
    string str;
    string a_opcode_name, d_opcode_name;
    tl_a_op_e a_op_e;
    tl_d_op_e d_op_e;
    if ($cast(a_op_e, a_opcode)) a_opcode_name = a_op_e.name();
    else a_opcode_name = $sformatf(&quot;Invalid, value: %0d&quot;, a_opcode);
    if ($cast(d_op_e, d_opcode)) d_opcode_name = d_op_e.name();
    else d_opcode_name = $sformatf(&quot;Invalid, value: %0d&quot;, d_opcode);

    str = {
      $sformatf(&quot;a_addr = 0x%0h &quot;, a_addr),
      $sformatf(&quot;a_data = 0x%0h &quot;, a_data),
      $sformatf(&quot;a_mask = 0x%0h &quot;, a_mask),
      $sformatf(&quot;a_size = 0x%0h &quot;, a_size),
      $sformatf(&quot;a_param = 0x%0h &quot;, a_param),
      $sformatf(&quot;a_source = 0x%0h &quot;, a_source),
      $sformatf(&quot;a_opcode = %0s &quot;, a_opcode_name),
      $sformatf(&quot;a_user = 0x%0h &quot;, a_user),
      $sformatf(&quot;d_data = 0x%0h &quot;, d_data),
      $sformatf(&quot;d_size = 0x%0h &quot;, d_size),
      $sformatf(&quot;d_param = 0x%0h &quot;, d_param),
      $sformatf(&quot;d_source = 0x%0h &quot;, d_source),
      $sformatf(&quot;d_opcode = %0s &quot;, d_opcode_name),
      $sformatf(&quot;d_error = %0b &quot;, d_error),
      $sformatf(&quot;d_user = %0b &quot;, d_user),
      $sformatf(&quot;d_sink = %0b &quot;, d_sink),
      $sformatf(&quot;req_abort_after_a_valid_len = %0b &quot;, req_abort_after_a_valid_len),
      $sformatf(&quot;rsp_abort_after_d_valid_len = %0b &quot;, rsp_abort_after_d_valid_len),
      $sformatf(&quot;req_completed = %0b &quot;, req_completed),
      $sformatf(&quot;rsp_completed = %0b &quot;, rsp_completed)
    };
    return str;
  endfunction

  function void disable_a_chan_randomization();
    a_addr.rand_mode(0);
    a_data.rand_mode(0);
    a_mask.rand_mode(0);
    a_size.rand_mode(0);
    a_param.rand_mode(0);
    a_source.rand_mode(0);
    a_opcode.rand_mode(0);
  endfunction

  // calculate d_error based on values of a_chan
  function bit get_exp_d_error();
    return get_error_a_opcode_invalid() || get_error_PutFullData_mask_size_mismatched() ||
           get_error_addr_mask_misaligned() || get_error_addr_size_misaligned() ||
           get_error_mask_not_in_enabled_lanes() || get_error_size_over_max();
  endfunction

  function bit get_error_a_opcode_invalid();
    return !(`chk_prot_a_opcode);
  endfunction

  function bit get_error_PutFullData_mask_size_mismatched();
    return !(`chk_prot_mask_w_PutFullData);
  endfunction

  function bit get_error_addr_mask_misaligned();
    return !(`chk_prot_addr_mask_align);
  endfunction

  function bit get_error_addr_size_misaligned();
    return !(`chk_prot_addr_size_align);
  endfunction

  function bit get_error_mask_not_in_enabled_lanes();
    return !(`chk_prot_mask_in_enabled_lanes);
  endfunction

  function bit get_error_size_over_max();
    return !(`chk_prot_max_size);
  endfunction  // get_error_size_over_max

  function void disable_a_chan_protocol_constraint();
    a_opcode_c.constraint_mode(0);
    mask_contiguous_c.constraint_mode(0);
    mask_w_PutFullData_c.constraint_mode(0);
    addr_mask_align_c.constraint_mode(0);
    mask_in_enabled_lanes_c.constraint_mode(0);
    addr_size_align_c.constraint_mode(0);
    max_size_c.constraint_mode(0);
  endfunction

  // randomly disable constraint_mode for a chan
  // at least one constraint_mode needs to be disabled to make sure protocol is violated
  function void randomize_a_chan_with_protocol_error();
    bit cm_a_opcode, cm_mask_w_PutFullData;
    bit cm_addr_mask_align, cm_mask_in_enabled_lanes, cm_addr_size_align, cm_max_size;
    `DV_CHECK_FATAL(std::randomize(
                    cm_a_opcode,
                    cm_mask_w_PutFullData,
                    cm_addr_mask_align,
                    cm_mask_in_enabled_lanes,
                    cm_addr_size_align,
                    cm_max_size
                    ) with {
                    // at least one constraint_mode is off
                    !(cm_a_opcode &amp;&amp; cm_mask_w_PutFullData &amp;&amp;
                                   cm_addr_mask_align &amp;&amp; cm_mask_in_enabled_lanes &amp;&amp;
                                   cm_addr_size_align &amp;&amp; cm_max_size);
                    })
    a_opcode_c.constraint_mode(cm_a_opcode);
    mask_w_PutFullData_c.constraint_mode(cm_mask_w_PutFullData);
    addr_mask_align_c.constraint_mode(cm_addr_mask_align);
    mask_in_enabled_lanes_c.constraint_mode(cm_mask_in_enabled_lanes);
    addr_size_align_c.constraint_mode(cm_addr_size_align);
    max_size_c.constraint_mode(cm_max_size);
    `DV_CHECK_FATAL(  // at least one `chk_prot_* is violated
        randomize() with {
        !cm_a_opcode              &amp;&amp; !(`chk_prot_a_opcode)              ||
                          !cm_mask_w_PutFullData    &amp;&amp; !(`chk_prot_mask_w_PutFullData)    ||
                          !cm_addr_mask_align       &amp;&amp; !(`chk_prot_addr_mask_align)       ||
                          !cm_mask_in_enabled_lanes &amp;&amp; !(`chk_prot_mask_in_enabled_lanes) ||
                          !cm_addr_size_align       &amp;&amp; !(`chk_prot_addr_size_align)       ||
                          !cm_max_size              &amp;&amp; !(`chk_prot_max_size);
        })
  endfunction

  // Find whether this seq item is a read or a write.
  virtual function bit is_write();
    return (a_opcode inside {PutFullData, PutPartialData});
  endfunction

  // Check if d_opcode is appropriate for the given a_opcode. This check assumes that the
  // response packet has been appended with the corresponding request.
  virtual function bit check_opcodes(bit throw_error = 1&#39;b1);
    // for read, return AccessAckData; for write or error opcode, return AccessAck
    tl_d_op_e exp_d_opcode = a_opcode == Get ? tlul_pkg::AccessAckData : tlul_pkg::AccessAck;
    check_opcodes = (d_opcode == int&#39;(exp_d_opcode));
    if (!check_opcodes &amp;&amp; throw_error) begin
      `uvm_error(`gfn, $sformatf(
                 &quot;d_opcode: %0d &amp; exp_d_opcode: %0d mismatch&quot;, d_opcode, exp_d_opcode))
    end
  endfunction

  // Check if packet parameters are ok.
  virtual function bit is_ok(bit throw_error = 1&#39;b1);
    is_ok = 1&#39;b1;
    is_ok &amp;= check_opcodes(throw_error);
    // addr and data channels should have the same source
    is_ok &amp;= (a_source == d_source);
    if (!is_ok &amp;&amp; throw_error)
      `uvm_error(`gfn, $sformatf(&quot;a_source: 0x%0h &amp; d_source: 0x%0h mismatch&quot;, a_source, d_source))
  endfunction

  // Compute and check the integrity of the a_channel payload.
  //
  // The TL agent is generic and adheres to the TLUL spec, which does not define
  // how the integrity of the payload on each channel is computed / checked. That
  // is up to the chip implementation. Typically, parity / ECC scheme is used, with
  // the redundant bits transmitted through *_user.
  //
  // Returns 1 if the integrity of a_channel is maintained, 0 otherwise. This base
  // class implementation vacuously returns 1.
  virtual function bit is_a_chan_intg_ok(bit throw_error = 1&#39;b1);
    return 1;
  endfunction

  // d_channel version of the function above
  virtual function bit is_d_chan_intg_ok(bit throw_error = 1&#39;b1);
    return 1;
  endfunction
endclass

`undef chk_prot_a_opcode
`undef chk_prot_mask_w_PutFullData
`undef chk_prot_addr_mask_align
`undef chk_prot_mask_in_enabled_lanes
`undef chk_prot_addr_size_align
`undef chk_prot_max_size
Diffs are:
 // Copyright lowRISC contributors.
 // Licensed under the Apache License, Version 2.0, see LICENSE for details.
 // SPDX-License-Identifier: Apache-2.0

 // ---------------------------------------------
 // TileLink sequence item
 // ---------------------------------------------

 // use macro to write constraint in order to reuse in functions:
 // get_exp_d_error and randomize_a_chan_with_protocol_error
 `define chk_prot_a_opcode \
   a_opcode inside {Get, PutFullData, PutPartialData}

 // For PutFullData message, mask needs to match with size
 `define chk_prot_mask_w_PutFullData \
   a_opcode != PutFullData || $countones(a_mask) == (1 &lt;&lt; a_size)

 // mask must align with addr, same as below
 //   a_addr[1:0] == 1 -&gt; a_mask[0]   == 0;
 //   a_addr[1:0] == 2 -&gt; a_mask[1:0] == 0;
 //   a_addr[1:0] == 3 -&gt; a_mask[2:0] == 0;
 `define chk_prot_addr_mask_align \
   MaskWidth&#39;(a_mask &lt;&lt; (4 - a_addr[SizeWidth-1:0])) == 0

 // mask must be within enabled lanes
 // prevent cases: addr: 0h, size: 1, mask: &#39;b1100; addr: 0h, size: 0, mask: &#39;b1000
 `define chk_prot_mask_in_enabled_lanes \
   ((a_mask &gt;&gt; a_addr[SizeWidth-1:0]) &gt;&gt; (1 &lt;&lt; a_size)) == 0

 // Address must be aligned to the a_size (2 ** a_size bytes)
 `define chk_prot_addr_size_align \
   (a_addr &lt;&lt; (AddrWidth - a_size)) == 0

 // max size is 2
 `define chk_prot_max_size \
   a_size &lt;= 2

 class tl_seq_item extends uvm_sequence_item;

   rand bit [AddrWidth - 1 : 0]   a_addr;
   rand bit [DataWidth - 1 : 0]   a_data;
   rand bit [MaskWidth - 1 : 0]   a_mask;
   rand bit [SizeWidth - 1 : 0]   a_size;
   rand bit [2:0]                 a_param;
   rand bit [SourceWidth - 1 : 0] a_source;
   rand bit [OpcodeWidth - 1 : 0] a_opcode;
   rand bit [AUserWidth - 1 : 0]  a_user;

   rand bit [2:0]                 d_param;
   rand bit [DataWidth - 1 : 0]   d_data;
   rand bit [SourceWidth - 1 : 0] d_source;
   rand bit [SizeWidth - 1 : 0]   d_size;
   rand bit [OpcodeWidth - 1 : 0] d_opcode;
   rand bit                       d_error;
   rand bit [DUserWidth - 1 : 0]  d_user;
   rand bit                       d_sink;

   // host mode delays
   rand int unsigned              a_valid_delay;
   rand int unsigned              a_valid_len;

   // device mode delays
   rand int unsigned              d_valid_delay;
   rand int unsigned              d_valid_len;

   // Indicates a_source val is overridden.
   //
   // a_source is randomized and set in tl_host_base_seq::finish_item() to facilitate late
   // randomization. If this bit is set, the a_source is assumed to be set to a fixed value instead.
   // It is possible that this fixed value might match one of the pending reqs in the that has not
   // yet completed. The driver can then use this bit to add more delays if needed before sending
   // this request, to avoid protocol violation.
   bit                            a_source_is_overridden;

   // after given valid_len, end the req/rsp if it&#39;s not accepted, which allows seq to switch
   // content and test unaccepted item shouldn&#39;t be used in design
   bit                            req_abort_after_a_valid_len;
   bit                            rsp_abort_after_d_valid_len;
   // True if the item is completed, not aborted
   bit                            req_completed;
   bit                            rsp_completed;

   // param is reserved for future use, must be zero
   constraint param_c {
     a_param == 0;
     d_param == 0;
   }

   constraint no_d_error_c {soft d_error == 0;}

   constraint a_valid_len_c {soft a_valid_len inside {[1 : 10]};}

   constraint d_valid_len_c {soft d_valid_len inside {[1 : 10]};}

   constraint valid_delay_c {
     soft a_valid_delay inside {[0 : 50]};
     soft d_valid_delay inside {[0 : 50]};
   }

   constraint d_opcode_c {d_opcode inside {AccessAckData, AccessAck};}

   constraint a_opcode_c {`chk_prot_a_opcode;}

   // mask must be contiguous, e.g. &#39;b1001, &#39;b1010 aren&#39;t allowed
   constraint mask_contiguous_c {
     $countones(
         a_mask ^ {a_mask[MaskWidth-2:0], 1&#39;b0}
     ) &lt;= 2;
   }

   constraint mask_w_PutFullData_c {`chk_prot_mask_w_PutFullData;}

   constraint addr_mask_align_c {`chk_prot_addr_mask_align;}

   constraint mask_in_enabled_lanes_c {`chk_prot_mask_in_enabled_lanes;}

   constraint addr_size_align_c {`chk_prot_addr_size_align;}

   // size can&#39;t be more than 2
   constraint max_size_c {`chk_prot_max_size;}

   `uvm_object_utils_begin(tl_seq_item)
     `uvm_field_int(a_addr, UVM_DEFAULT)
     `uvm_field_int(a_data, UVM_DEFAULT)
     `uvm_field_int(a_mask, UVM_DEFAULT)
     `uvm_field_int(a_size, UVM_DEFAULT)
     `uvm_field_int(a_param, UVM_DEFAULT)
     `uvm_field_int(a_source, UVM_DEFAULT)
     `uvm_field_int(a_opcode, UVM_DEFAULT)
     `uvm_field_int(a_user, UVM_DEFAULT)
     `uvm_field_int(d_param, UVM_DEFAULT)
     `uvm_field_int(d_source, UVM_DEFAULT)
     `uvm_field_int(d_data, UVM_DEFAULT)
     `uvm_field_int(d_size, UVM_DEFAULT)
     `uvm_field_int(d_opcode, UVM_DEFAULT)
     `uvm_field_int(d_error, UVM_DEFAULT)
     `uvm_field_int(d_sink, UVM_DEFAULT)
     `uvm_field_int(d_user, UVM_DEFAULT)
     `uvm_field_int(a_source_is_overridden, UVM_DEFAULT | UVM_NOPACK)
     `uvm_field_int(a_valid_delay, UVM_DEFAULT | UVM_NOPACK)
     `uvm_field_int(d_valid_delay, UVM_DEFAULT | UVM_NOPACK)
     `uvm_field_int(a_valid_len, UVM_DEFAULT | UVM_NOPACK)
     `uvm_field_int(d_valid_len, UVM_DEFAULT | UVM_NOPACK)
     `uvm_field_int(req_abort_after_a_valid_len, UVM_DEFAULT | UVM_NOPACK)
     `uvm_field_int(rsp_abort_after_d_valid_len, UVM_DEFAULT | UVM_NOPACK)
     `uvm_field_int(req_completed, UVM_DEFAULT | UVM_NOPACK)
     `uvm_field_int(rsp_completed, UVM_DEFAULT | UVM_NOPACK)
   `uvm_object_utils_end

   function new(string name = &quot;&quot;);
     super.new(name);
   endfunction : new

   virtual function string convert2string();
     string str;
     string a_opcode_name, d_opcode_name;
     tl_a_op_e a_op_e;
     tl_d_op_e d_op_e;
     if ($cast(a_op_e, a_opcode)) a_opcode_name = a_op_e.name();
     else a_opcode_name = $sformatf(&quot;Invalid, value: %0d&quot;, a_opcode);
     if ($cast(d_op_e, d_opcode)) d_opcode_name = d_op_e.name();
     else d_opcode_name = $sformatf(&quot;Invalid, value: %0d&quot;, d_opcode);

     str = {
       $sformatf(&quot;a_addr = 0x%0h &quot;, a_addr),
       $sformatf(&quot;a_data = 0x%0h &quot;, a_data),
       $sformatf(&quot;a_mask = 0x%0h &quot;, a_mask),
       $sformatf(&quot;a_size = 0x%0h &quot;, a_size),
       $sformatf(&quot;a_param = 0x%0h &quot;, a_param),
       $sformatf(&quot;a_source = 0x%0h &quot;, a_source),
       $sformatf(&quot;a_opcode = %0s &quot;, a_opcode_name),
       $sformatf(&quot;a_user = 0x%0h &quot;, a_user),
       $sformatf(&quot;d_data = 0x%0h &quot;, d_data),
       $sformatf(&quot;d_size = 0x%0h &quot;, d_size),
       $sformatf(&quot;d_param = 0x%0h &quot;, d_param),
       $sformatf(&quot;d_source = 0x%0h &quot;, d_source),
       $sformatf(&quot;d_opcode = %0s &quot;, d_opcode_name),
       $sformatf(&quot;d_error = %0b &quot;, d_error),
       $sformatf(&quot;d_user = %0b &quot;, d_user),
       $sformatf(&quot;d_sink = %0b &quot;, d_sink),
       $sformatf(&quot;req_abort_after_a_valid_len = %0b &quot;, req_abort_after_a_valid_len),
       $sformatf(&quot;rsp_abort_after_d_valid_len = %0b &quot;, rsp_abort_after_d_valid_len),
       $sformatf(&quot;req_completed = %0b &quot;, req_completed),
       $sformatf(&quot;rsp_completed = %0b &quot;, rsp_completed)
     };
     return str;
   endfunction

   function void disable_a_chan_randomization();
     a_addr.rand_mode(0);
     a_data.rand_mode(0);
     a_mask.rand_mode(0);
     a_size.rand_mode(0);
     a_param.rand_mode(0);
     a_source.rand_mode(0);
     a_opcode.rand_mode(0);
   endfunction

   // calculate d_error based on values of a_chan
   function bit get_exp_d_error();
     return get_error_a_opcode_invalid() || get_error_PutFullData_mask_size_mismatched() ||
            get_error_addr_mask_misaligned() || get_error_addr_size_misaligned() ||
            get_error_mask_not_in_enabled_lanes() || get_error_size_over_max();
   endfunction

   function bit get_error_a_opcode_invalid();
     return !(`chk_prot_a_opcode);
   endfunction

   function bit get_error_PutFullData_mask_size_mismatched();
     return !(`chk_prot_mask_w_PutFullData);
   endfunction

   function bit get_error_addr_mask_misaligned();
     return !(`chk_prot_addr_mask_align);
   endfunction

   function bit get_error_addr_size_misaligned();
     return !(`chk_prot_addr_size_align);
   endfunction

   function bit get_error_mask_not_in_enabled_lanes();
     return !(`chk_prot_mask_in_enabled_lanes);
   endfunction

   function bit get_error_size_over_max();
     return !(`chk_prot_max_size);
   endfunction  // get_error_size_over_max

   function void disable_a_chan_protocol_constraint();
     a_opcode_c.constraint_mode(0);
     mask_contiguous_c.constraint_mode(0);
     mask_w_PutFullData_c.constraint_mode(0);
     addr_mask_align_c.constraint_mode(0);
     mask_in_enabled_lanes_c.constraint_mode(0);
     addr_size_align_c.constraint_mode(0);
     max_size_c.constraint_mode(0);
   endfunction

   // randomly disable constraint_mode for a chan
   // at least one constraint_mode needs to be disabled to make sure protocol is violated
   function void randomize_a_chan_with_protocol_error();
     bit cm_a_opcode, cm_mask_w_PutFullData;
     bit cm_addr_mask_align, cm_mask_in_enabled_lanes, cm_addr_size_align, cm_max_size;
     `DV_CHECK_FATAL(std::randomize(
                     cm_a_opcode,
                     cm_mask_w_PutFullData,
                     cm_addr_mask_align,
                     cm_mask_in_enabled_lanes,
                     cm_addr_size_align,
                     cm_max_size
                     ) with {
                     // at least one constraint_mode is off
                     !(cm_a_opcode &amp;&amp; cm_mask_w_PutFullData &amp;&amp;
                                    cm_addr_mask_align &amp;&amp; cm_mask_in_enabled_lanes &amp;&amp;
                                    cm_addr_size_align &amp;&amp; cm_max_size);
                     })
     a_opcode_c.constraint_mode(cm_a_opcode);
     mask_w_PutFullData_c.constraint_mode(cm_mask_w_PutFullData);
     addr_mask_align_c.constraint_mode(cm_addr_mask_align);
     mask_in_enabled_lanes_c.constraint_mode(cm_mask_in_enabled_lanes);
     addr_size_align_c.constraint_mode(cm_addr_size_align);
     max_size_c.constraint_mode(cm_max_size);
     `DV_CHECK_FATAL(  // at least one `chk_prot_* is violated
-                    randomize() with {
-                    !cm_a_opcode              &amp;&amp; !(`chk_prot_a_opcode)              ||
+        randomize() with {
+        !cm_a_opcode              &amp;&amp; !(`chk_prot_a_opcode)              ||
                           !cm_mask_w_PutFullData    &amp;&amp; !(`chk_prot_mask_w_PutFullData)    ||
                           !cm_addr_mask_align       &amp;&amp; !(`chk_prot_addr_mask_align)       ||
                           !cm_mask_in_enabled_lanes &amp;&amp; !(`chk_prot_mask_in_enabled_lanes) ||
                           !cm_addr_size_align       &amp;&amp; !(`chk_prot_addr_size_align)       ||
                           !cm_max_size              &amp;&amp; !(`chk_prot_max_size);
+        })
-                    })
   endfunction

   // Find whether this seq item is a read or a write.
   virtual function bit is_write();
     return (a_opcode inside {PutFullData, PutPartialData});
   endfunction

   // Check if d_opcode is appropriate for the given a_opcode. This check assumes that the
   // response packet has been appended with the corresponding request.
   virtual function bit check_opcodes(bit throw_error = 1&#39;b1);
     // for read, return AccessAckData; for write or error opcode, return AccessAck
     tl_d_op_e exp_d_opcode = a_opcode == Get ? tlul_pkg::AccessAckData : tlul_pkg::AccessAck;
     check_opcodes = (d_opcode == int&#39;(exp_d_opcode));
     if (!check_opcodes &amp;&amp; throw_error) begin
       `uvm_error(`gfn, $sformatf(
                  &quot;d_opcode: %0d &amp; exp_d_opcode: %0d mismatch&quot;, d_opcode, exp_d_opcode))
     end
   endfunction

   // Check if packet parameters are ok.
   virtual function bit is_ok(bit throw_error = 1&#39;b1);
     is_ok = 1&#39;b1;
     is_ok &amp;= check_opcodes(throw_error);
     // addr and data channels should have the same source
     is_ok &amp;= (a_source == d_source);
     if (!is_ok &amp;&amp; throw_error)
       `uvm_error(`gfn, $sformatf(&quot;a_source: 0x%0h &amp; d_source: 0x%0h mismatch&quot;, a_source, d_source))
   endfunction

   // Compute and check the integrity of the a_channel payload.
   //
   // The TL agent is generic and adheres to the TLUL spec, which does not define
   // how the integrity of the payload on each channel is computed / checked. That
   // is up to the chip implementation. Typically, parity / ECC scheme is used, with
   // the redundant bits transmitted through *_user.
   //
   // Returns 1 if the integrity of a_channel is maintained, 0 otherwise. This base
   // class implementation vacuously returns 1.
   virtual function bit is_a_chan_intg_ok(bit throw_error = 1&#39;b1);
     return 1;
   endfunction

   // d_channel version of the function above
   virtual function bit is_d_chan_intg_ok(bit throw_error = 1&#39;b1);
     return 1;
   endfunction
 endclass

 `undef chk_prot_a_opcode
 `undef chk_prot_mask_w_PutFullData
 `undef chk_prot_addr_mask_align
 `undef chk_prot_mask_in_enabled_lanes
 `undef chk_prot_addr_size_align
 `undef chk_prot_max_size
; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// ---------------------------------------------
// TileLink sequence item
// ---------------------------------------------

// use macro to write constraint in order to reuse in functions:
// get_exp_d_error and randomize_a_chan_with_protocol_error
`define chk_prot_a_opcode \
  a_opcode inside {Get, PutFullData, PutPartialData}

// For PutFullData message, mask needs to match with size
`define chk_prot_mask_w_PutFullData \
  a_opcode != PutFullData || $countones(a_mask) == (1 &lt;&lt; a_size)

// mask must align with addr, same as below
//   a_addr[1:0] == 1 -&gt; a_mask[0]   == 0;
//   a_addr[1:0] == 2 -&gt; a_mask[1:0] == 0;
//   a_addr[1:0] == 3 -&gt; a_mask[2:0] == 0;
`define chk_prot_addr_mask_align \
  MaskWidth&#39;(a_mask &lt;&lt; (4 - a_addr[SizeWidth-1:0])) == 0

// mask must be within enabled lanes
// prevent cases: addr: 0h, size: 1, mask: &#39;b1100; addr: 0h, size: 0, mask: &#39;b1000
`define chk_prot_mask_in_enabled_lanes \
  ((a_mask &gt;&gt; a_addr[SizeWidth-1:0]) &gt;&gt; (1 &lt;&lt; a_size)) == 0

// Address must be aligned to the a_size (2 ** a_size bytes)
`define chk_prot_addr_size_align \
  (a_addr &lt;&lt; (AddrWidth - a_size)) == 0

// max size is 2
`define chk_prot_max_size \
  a_size &lt;= 2

class tl_seq_item extends uvm_sequence_item;

  rand bit [AddrWidth - 1 : 0]   a_addr;
  rand bit [DataWidth - 1 : 0]   a_data;
  rand bit [MaskWidth - 1 : 0]   a_mask;
  rand bit [SizeWidth - 1 : 0]   a_size;
  rand bit [2:0]                 a_param;
  rand bit [SourceWidth - 1 : 0] a_source;
  rand bit [OpcodeWidth - 1 : 0] a_opcode;
  rand bit [AUserWidth - 1 : 0]  a_user;

  rand bit [2:0]                 d_param;
  rand bit [DataWidth - 1 : 0]   d_data;
  rand bit [SourceWidth - 1 : 0] d_source;
  rand bit [SizeWidth - 1 : 0]   d_size;
  rand bit [OpcodeWidth - 1 : 0] d_opcode;
  rand bit                       d_error;
  rand bit [DUserWidth - 1 : 0]  d_user;
  rand bit                       d_sink;

  // host mode delays
  rand int unsigned              a_valid_delay;
  rand int unsigned              a_valid_len;

  // device mode delays
  rand int unsigned              d_valid_delay;
  rand int unsigned              d_valid_len;

  // Indicates a_source val is overridden.
  //
  // a_source is randomized and set in tl_host_base_seq::finish_item() to facilitate late
  // randomization. If this bit is set, the a_source is assumed to be set to a fixed value instead.
  // It is possible that this fixed value might match one of the pending reqs in the that has not
  // yet completed. The driver can then use this bit to add more delays if needed before sending
  // this request, to avoid protocol violation.
  bit                            a_source_is_overridden;

  // after given valid_len, end the req/rsp if it&#39;s not accepted, which allows seq to switch
  // content and test unaccepted item shouldn&#39;t be used in design
  bit                            req_abort_after_a_valid_len;
  bit                            rsp_abort_after_d_valid_len;
  // True if the item is completed, not aborted
  bit                            req_completed;
  bit                            rsp_completed;

  // param is reserved for future use, must be zero
  constraint param_c {
    a_param == 0;
    d_param == 0;
  }

  constraint no_d_error_c {soft d_error == 0;}

  constraint a_valid_len_c {soft a_valid_len inside {[1 : 10]};}

  constraint d_valid_len_c {soft d_valid_len inside {[1 : 10]};}

  constraint valid_delay_c {
    soft a_valid_delay inside {[0 : 50]};
    soft d_valid_delay inside {[0 : 50]};
  }

  constraint d_opcode_c {d_opcode inside {AccessAckData, AccessAck};}

  constraint a_opcode_c {`chk_prot_a_opcode;}

  // mask must be contiguous, e.g. &#39;b1001, &#39;b1010 aren&#39;t allowed
  constraint mask_contiguous_c {
    $countones(
        a_mask ^ {a_mask[MaskWidth-2:0], 1&#39;b0}
    ) &lt;= 2;
  }

  constraint mask_w_PutFullData_c {`chk_prot_mask_w_PutFullData;}

  constraint addr_mask_align_c {`chk_prot_addr_mask_align;}

  constraint mask_in_enabled_lanes_c {`chk_prot_mask_in_enabled_lanes;}

  constraint addr_size_align_c {`chk_prot_addr_size_align;}

  // size can&#39;t be more than 2
  constraint max_size_c {`chk_prot_max_size;}

  `uvm_object_utils_begin(tl_seq_item)
    `uvm_field_int(a_addr, UVM_DEFAULT)
    `uvm_field_int(a_data, UVM_DEFAULT)
    `uvm_field_int(a_mask, UVM_DEFAULT)
    `uvm_field_int(a_size, UVM_DEFAULT)
    `uvm_field_int(a_param, UVM_DEFAULT)
    `uvm_field_int(a_source, UVM_DEFAULT)
    `uvm_field_int(a_opcode, UVM_DEFAULT)
    `uvm_field_int(a_user, UVM_DEFAULT)
    `uvm_field_int(d_param, UVM_DEFAULT)
    `uvm_field_int(d_source, UVM_DEFAULT)
    `uvm_field_int(d_data, UVM_DEFAULT)
    `uvm_field_int(d_size, UVM_DEFAULT)
    `uvm_field_int(d_opcode, UVM_DEFAULT)
    `uvm_field_int(d_error, UVM_DEFAULT)
    `uvm_field_int(d_sink, UVM_DEFAULT)
    `uvm_field_int(d_user, UVM_DEFAULT)
    `uvm_field_int(a_source_is_overridden, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(a_valid_delay, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(d_valid_delay, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(a_valid_len, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(d_valid_len, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(req_abort_after_a_valid_len, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(rsp_abort_after_d_valid_len, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(req_completed, UVM_DEFAULT | UVM_NOPACK)
    `uvm_field_int(rsp_completed, UVM_DEFAULT | UVM_NOPACK)
  `uvm_object_utils_end

  function new(string name = &quot;&quot;);
    super.new(name);
  endfunction : new

  virtual function string convert2string();
    string str;
    string a_opcode_name, d_opcode_name;
    tl_a_op_e a_op_e;
    tl_d_op_e d_op_e;
    if ($cast(a_op_e, a_opcode)) a_opcode_name = a_op_e.name();
    else a_opcode_name = $sformatf(&quot;Invalid, value: %0d&quot;, a_opcode);
    if ($cast(d_op_e, d_opcode)) d_opcode_name = d_op_e.name();
    else d_opcode_name = $sformatf(&quot;Invalid, value: %0d&quot;, d_opcode);

    str = {
      $sformatf(&quot;a_addr = 0x%0h &quot;, a_addr),
      $sformatf(&quot;a_data = 0x%0h &quot;, a_data),
      $sformatf(&quot;a_mask = 0x%0h &quot;, a_mask),
      $sformatf(&quot;a_size = 0x%0h &quot;, a_size),
      $sformatf(&quot;a_param = 0x%0h &quot;, a_param),
      $sformatf(&quot;a_source = 0x%0h &quot;, a_source),
      $sformatf(&quot;a_opcode = %0s &quot;, a_opcode_name),
      $sformatf(&quot;a_user = 0x%0h &quot;, a_user),
      $sformatf(&quot;d_data = 0x%0h &quot;, d_data),
      $sformatf(&quot;d_size = 0x%0h &quot;, d_size),
      $sformatf(&quot;d_param = 0x%0h &quot;, d_param),
      $sformatf(&quot;d_source = 0x%0h &quot;, d_source),
      $sformatf(&quot;d_opcode = %0s &quot;, d_opcode_name),
      $sformatf(&quot;d_error = %0b &quot;, d_error),
      $sformatf(&quot;d_user = %0b &quot;, d_user),
      $sformatf(&quot;d_sink = %0b &quot;, d_sink),
      $sformatf(&quot;req_abort_after_a_valid_len = %0b &quot;, req_abort_after_a_valid_len),
      $sformatf(&quot;rsp_abort_after_d_valid_len = %0b &quot;, rsp_abort_after_d_valid_len),
      $sformatf(&quot;req_completed = %0b &quot;, req_completed),
      $sformatf(&quot;rsp_completed = %0b &quot;, rsp_completed)
    };
    return str;
  endfunction

  function void disable_a_chan_randomization();
    a_addr.rand_mode(0);
    a_data.rand_mode(0);
    a_mask.rand_mode(0);
    a_size.rand_mode(0);
    a_param.rand_mode(0);
    a_source.rand_mode(0);
    a_opcode.rand_mode(0);
  endfunction

  // calculate d_error based on values of a_chan
  function bit get_exp_d_error();
    return get_error_a_opcode_invalid() || get_error_PutFullData_mask_size_mismatched() ||
           get_error_addr_mask_misaligned() || get_error_addr_size_misaligned() ||
           get_error_mask_not_in_enabled_lanes() || get_error_size_over_max();
  endfunction

  function bit get_error_a_opcode_invalid();
    return !(`chk_prot_a_opcode);
  endfunction

  function bit get_error_PutFullData_mask_size_mismatched();
    return !(`chk_prot_mask_w_PutFullData);
  endfunction

  function bit get_error_addr_mask_misaligned();
    return !(`chk_prot_addr_mask_align);
  endfunction

  function bit get_error_addr_size_misaligned();
    return !(`chk_prot_addr_size_align);
  endfunction

  function bit get_error_mask_not_in_enabled_lanes();
    return !(`chk_prot_mask_in_enabled_lanes);
  endfunction

  function bit get_error_size_over_max();
    return !(`chk_prot_max_size);
  endfunction  // get_error_size_over_max

  function void disable_a_chan_protocol_constraint();
    a_opcode_c.constraint_mode(0);
    mask_contiguous_c.constraint_mode(0);
    mask_w_PutFullData_c.constraint_mode(0);
    addr_mask_align_c.constraint_mode(0);
    mask_in_enabled_lanes_c.constraint_mode(0);
    addr_size_align_c.constraint_mode(0);
    max_size_c.constraint_mode(0);
  endfunction

  // randomly disable constraint_mode for a chan
  // at least one constraint_mode needs to be disabled to make sure protocol is violated
  function void randomize_a_chan_with_protocol_error();
    bit cm_a_opcode, cm_mask_w_PutFullData;
    bit cm_addr_mask_align, cm_mask_in_enabled_lanes, cm_addr_size_align, cm_max_size;
    `DV_CHECK_FATAL(std::randomize(
                    cm_a_opcode,
                    cm_mask_w_PutFullData,
                    cm_addr_mask_align,
                    cm_mask_in_enabled_lanes,
                    cm_addr_size_align,
                    cm_max_size
                    ) with {
                    // at least one constraint_mode is off
                    !(cm_a_opcode &amp;&amp; cm_mask_w_PutFullData &amp;&amp;
                                   cm_addr_mask_align &amp;&amp; cm_mask_in_enabled_lanes &amp;&amp;
                                   cm_addr_size_align &amp;&amp; cm_max_size);
                    })
    a_opcode_c.constraint_mode(cm_a_opcode);
    mask_w_PutFullData_c.constraint_mode(cm_mask_w_PutFullData);
    addr_mask_align_c.constraint_mode(cm_addr_mask_align);
    mask_in_enabled_lanes_c.constraint_mode(cm_mask_in_enabled_lanes);
    addr_size_align_c.constraint_mode(cm_addr_size_align);
    max_size_c.constraint_mode(cm_max_size);
    `DV_CHECK_FATAL(  // at least one `chk_prot_* is violated
                    randomize() with {
                    !cm_a_opcode              &amp;&amp; !(`chk_prot_a_opcode)              ||
                          !cm_mask_w_PutFullData    &amp;&amp; !(`chk_prot_mask_w_PutFullData)    ||
                          !cm_addr_mask_align       &amp;&amp; !(`chk_prot_addr_mask_align)       ||
                          !cm_mask_in_enabled_lanes &amp;&amp; !(`chk_prot_mask_in_enabled_lanes) ||
                          !cm_addr_size_align       &amp;&amp; !(`chk_prot_addr_size_align)       ||
                          !cm_max_size              &amp;&amp; !(`chk_prot_max_size);
                    })
  endfunction

  // Find whether this seq item is a read or a write.
  virtual function bit is_write();
    return (a_opcode inside {PutFullData, PutPartialData});
  endfunction

  // Check if d_opcode is appropriate for the given a_opcode. This check assumes that the
  // response packet has been appended with the corresponding request.
  virtual function bit check_opcodes(bit throw_error = 1&#39;b1);
    // for read, return AccessAckData; for write or error opcode, return AccessAck
    tl_d_op_e exp_d_opcode = a_opcode == Get ? tlul_pkg::AccessAckData : tlul_pkg::AccessAck;
    check_opcodes = (d_opcode == int&#39;(exp_d_opcode));
    if (!check_opcodes &amp;&amp; throw_error) begin
      `uvm_error(`gfn, $sformatf(
                 &quot;d_opcode: %0d &amp; exp_d_opcode: %0d mismatch&quot;, d_opcode, exp_d_opcode))
    end
  endfunction

  // Check if packet parameters are ok.
  virtual function bit is_ok(bit throw_error = 1&#39;b1);
    is_ok = 1&#39;b1;
    is_ok &amp;= check_opcodes(throw_error);
    // addr and data channels should have the same source
    is_ok &amp;= (a_source == d_source);
    if (!is_ok &amp;&amp; throw_error)
      `uvm_error(`gfn, $sformatf(&quot;a_source: 0x%0h &amp; d_source: 0x%0h mismatch&quot;, a_source, d_source))
  endfunction

  // Compute and check the integrity of the a_channel payload.
  //
  // The TL agent is generic and adheres to the TLUL spec, which does not define
  // how the integrity of the payload on each channel is computed / checked. That
  // is up to the chip implementation. Typically, parity / ECC scheme is used, with
  // the redundant bits transmitted through *_user.
  //
  // Returns 1 if the integrity of a_channel is maintained, 0 otherwise. This base
  // class implementation vacuously returns 1.
  virtual function bit is_a_chan_intg_ok(bit throw_error = 1&#39;b1);
    return 1;
  endfunction

  // d_channel version of the function above
  virtual function bit is_d_chan_intg_ok(bit throw_error = 1&#39;b1);
    return 1;
  endfunction
endclass

`undef chk_prot_a_opcode
`undef chk_prot_mask_w_PutFullData
`undef chk_prot_addr_mask_align
`undef chk_prot_mask_in_enabled_lanes
`undef chk_prot_addr_size_align
`undef chk_prot_max_size
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-edn-dv-env-edn-env-cfg-sv">
<span id="error-hw-ip-edn-dv-env-edn-env-cfg-sv"></span><h2>hw/ip/edn/dv/env/edn_env_cfg.sv<a class="headerlink" href="#hw-ip-edn-dv-env-edn-env-cfg-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">edn</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">edn_env_cfg</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span> <span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">edn</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">edn_env_cfg</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;for&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">edn</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">edn_env_cfg</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">edn</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">edn_env_cfg</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;++&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-flash-ctrl-dv-env-seq-lib-flash-ctrl-base-vseq-sv">
<span id="error-hw-ip-flash-ctrl-dv-env-seq-lib-flash-ctrl-base-vseq-sv"></span><h2>hw/ip/flash_ctrl/dv/env/seq_lib/flash_ctrl_base_vseq.sv<a class="headerlink" href="#hw-ip-flash-ctrl-dv-env-seq-lib-flash-ctrl-base-vseq-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/flash_ctrl/dv/env/seq_lib/flash_ctrl_base_vseq.sv: Error lex/parsing-ing formatted output.  Please file a bug.
First error: token: &quot;uvm_reg_data_t&quot; at 107:5-18; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class flash_ctrl_base_vseq extends cip_base_vseq #(
  .RAL_T              (flash_ctrl_core_reg_block),
  .CFG_T              (flash_ctrl_env_cfg),
  .COV_T              (flash_ctrl_env_cov),
  .VIRTUAL_SEQUENCER_T(flash_ctrl_virtual_sequencer)
);
  `uvm_object_utils(flash_ctrl_base_vseq)

  // flash ctrl configuration settings.

  constraint num_trans_c {num_trans inside {[1 : cfg.seq_cfg.max_num_trans]};}

  `uvm_object_new

  virtual task dut_shutdown();
    // check for pending flash_ctrl operations and wait for them to complete
    // TODO
  endtask

  virtual task reset_flash();
    // Set all flash partitions to 1s.
    flash_dv_part_e part = part.first();
    do begin
      cfg.flash_mem_bkdr_init(part, FlashMemInitSet);
      part = part.next();
    end while (part != part.first());
    // Wait for flash_ctrl to finish initializing on every reset
    // We probably need a parameter to skip this for certain tests
    csr_spinwait(.ptr(ral.status.init_wip), .exp_data(1&#39;b0));
  endtask : reset_flash

  virtual task apply_reset(string kind = &quot;HARD&quot;);
    uvm_reg_data_t data;
    bit init_busy;
    super.apply_reset(kind);
    if (kind == &quot;HARD&quot;) begin
      cfg.clk_rst_vif.wait_clks(cfg.post_reset_delay_clks);
    end
    reset_flash();

  endtask  // apply_reset

  // Configure the memory protection regions.
  virtual task flash_ctrl_mp_region_cfg(uint index, flash_mp_region_cfg_t region_cfg);
    uvm_reg_data_t data;
    uvm_reg csr;
    data = get_csr_val_with_updated_field(
        ral.mp_region_cfg[index].en_0, data, region_cfg.en
    ) | get_csr_val_with_updated_field(
        ral.mp_region_cfg[index].rd_en_0, data, region_cfg.read_en
    ) | get_csr_val_with_updated_field(
        ral.mp_region_cfg[index].prog_en_0, data, region_cfg.program_en
    ) | get_csr_val_with_updated_field(
        ral.mp_region_cfg[index].erase_en_0, data, region_cfg.erase_en
    ) | get_csr_val_with_updated_field(
        ral.mp_region_cfg[index].base_0, data, region_cfg.start_page
    ) | get_csr_val_with_updated_field(
        ral.mp_region_cfg[index].size_0, data, region_cfg.num_pages
    );
    csr_wr(.ptr(ral.mp_region_cfg[index]), .value(data));
  endtask

  // Configure the protection for the &quot;default&quot; region (all pages that do not fall into one
  // of the memory protection regions).
  virtual task flash_ctrl_default_region_cfg(bit read_en, bit program_en, bit erase_en);
    uvm_reg_data_t data;

    data = get_csr_val_with_updated_field(
        ral.default_region.rd_en, data, read_en
    ) | get_csr_val_with_updated_field(
        ral.default_region.prog_en, data, program_en
    ) | get_csr_val_with_updated_field(
        ral.default_region.erase_en, data, erase_en
    );
    csr_wr(.ptr(ral.default_region), .value(data));
  endtask

  // Configure bank erasability.
  virtual task flash_ctrl_bank_erase_cfg(bit [flash_ctrl_pkg::NumBanks-1:0] bank_erase_en);
    csr_wr(.ptr(ral.mp_bank_cfg), .value(bank_erase_en));
  endtask

  // Configure read and program fifo levels for interrupt.
  virtual task flash_ctrl_fifo_levels_cfg_intr(uint read_fifo_intr_level,
                                               uint program_fifo_intr_level);
    uvm_reg_data_t data;

    data = get_csr_val_with_updated_field(
        ral.fifo_lvl.prog, data, program_fifo_intr_level
    ) | get_csr_val_with_updated_field(
        ral.fifo_lvl.rd, data, read_fifo_intr_level
    );
    csr_wr(.ptr(ral.fifo_lvl), .value(data));
  endtask

  // Reset the program and read fifos.
  virtual task flash_ctrl_fifo_reset(bit reset = 1&#39;b1);
    csr_wr(.ptr(ral.fifo_rst), .value(reset));
  endtask

  // Wait for flash_ctrl op to finish.
  virtual task wait_flash_op_done(bit clear_op_status = 1&#39;b1, time timeout_ns = 10_000_000
    uvm_reg_data_t data;
    bit done;
    `DV_SPINWAIT(do begin
        csr_rd(.ptr(ral.op_status), .value(data));
        done = get_field_val(ral.op_status.done, data);
      end while (done == 1&#39;b0);, &quot;wait_flash_op_done timeout occurred!&quot;, timeout_ns)
    if (clear_op_status) begin
      data = get_csr_val_with_updated_field(ral.op_status.done, data, 0);
      csr_wr(.ptr(ral.op_status), .value(data));
    end
  endtask

  // Wait for flash_ctrl op to finish with error.
  virtual task wait_flash_op_err(bit clear_op_status = 1&#39;b1);
    uvm_reg_data_t data;
    bit err;
    `DV_SPINWAIT(do begin
        csr_rd(.ptr(ral.op_status), .value(data));
        err = get_field_val(ral.op_status.err, data);
      end while (err == 1&#39;b0);, &quot;wait_flash_op_err timeout occurred!&quot;)
    if (clear_op_status) begin
      data = get_csr_val_with_updated_field(ral.op_status.err, data, 0);
      csr_wr(.ptr(ral.op_status), .value(data));
    end
  endtask

  // Wait for prog fifo to not be full.
  virtual task wait_flash_ctrl_prog_fifo_not_full();
    // TODO: if intr enabled, then check interrupt, else check status.
    bit prog_full;
    `DV_SPINWAIT(do begin
        csr_rd(.ptr(ral.status.prog_full), .value(prog_full));
      end while (prog_full);, &quot;wait_flash_ctrl_prog_fifo_not_full timeout occurred!&quot;)
  endtask

  // Wait for rd fifo to not be empty.
  virtual task wait_flash_ctrl_rd_fifo_not_empty();
    // TODO: if intr enabled, then check interrupt, else check status.
    bit read_empty;
    `DV_SPINWAIT(do begin
        csr_rd(.ptr(ral.status.rd_empty), .value(read_empty));
      end while (read_empty);, &quot;wait_flash_ctrl_rd_fifo_not_empty timeout occurred!&quot;)
  endtask

  virtual task flash_ctrl_start_op(flash_op_t flash_op);
    uvm_reg_data_t data;
    flash_part_e partition_sel;
    bit [InfoTypesWidth-1:0] info_sel;


    csr_wr(.ptr(ral.addr), .value(flash_op.addr));

    //    flash_op.partition     -&gt; partition_sel  ,    info_sel         |
    //     (flash_dv_part_e)     | (flash_part_e)  | bit[InfoTypesWidth] |
    // --------------------------|-----------------|---------------------|
    //  FlashPartData        = 0 | FlashPartData=0 |         0           |
    //  FlashPartInfo        = 1 | FlashPartInfo=1 |         0           |
    //  FlashPartInfo1       = 2 | FlashPartInfo=1 |         1           |
    //  FlashPartRedundancy  = 4 | FlashPartInfo=1 |         2           |
    partition_sel = |flash_op.partition;
    info_sel = flash_op.partition &gt;&gt; 1;

    data = get_csr_val_with_updated_field(
        ral.control.start, data, 1&#39;b1
    ) | get_csr_val_with_updated_field(
        ral.control.op, data, flash_op.op
    ) | get_csr_val_with_updated_field(
        ral.control.erase_sel, data, flash_op.erase_type
    ) | get_csr_val_with_updated_field(
        ral.control.partition_sel, data, partition_sel
    ) | get_csr_val_with_updated_field(
        ral.control.info_sel, data, info_sel
    ) | get_csr_val_with_updated_field(
        ral.control.num, data, flash_op.num_words - 1
    );
    csr_wr(.ptr(ral.control), .value(data));
  endtask

  // Program data into flash, stopping whenever full.
  // The flash op is assumed to have already commenced.
  virtual task flash_ctrl_write(data_q_t data, bit poll_fifo_status);
    foreach (data[i]) begin
      // Check if prog fifo is full. If yes, then wait for space to become available.
      // Note that this polling is not needed since the interface is backpressure enabled.
      if (poll_fifo_status) begin
        wait_flash_ctrl_prog_fifo_not_full();
      end
      mem_wr(.ptr(ral.prog_fifo), .offset(0), .data(data[i]));
      `uvm_info(`gfn, $sformatf(&quot;flash_ctrl_write: 0x%0h&quot;, data[i]), UVM_MEDIUM)
    end
  endtask

  // Read data from flash, stopping whenever empty.
  // The flash op is assumed to have already commenced.
  virtual task flash_ctrl_read(uint num_words, ref data_q_t data, bit poll_fifo_status);
    for (int i = 0; i &lt; num_words; i++) begin
      // Check if rd fifo is empty. If yes, then wait for data to become available.
      // Note that this polling is not needed since the interface is backpressure enabled.
      if (poll_fifo_status) begin
        wait_flash_ctrl_rd_fifo_not_empty();
      end
      mem_rd(.ptr(ral.rd_fifo), .offset(0), .data(data[i]));
      `uvm_info(`gfn, $sformatf(&quot;flash_ctrl_read: 0x%0h&quot;, data[i]), UVM_MEDIUM)
    end
  endtask


endclass : flash_ctrl_base_vseq
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-gpio-dv-env-gpio-scoreboard-sv">
<span id="error-hw-ip-gpio-dv-env-gpio-scoreboard-sv"></span><h2>hw/ip/gpio/dv/env/gpio_scoreboard.sv<a class="headerlink" href="#hw-ip-gpio-dv-env-gpio-scoreboard-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/gpio/dv/env/gpio_scoreboard.sv: Error lex/parsing-ing formatted output.  Please file a bug.
First error: token: &quot;end&quot; at 159:21-23; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
class gpio_scoreboard extends cip_base_scoreboard #(
  .CFG_T(gpio_env_cfg),
  .RAL_T(gpio_reg_block),
  .COV_T(gpio_env_cov)
);

  // predicted value of DATA_OUT rtl implementation register
  bit [NUM_GPIOS-1:0] data_out;
  // predicted updated value of DATA_OE rtl implementation register
  bit [NUM_GPIOS-1:0] data_oe;
  // input presented by driving gpio_i
  logic [NUM_GPIOS-1:0] gpio_i_driven;
  // gpio input pins if previous out value
  logic [NUM_GPIOS-1:0] prv_gpio_i_pins_o;
  // gpio input pins if previous out enable value
  logic [NUM_GPIOS-1:0] prv_gpio_i_pins_oe;
  // Flag to store value to be updated for INTR_STATE register
  // and to indicate whether value change is due currently
  gpio_reg_update_due_t intr_state_update_queue[$];
  // data_in update queue
  gpio_reg_update_due_t data_in_update_queue[$];
  // Latest Interrupt state update due to either of following reasons:
  //  (i) gpio value change
  // (ii) interrupt control register value(s) write
  // This flag is not meant for update when intr_state register is written
  bit [TL_DW-1:0] last_intr_update_except_clearing;
  // Value seen in last Interrupt Test write
  bit [TL_DW-1:0] last_intr_test_event;
  // Flag to:
  //  (i) indicate that write to INTR_STATE register just happened, and
  // (ii) store information of which all interupt bits were cleared
  bit [TL_DW-1:0] cleared_intr_bits;

  // mask are WO, store the values in scb
  uvm_reg_data_t masked_out_lower_mask;
  uvm_reg_data_t masked_out_upper_mask;

  `uvm_component_utils(gpio_scoreboard)

  `uvm_component_new

  // Function: build_phase
  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
  endfunction

  // Task: run_phase
  task run_phase(uvm_phase phase);
    super.run_phase(phase);
    fork
      monitor_gpio_i();
      monitor_gpio_interrupt_pins();
    join_none
  endtask

  // Task : process_tl_access
  // process monitored tl transaction
  virtual task process_tl_access(tl_seq_item item, tl_channels_e channel, string ral_name);
    uvm_reg        csr;
    bit            do_read_check = 1&#39;b1;
    bit            write = item.is_write();
    uvm_reg_addr_t csr_addr = ral.get_word_aligned_addr(item.a_addr);

    // if access was to a valid csr, get the csr handle
    if (csr_addr inside {cfg.ral_models[ral_name].csr_addrs}) begin
      csr = ral.default_map.get_reg_by_offset(csr_addr);
      `DV_CHECK_NE_FATAL(csr, null)
    end else begin
      `uvm_fatal(`gfn, $sformatf(&quot;Access unexpected addr 0x%0h&quot;, csr_addr))
    end

    // grab completed transactions from data channel; ignore packets from address channel
    if (channel == AddrChannel) begin
      // Clock period in nano seconds (timeunit)
      real clk_period = cfg.clk_rst_vif.clk_period_ps / 1000;
      time crnt_time = $time;

      // apply pending update for `data_in` register
      if (data_in_update_queue.size() &gt; 0) begin
        if (data_in_update_queue[$].needs_update == 1&#39;b1 &amp;&amp;
            (int&#39;((crnt_time - data_in_update_queue[$].eval_time) / clk_period)) &gt; 1) begin
          void&#39;(ral.data_in.predict(
              .value(data_in_update_queue[$].reg_value), .kind(UVM_PREDICT_READ)
          ));
        end else if (data_in_update_queue[$-1].needs_update == 1&#39;b1) begin
          // Use previous updated value for &quot;data_in&quot; prediction
          void&#39;(ral.data_in.predict(
              .value(data_in_update_queue[$-1].reg_value), .kind(UVM_PREDICT_READ)
          ));
        end
      end

      // apply pending update for interrupt state
      if (intr_state_update_queue.size() &gt; 0) begin
        // As register read takes single clock cycle to latch the updated value, immediate
        // read on same or next clock will not give latest updated value. So, look for time stamp
        // of latest update to decide which value to predict for &quot;intr_state&quot; mirrored value
        if (intr_state_update_queue[$].needs_update == 1&#39;b1 &amp;&amp;
            (int&#39;((crnt_time - intr_state_update_queue[$].eval_time) / clk_period)) &gt; 1) begin
          void&#39;(ral.intr_state.predict(
              .value(intr_state_update_queue[$].reg_value), .kind(UVM_PREDICT_READ)
          ));
        end else if (intr_state_update_queue[$-1].needs_update == 1&#39;b1) begin
          // Use previous updated value for &quot;intr_state&quot; prediction
          void&#39;(ral.intr_state.predict(
              .value(intr_state_update_queue[$-1].reg_value), .kind(UVM_PREDICT_READ)
          ));
        end
      end

      // if incoming access is a write to a valid csr, then make updates right away
      if (write) begin
        if (csr.get_name() == &quot;intr_state&quot;) begin
          // As per rtl definition of W1C, hardware must get a chance to make update
          // to interrupt state first, so we need to clear interrupt only after possible
          // interrupt update due to gpio change
          #0;
          `uvm_info(`gfn, $sformatf(&quot;Write on intr_state: write data = %0h&quot;, item.a_data), UVM_HIGH)
          if (intr_state_update_queue.size() &gt; 0) begin
            gpio_reg_update_due_t intr_state_write_to_clear_update = intr_state_update_queue[$];
            `uvm_info(`gfn, $sformatf(
                      &quot;Entry taken out for clearing is %0p&quot;, intr_state_write_to_clear_update),
                      UVM_HIGH)
            // Update time
            intr_state_write_to_clear_update.eval_time = $time;
            for (uint each_bit = 0; each_bit &lt; TL_DW; each_bit++) begin
              if (intr_state_write_to_clear_update.needs_update == 1&#39;b1 &amp;&amp;
                  intr_state_write_to_clear_update.reg_value[each_bit] == 1&#39;b1 &amp;&amp;
                  item.a_data[each_bit] == 1&#39;b1) begin
                intr_state_write_to_clear_update.reg_value[each_bit] = 1&#39;b0;
                cleared_intr_bits[each_bit] = 1&#39;b1;
                // Coverage Sampling: gpio interrupt cleared
                if (cfg.en_cov) begin
                  cov.intr_state_cov_obj[each_bit].sample(1&#39;b0);
                end
              end
            end
            // If same time stamp as last entry, update entry to account for &quot;still active&quot; event
            // that caused last interrupt update (As per definition of w1c in comportability
            // specification)
            if (intr_state_write_to_clear_update.eval_time == intr_state_update_queue[$].eval_time)
                begin
              // Re-apply interrupt update
              intr_state_write_to_clear_update.reg_value |= last_intr_update_except_clearing;
              // Delete last entry with same time stamp
              intr_state_update_queue.delete(intr_state_update_queue.size() - 1);
              // Coverage Sampling: cover a scenario wherein cleared interrupt state bit
              // is re-asserted due to still active interrupt event
              // Note: In this case, both interrupt clearing event and INTR_STATE reg write
              // have occurred at the same time.
              if (cfg.en_cov) begin
                foreach (cleared_intr_bits[each_bit]) begin
                  if (cleared_intr_bits[each_bit]) begin
                    if (last_intr_update_except_clearing[each_bit]) begin
                      cov.sticky_intr_cov[{&quot;gpio_sticky_intr_pin&quot;, $sformatf(&quot;%0d&quot;, each_bit)
                    end else begin
                      cov.sticky_intr_cov[{&quot;gpio_sticky_intr_pin&quot;, $sformatf(&quot;%0d&quot;, each_bit)
                    end
                  end
                end
              end
            end
            // Push new interrupt state update entry into queue
            intr_state_update_queue.push_back(intr_state_write_to_clear_update);
            if (intr_state_update_queue.size() &gt; 2) begin
              // Delete extra unnecessary entry
              intr_state_update_queue.delete(0);
            end
          end
        end else begin
          if (csr.get_name() == &quot;intr_test&quot;) begin
            // Store the written value as it is WO register
            last_intr_test_event = item.a_data;
          end else begin
            // Coverage Sampling: coverage on *out* and *oe* register values
            if (cfg.en_cov &amp;&amp; (!uvm_re_match(
                    &quot;*out*&quot;, csr.get_name()
                ) || !uvm_re_match(
                    &quot;*oe*&quot;, csr.get_name()
                ))) begin
              for (uint each_pin = 0; each_pin &lt; NUM_GPIOS; each_pin++) begin
                cov.out_oe_cov_objs[each_pin][csr.get_name()].sample(item.a_data[each_pin]);
              end
              // Coverage Sampling: Cross coverage on mask and data within masked_* registers
              if (!uvm_re_match(&quot;masked*&quot;, csr.get_name())) begin
                bit [(NUM_GPIOS/2) - 1:0] mask, data;
                {mask, data} = item.a_data;
                for (uint each_pin = 0; each_pin &lt; NUM_GPIOS / 2; each_pin++) begin
                  cov.out_oe_mask_data_cov_objs[each_pin][csr.get_name()].var1_var2_cg.sample(
                      mask[each_pin], data[each_pin]);
                end
              end
            end
            // these fields are WO, save values in scb
            if (csr.get_name() == &quot;masked_out_lower&quot;) begin
              masked_out_lower_mask = get_field_val(ral.masked_out_lower.mask, item.a_data);
            end else if (csr.get_name() == &quot;masked_out_upper&quot;) begin
              masked_out_upper_mask = get_field_val(ral.masked_out_upper.mask, item.a_data);
            end
            void&#39;(csr.predict(.value(item.a_data), .kind(UVM_PREDICT_WRITE), .be(item.a_mask)));
          end
        end
        `uvm_info(`gfn, &quot;Calling gpio_predict_and_compare on reg write&quot;, UVM_HIGH)
        gpio_predict_and_compare(csr);
      end  // if (write)
    end else begin  // if (channel == DataChannel)
      if (write == 0) begin
        `uvm_info(`gfn, $sformatf(&quot;csr read on %0s&quot;, csr.get_name()), UVM_HIGH)
        // If do_read_check, is set, then check mirrored_value against item.d_data
        if (do_read_check) begin
          // Checker-2: Check if reg read data matches expected value or not
          `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data)
          // Checker-3: Check value of interrupt pins against predicted value
          if (csr.get_name() == &quot;intr_state&quot;) begin
            bit [TL_DW-1:0] intr_state = (intr_state_update_queue.size() &gt; 0) ?
                                         intr_state_update_queue[$].reg_value :
                                         csr.get_mirrored_value();
            bit [TL_DW-1:0] pred_val_intr_pins = intr_state &amp;
                                                 ral.intr_enable.get_mirrored_value();
            // according to issue #841, interrupt is a flop and the value will be updated after one
            // clock cycle. Because the `pred_val_intr_pins` might be updated during the one clk
            // cycle, we store the predicted intr val into a temp automatic variable.
            fork
              begin
                automatic bit [TL_DW-1:0] pred_val_intr_pins_temp = pred_val_intr_pins;
                cfg.clk_rst_vif.wait_clks(1);
                if (!cfg.under_reset) `DV_CHECK_EQ(cfg.intr_vif.pins, pred_val_intr_pins_temp)
              end
            join_none
          end
        end
      end  // if (write == 0)
    end
  endtask : process_tl_access

  // Task : monitor_gpio_i
  // monitor gpio input pins interface
  virtual task monitor_gpio_i();
    logic [NUM_GPIOS-1:0] prev_gpio_i = cfg.gpio_vif.pins;

    forever begin : monitor_pins_if
      @(cfg.gpio_vif.pins or cfg.under_reset);
      `uvm_info(`gfn, $sformatf(
                &quot;cfg.gpio_vif.pins = %0h, under_reset = %0b&quot;, cfg.gpio_vif.pins, cfg.under_reset),
                UVM_HIGH)
      if (cfg.under_reset == 1&#39;b0) begin
        // Coverage Sampling: gpio pin values&#39; coverage
        if (cfg.en_cov) begin
          foreach (cov.gpio_pin_values_cov_obj[each_pin]) begin
            cov.gpio_pin_values_cov_obj[each_pin].sample(cfg.gpio_vif.pins[each_pin]);
          end
        end
        // evaluate gpio input driven to dut
        foreach (cfg.gpio_vif.pins_oe[pin_num]) begin
          if (cfg.gpio_vif.pins_oe[pin_num] == 1&#39;b1) begin
            gpio_i_driven[pin_num] = cfg.gpio_vif.pins_o[pin_num];
          end else begin
            gpio_i_driven[pin_num] = 1&#39;bz;
          end
          `uvm_info(`gfn, $sformatf(
                    &quot;pins_oe[%0d] = %0b pins_o[%0d] = %0b gpio_i_driven[%0d] = %0b&quot;,
                    pin_num,
                    cfg.gpio_vif.pins_oe[pin_num],
                    pin_num,
                    cfg.gpio_vif.pins_o[pin_num],
                    pin_num,
                    gpio_i_driven[pin_num]
                    ), UVM_HIGH)
        end

        `uvm_info(`gfn, $sformatf(
                  &quot;pins = 0x%0h [%0b]) gpio_i_driven = 0x%0h [%0b]&quot;,
                  cfg.gpio_vif.pins,
                  cfg.gpio_vif.pins,
                  gpio_i_driven,
                  gpio_i_driven
                  ), UVM_HIGH)
        // Predict effect on gpio pins
        gpio_predict_and_compare();

        if (prev_gpio_i !== cfg.gpio_vif.pins) begin
          // Flag to indicate:
          // (i) if there was any change in value on gpio_i pin - Bit0
          // (ii) what change occurred on gpio_i pin - Bit1
          gpio_transition_t [NUM_GPIOS-1:0] gpio_i_transition;
          foreach (prev_gpio_i[pin]) begin
            gpio_i_transition[pin].transition_occurred =
                (cfg.gpio_vif.pins[pin] !== prev_gpio_i[pin]);
            if (gpio_i_transition[pin].transition_occurred) begin
              case (cfg.gpio_vif.pins[pin])
                1&#39;b0: begin
                  // Negedge seen on pin, indicated by 0 value
                  gpio_i_transition[pin].is_rising_edge = 1&#39;b0;
                end
                1&#39;b1: begin
                  // Posedge seen on pin, indicated by 1 value
                  gpio_i_transition[pin].is_rising_edge = 1&#39;b1;
                end
                1&#39;bz: begin
                  if (prev_gpio_i[pin] === 1&#39;b1) begin
                    // Negedge seen on pin, indicated by 0 value
                    gpio_i_transition[pin].is_rising_edge = 1&#39;b0;
                  end else if (prev_gpio_i[pin] === 1&#39;b0) begin
                    // Posedge seen on pin, indicated by 1 value
                    gpio_i_transition[pin].is_rising_edge = 1&#39;b1;
                  end else begin
                    // x-&gt;z does not indicate useful transition, reset transition bit
                    gpio_i_transition[pin].transition_occurred = 1&#39;b0;
                  end
                end
                1&#39;bx: begin
                  if (prev_gpio_i[pin] === 1&#39;b1) begin
                    // Negedge seen on pin, indicated by 0 value
                    gpio_i_transition[pin].is_rising_edge = 1&#39;b0;
                  end else if (prev_gpio_i[pin] === 1&#39;b0) begin
                    // Posedge seen on pin, indicated by 1 value
                    gpio_i_transition[pin].is_rising_edge = 1&#39;b1;
                  end else begin
                    // z-&gt;x does not indicate useful transition, reset transition bit
                    gpio_i_transition[pin].transition_occurred = 1&#39;b0;
                  end
                end
              endcase
            end
          end
          foreach (gpio_i_transition[ii]) begin
            `uvm_info(`gfn, $sformatf(&quot;gpio_i_transition[%0d] = %0p&quot;, ii, gpio_i_transition[ii]),
                      UVM_HIGH)
          end
          `uvm_info(`gfn, &quot;Calling gpio_interrupt_predict from monitor_pins_if&quot;, UVM_HIGH)
          // Look for interrupt event and update interrupt status
          gpio_interrupt_predict(gpio_i_transition);
          // Update value
          prev_gpio_i = cfg.gpio_vif.pins;
          `uvm_info(`gfn, $sformatf(&quot;updated prev_gpio_i = 0x%0h [%0b]&quot;, prev_gpio_i, prev_gpio_i),
                    UVM_HIGH)
        end
        // Update &quot;previous pins if out and out enable&quot; values
        prv_gpio_i_pins_o  = cfg.gpio_vif.pins_o;
        prv_gpio_i_pins_oe = cfg.gpio_vif.pins_oe;
        `uvm_info(`gfn, $sformatf(
                  &quot;prv_gpio_i_pins_o = 0x%0h [%0b]&quot;, prv_gpio_i_pins_o, prv_gpio_i_pins_o),
                  UVM_HIGH)
        `uvm_info(`gfn, $sformatf(
                  &quot;prv_gpio_i_pins_oe = 0x%0h [%0b]&quot;, prv_gpio_i_pins_oe, prv_gpio_i_pins_oe),
                  UVM_HIGH)
      end

    end  // monitor_pins_if

  endtask : monitor_gpio_i

  // Task: monitor_gpio_interrupt_pins
  virtual task monitor_gpio_interrupt_pins();
    forever begin : monitor_gpio_intr
      @(cfg.intr_vif.pins or cfg.under_reset) begin
        if (cfg.under_reset == 0) begin
          if (cfg.en_cov) begin
            // Coverage Sampling: gpio interrupt pin values and transitions
            for (uint each_pin = 0; each_pin &lt; NUM_GPIOS; each_pin++) begin
              cov.intr_pins_cg.sample(each_pin, cfg.intr_vif.pins[each_pin]);
            end
          end
        end
      end
    end
  endtask : monitor_gpio_interrupt_pins

  // Function: actual_gpio_i_activity
  function bit actual_gpio_i_activity();
    return ~((prv_gpio_i_pins_o === cfg.gpio_vif.pins_o) &amp;&amp;
             (prv_gpio_i_pins_oe === cfg.gpio_vif.pins_oe));
  endfunction : actual_gpio_i_activity

  // Function : gpio_predict_and_compare
  function void gpio_predict_and_compare(uvm_reg csr = null);
    string msg_id = {`gfn, &quot; gpio_predict_and_compare: &quot;};
    // Predicted value of &quot;pins&quot; from within gpio_vif
    logic [NUM_GPIOS-1:0] pred_val_gpio_pins;
    // Flag to decide if gpio data prediction and check are required
    bit gpio_data_check = 1&#39;b1;

    if (csr != null) begin
      // process the csr req
      case (csr.get_name())
        &quot;data_in&quot;: begin
          gpio_data_check = 1&#39;b0;
        end
        &quot;direct_out&quot;: begin
          data_out = csr.get_mirrored_value();
          `uvm_info(`gfn, $sformatf(&quot;data_out updated to 0x%0h [%0b]&quot;, data_out, data_out),
                    UVM_HIGH)
          // Update mirror values of *out* registers
          update_gpio_out_regs();
        end
        &quot;masked_out_lower&quot;: begin
          uvm_reg_data_t data = ral.masked_out_lower.data.get_mirrored_value();

          for (uint pin_idx = 0; pin_idx &lt; ral.masked_out_lower.mask.get_n_bits(); pin_idx++) begin
            if (masked_out_lower_mask[pin_idx] == 1&#39;b1) begin
              data_out[pin_idx] = data[pin_idx];
            end
          end
          `uvm_info(`gfn, $sformatf(&quot;data_out updated to 0x%0h [%0b]&quot;, data_out, data_out),
                    UVM_HIGH)
          // Update mirror values of *out* registers
          update_gpio_out_regs();
        end
        &quot;masked_out_upper&quot;: begin
          uvm_reg_data_t data = ral.masked_out_upper.data.get_mirrored_value();

          for (uint pin_idx = 0; pin_idx &lt; ral.masked_out_upper.mask.get_n_bits(); pin_idx++) begin
            if (masked_out_upper_mask[pin_idx] == 1&#39;b1) begin
              data_out[(NUM_GPIOS/2)+pin_idx] = data[pin_idx];
            end
          end
          `uvm_info(`gfn, $sformatf(&quot;data_out updated to 0x%0h [%0b]&quot;, data_out, data_out),
                    UVM_HIGH)
          // Update mirror values of *out* registers
          update_gpio_out_regs();
        end
        &quot;direct_oe&quot;: begin
          data_oe = csr.get_mirrored_value();
          `uvm_info(`gfn, $sformatf(&quot;data_out updated to 0x%0h [%0b]&quot;, data_out, data_out),
                    UVM_HIGH)
          // Update mirror values of *oe* registers
          update_gpio_oe_regs();
        end
        &quot;masked_oe_lower&quot;: begin
          uvm_reg_data_t mask = ral.masked_oe_lower.mask.get_mirrored_value();
          uvm_reg_data_t data = ral.masked_oe_lower.data.get_mirrored_value();

          for (uint pin_idx = 0; pin_idx &lt; ral.masked_oe_lower.mask.get_n_bits(); pin_idx++) begin
            if (mask[pin_idx] == 1&#39;b1) begin
              data_oe[pin_idx] = data[pin_idx];
            end
          end
          `uvm_info(`gfn, $sformatf(&quot;data_oe reg updated to 0x%0h [%0b]&quot;, data_oe, data_oe),
                    UVM_HIGH)
          // Update mirror values of *oe* registers
          update_gpio_oe_regs();
        end
        &quot;masked_oe_upper&quot;: begin
          uvm_reg_data_t mask = ral.masked_oe_upper.mask.get_mirrored_value();
          uvm_reg_data_t data = ral.masked_oe_upper.data.get_mirrored_value();

          for (uint pin_idx = 0; pin_idx &lt; ral.masked_oe_upper.mask.get_n_bits(); pin_idx++) begin
            if (mask[pin_idx] == 1&#39;b1) begin
              data_oe[(NUM_GPIOS/2)+pin_idx] = data[pin_idx];
            end
          end
          `uvm_info(`gfn, $sformatf(&quot;data_oe reg updated to %0h&quot;, data_oe), UVM_HIGH)
          // Update mirror values of *oe* registers
          update_gpio_oe_regs();
        end
        &quot;intr_enable&quot;: begin
          gpio_data_check = 1&#39;b0;
          gpio_interrupt_predict();
        end
        &quot;intr_state&quot;: begin
          gpio_data_check = 1&#39;b0;
          gpio_interrupt_predict();
        end
        &quot;intr_test&quot;: begin
          gpio_data_check = 1&#39;b0;
          gpio_interrupt_predict();
        end
        &quot;intr_ctrl_en_rising&quot;: begin
          gpio_data_check = 1&#39;b0;
          gpio_interrupt_predict();
        end
        &quot;intr_ctrl_en_falling&quot;: begin
          gpio_data_check = 1&#39;b0;
          gpio_interrupt_predict();
        end
        &quot;intr_ctrl_en_lvlhigh&quot;: begin
          gpio_data_check = 1&#39;b0;
          gpio_interrupt_predict();
        end
        &quot;intr_ctrl_en_lvllow&quot;: begin
          gpio_data_check = 1&#39;b0;
          gpio_interrupt_predict();
        end
        &quot;ctrl_en_input_filter&quot;: begin
        end
        default: begin
          `uvm_fatal(`gfn, $sformatf(&quot;invalid csr: %0s&quot;, csr.get_full_name()))
        end
      endcase
    end

    // GPIO inout signal value check
    if (gpio_data_check == 1&#39;b1) begin
      // effect of gpio_o on gpio_i based on gpio_oe
      logic [NUM_GPIOS-1:0] data_out_effect_on_gpio_i;
      // As there is a common net that drives gpio_i and gets driven through gpio_o
      // based on gpio_oe, gpio_i will have effect of (gpio_o &amp; gpio_oe) value
      foreach (data_oe[pin_num]) begin
        if (data_oe[pin_num] === 1&#39;b1) begin
          data_out_effect_on_gpio_i[pin_num] = data_out[pin_num];
        end else begin
          data_out_effect_on_gpio_i[pin_num] = 1&#39;bz;
        end
      end
      `uvm_info(msg_id, $sformatf(
                &quot;data_out_effect_on_gpio_i = 0x%0h [%0b]&quot;,
                data_out_effect_on_gpio_i,
                data_out_effect_on_gpio_i
                ), UVM_HIGH)
      `uvm_info(msg_id, $sformatf(&quot;gpio_i_driven = 0x%0h [%0b]&quot;, gpio_i_driven, gpio_i_driven),
                UVM_HIGH)

      // Predict effective value of common wire that-
      // (i) drives gpio_i, and
      // (ii) gets driven by gpio_o based on gpiooe value
      for (uint pin_num = 0; pin_num &lt; NUM_GPIOS; pin_num++) begin
        if (data_out_effect_on_gpio_i[pin_num] === 1&#39;bz) begin
          pred_val_gpio_pins[pin_num] = gpio_i_driven[pin_num];
        end else if (gpio_i_driven[pin_num] === 1&#39;bz) begin
          pred_val_gpio_pins[pin_num] = data_out_effect_on_gpio_i[pin_num];
        end else if (data_out_effect_on_gpio_i[pin_num] === gpio_i_driven[pin_num]) begin
          pred_val_gpio_pins[pin_num] = data_out_effect_on_gpio_i[pin_num];
        end else begin
          pred_val_gpio_pins[pin_num] = 1&#39;bx;
        end
        if (pred_val_gpio_pins[pin_num] === 1&#39;bz) begin
          if (cfg.gpio_vif.pins_pu[pin_num] == 1&#39;b1) begin
            pred_val_gpio_pins[pin_num] = 1&#39;b1;
          end else if (cfg.gpio_vif.pins_pd[pin_num] == 1&#39;b1) begin
            pred_val_gpio_pins[pin_num] = 1&#39;b0;
          end
        end
      end
      `uvm_info(msg_id, $sformatf(
                &quot;pred_val_gpio_pins = %0h(%0b)&quot;, pred_val_gpio_pins, pred_val_gpio_pins), UVM_HIGH)

      // Store latest update to be applied to data_in
      begin
        gpio_reg_update_due_t current_data_in_update;
        if (data_in_update_queue.size == 2) begin
          data_in_update_queue.delete(0);
        end
        current_data_in_update.needs_update = 1&#39;b1;
        current_data_in_update.reg_value = pred_val_gpio_pins;
        current_data_in_update.eval_time = $time;
        data_in_update_queue.push_back(current_data_in_update);
        // Coverage Sampling: data_in register coverage
        // Coverage Sampling: Cross coverage between data_out, data_oe and data_in
        // values per bit
        if (cfg.en_cov) begin
          for (uint each_bit = 0; each_bit &lt; NUM_GPIOS; each_bit++) begin
            cov.data_in_cov_obj[each_bit].sample(pred_val_gpio_pins[each_bit]);
            cov.data_out_data_oe_data_in_cross_cg.sample(
                each_bit, data_out[each_bit], data_oe[each_bit], pred_val_gpio_pins[each_bit]);
            cov.gpio_pins_data_in_cross_cg.sample(each_bit, cfg.gpio_vif.pins[each_bit],
                                                  pred_val_gpio_pins[each_bit]);
          end
        end
      end
      // If update was due to register write, we can call predict right away
      if (csr != null) begin
        // Update data_in register value based on result of input and output
        void&#39;(ral.data_in.data_in.predict(.value(pred_val_gpio_pins), .kind(UVM_PREDICT_DIRECT)));
      end

      // Checker-1: Compare predicted and actual values of gpio pins
      // Avoid calling this checker due to weak pull-up or pull-down effect
      if ((csr != null) || ((|gpio_i_driven === 1&#39;b1) &amp;&amp; (actual_gpio_i_activity() == 1))) begin
        `DV_CHECK_CASE_EQ(pred_val_gpio_pins, cfg.gpio_vif.pins)
      end
    end

  endfunction : gpio_predict_and_compare

  // Function : gpio_interrupt_predict
  // This function computes expected value of gpio intr_status based on
  // changes of gpio_i data or interrupt control registers
  virtual function void gpio_interrupt_predict(
      input gpio_transition_t [NUM_GPIOS-1:0] gpio_i_transition = {NUM_GPIOS{2&#39;b00}});

    string             msg_id = {`gfn, $sformatf(&quot; gpio_interrupt_predict: &quot;)};
    bit    [TL_DW-1:0] intr_enable = ral.intr_enable.get_mirrored_value();
    bit    [TL_DW-1:0] intr_state = ral.intr_state.get_mirrored_value();
    bit    [TL_DW-1:0] intr_ctrl_en_rising = ral.intr_ctrl_en_rising.get_mirrored_value();
    bit    [TL_DW-1:0] intr_ctrl_en_falling = ral.intr_ctrl_en_falling.get_mirrored_value();
    bit    [TL_DW-1:0] intr_ctrl_en_lvlhigh = ral.intr_ctrl_en_lvlhigh.get_mirrored_value();
    bit    [TL_DW-1:0] intr_ctrl_en_lvllow = ral.intr_ctrl_en_lvllow.get_mirrored_value();
    // expected(predicted) value of interrupt status
    bit    [TL_DW-1:0] exp_intr_status;

    // Reset value of last_intr_update_except_clearing to 0
    last_intr_update_except_clearing = &#39;0;
    // Check if there is already INTR_STATE value update which was already due
    // for update, but not actually updated
    if (intr_state_update_queue.size() &gt; 0) begin
      if (intr_state_update_queue[$].needs_update) begin
        intr_state = intr_state_update_queue[$].reg_value;
      end
    end

    // Coverage Sampling: gpio interrupt types
    if (cfg.en_cov) begin
      foreach (intr_ctrl_en_rising[each_bit]) begin
        cov.intr_ctrl_en_cov_objs[each_bit][&quot;intr_ctrl_en_rising&quot;].sample(
            intr_ctrl_en_rising[each_bit]);
        cov.intr_ctrl_en_cov_objs[each_bit][&quot;intr_ctrl_en_falling&quot;].sample(
            intr_ctrl_en_falling[each_bit]);
        cov.intr_ctrl_en_cov_objs[each_bit][&quot;intr_ctrl_en_lvlhigh&quot;].sample(
            intr_ctrl_en_lvlhigh[each_bit]);
        cov.intr_ctrl_en_cov_objs[each_bit][&quot;intr_ctrl_en_lvllow&quot;].sample(
            intr_ctrl_en_lvllow[each_bit]);
      end
    end
    // 1. Look for edge triggerred interrupts
    begin
      bit [TL_DW-1:0] rising_edge_intr_events, falling_edge_intr_events;
      if (gpio_i_transition != {NUM_GPIOS{2&#39;b00}}) begin
        foreach (rising_edge_intr_events[each_bit]) begin
          if (gpio_i_transition[each_bit].transition_occurred) begin
            rising_edge_intr_events[each_bit]  = gpio_i_transition[each_bit].is_rising_edge &amp;
                                                 intr_ctrl_en_rising[each_bit];
            falling_edge_intr_events[each_bit] = !gpio_i_transition[each_bit].is_rising_edge &amp;
                                                 intr_ctrl_en_falling[each_bit];
          end
        end
        foreach (gpio_i_transition[each_bit]) begin
          if (gpio_i_transition[each_bit].transition_occurred) begin
            if (rising_edge_intr_events[each_bit] || falling_edge_intr_events[each_bit]) begin
              exp_intr_status[each_bit] = 1&#39;b1;
              // Register the latest edge triggered gpio interrupt update, if any
              last_intr_update_except_clearing[each_bit] = 1&#39;b1;
            end else begin
              exp_intr_status[each_bit] = intr_state[each_bit];
            end
          end
        end
      end
      // Coverage Sampling: Cross coverage of (edge tiggered intr type)x(enable)x(state)
      // when type is enabled
      if (cfg.en_cov) begin
        foreach (rising_edge_intr_events[each_bit]) begin
          cov.intr_event_type_cov_objs[each_bit][&quot;intr_event_rising&quot;].intr_type_cg.sample(
              intr_ctrl_en_rising[each_bit], intr_enable[each_bit],
              rising_edge_intr_events[each_bit]);
          cov.intr_event_type_cov_objs[each_bit][&quot;intr_event_falling&quot;].intr_type_cg.sample(
              intr_ctrl_en_falling[each_bit], intr_enable[each_bit],
              falling_edge_intr_events[each_bit]);
        end
      end
    end
    // 2. Look for level triggerred interrupts
    begin
      bit [TL_DW-1:0] lvlhigh_intr_events, lvllow_intr_events;
      for (uint each_bit = 0; each_bit &lt; TL_DW; each_bit++) begin
        lvlhigh_intr_events[each_bit] = (cfg.gpio_vif.pins[each_bit] == 1&#39;b1) &amp;&amp;
                                        (intr_ctrl_en_lvlhigh[each_bit] == 1&#39;b1);
        lvllow_intr_events[each_bit]  = (cfg.gpio_vif.pins[each_bit] == 1&#39;b0) &amp;&amp;
                                        (intr_ctrl_en_lvllow[each_bit] == 1&#39;b1);
        if (exp_intr_status[each_bit] == 1&#39;b0) begin
          if (lvlhigh_intr_events[each_bit] || lvllow_intr_events[each_bit]) begin
            exp_intr_status[each_bit] = 1&#39;b1;
            // Register the latest level triggered gpio interrupt update, if any
            last_intr_update_except_clearing[each_bit] = 1&#39;b1;
          end else begin
            exp_intr_status[each_bit] = intr_state[each_bit];
          end
        end
      end
      // Coverage Sampling: Cross coverage of (edge tiggered intr type)x(enable)x(state)
      // when type is enabled
      if (cfg.en_cov) begin
        foreach (lvlhigh_intr_events[each_bit]) begin
          cov.intr_event_type_cov_objs[each_bit][&quot;intr_event_lvlhigh&quot;].intr_type_cg.sample(
              intr_ctrl_en_lvlhigh[each_bit], intr_enable[each_bit], lvlhigh_intr_events[each_bit]);
          cov.intr_event_type_cov_objs[each_bit][&quot;intr_event_lvllow&quot;].intr_type_cg.sample(
              intr_ctrl_en_lvllow[each_bit], intr_enable[each_bit], lvllow_intr_events[each_bit]);
        end
      end
    end
    // 3. Apply effect of &quot;Interrupt Test&quot;
    exp_intr_status |= last_intr_test_event;
    `uvm_info(`gfn, $sformatf(&quot;updated intr_state is %0h&quot;, exp_intr_status), UVM_HIGH)
    // Coverage Sampling: Coverage on Interrupt Index, Interrupt Enable,
    // Interrupt Status and their cross coverage
    if (cfg.en_cov) begin
      foreach (exp_intr_status[each_bit]) begin
        cov.intr_cg.sample(each_bit, intr_enable[each_bit], exp_intr_status[each_bit]);
        cov.intr_state_cov_obj[each_bit].sample(last_intr_update_except_clearing[each_bit]);
        // Coverage Sampling: cover a scenario wherein cleared interrupt state bit
        // is re-asserted due to still active interrupt event
        if (cleared_intr_bits[each_bit]) begin
          if (exp_intr_status[each_bit]) begin
            cov.sticky_intr_cov[{&quot;gpio_sticky_intr_pin&quot;, $sformatf(&quot;%0d&quot;, each_bit)}].sample(1&#39;b1);
          end else begin
            cov.sticky_intr_cov[{&quot;gpio_sticky_intr_pin&quot;, $sformatf(&quot;%0d&quot;, each_bit)}].sample(1&#39;b0);
          end
          // Clear the flag
          cleared_intr_bits[each_bit] = 1&#39;b0;
        end
        // Interrupt Test coverage
        cov.intr_test_cg.sample(each_bit, last_intr_test_event[each_bit], intr_enable[each_bit],
                                exp_intr_status[each_bit]);
      end
    end
    // Clear last_intr_test_event
    last_intr_test_event = &#39;0;
    `uvm_info(msg_id, $sformatf(
              &quot;Predicted interrupt status = 0x%0h [%0b]&quot;, exp_intr_status, exp_intr_status),
              UVM_HIGH)
    begin
      gpio_reg_update_due_t crnt_intr_state_update;
      // Keep update pending until register access is done
      crnt_intr_state_update.needs_update = 1&#39;b1;
      crnt_intr_state_update.reg_value = exp_intr_status;
      crnt_intr_state_update.eval_time = $time;
      // Push new entry into queue
      intr_state_update_queue.push_back(crnt_intr_state_update);

      // If queue already has two entries, remove 0th element
      if (intr_state_update_queue.size() &gt; 2) begin
        intr_state_update_queue.delete(0);
      end
    end
  endfunction : gpio_interrupt_predict

  // Function : update_gpio_out_regs
  // This function is used for updating direct_out, masked_out_upper and masked_out_lower
  // register values based on write to any one of these 3 registers.
  // Note : Assumption for this method is that data_out has already been updated
  //        before calling the method.
  function void update_gpio_out_regs();
    uvm_reg_data_t data;
    // 1. Update &quot;direct_out&quot; register for writes to masked_out_* registers
    //    For write to &quot;direct_out&quot;, it must have been updated already.
    void&#39;(ral.direct_out.predict(.value(data_out), .kind(UVM_PREDICT_WRITE)));
    // 2. Update masked_out_lower
    data = data_out;
    for (uint idx = ral.masked_out_lower.data.get_n_bits(); idx &lt; `UVM_REG_DATA_WIDTH; idx++) begin
      data[idx] = 1&#39;b0;
    end
    void&#39;(ral.masked_out_lower.data.predict(.value(data), .kind(UVM_PREDICT_WRITE)));
    // 3. Update masked_out_upper
    data = 0;
    for (uint idx = ral.masked_out_upper.data.get_n_bits(); idx &lt; `UVM_REG_DATA_WIDTH; idx++) begin
      data[idx-ral.masked_out_upper.data.get_n_bits()] = data_out[idx];
    end
    void&#39;(ral.masked_out_upper.data.predict(.value(data), .kind(UVM_PREDICT_WRITE)));
    // Coverage Sampling: Coverage on DATA_OUT values and its combinations with DATA_OE
    sample_data_out_data_oe_coverage();
  endfunction : update_gpio_out_regs

  // Function : update_gpio_oe_regs
  // This function is used for updating direct_oe, masked_oe_upper and masked_oe_lower
  // register values based on write to any one of these 3 registers.
  // Note : Assumption for this method is that data_oe has already been updated
  //        before calling the method.
  function void update_gpio_oe_regs();
    uvm_reg_data_t data;
    const uvm_reg_data_t mask = 0;
    // 1. Update &quot;direct_oe&quot; register for writes to masked_oe_* registers
    //    For write to &quot;direct_oe&quot;, it must have been updated already.
    void&#39;(ral.direct_oe.predict(.value(data_oe), .kind(UVM_PREDICT_WRITE)));
    // 2. Update masked_oe_lower
    data = data_oe;
    for (uint idx = ral.masked_oe_lower.data.get_n_bits(); idx &lt; `UVM_REG_DATA_WIDTH; idx++) begin
      data[idx] = 1&#39;b0;
    end
    void&#39;(ral.masked_oe_lower.mask.predict(.value(mask), .kind(UVM_PREDICT_WRITE)));
    void&#39;(ral.masked_oe_lower.data.predict(.value(data), .kind(UVM_PREDICT_WRITE)));
    // 3. Update masked_oe_upper
    data = 0;
    for (uint idx = ral.masked_oe_upper.data.get_n_bits(); idx &lt; `UVM_REG_DATA_WIDTH; idx++) begin
      data[idx-ral.masked_oe_upper.data.get_n_bits()] = data_oe[idx];
    end
    void&#39;(ral.masked_oe_upper.mask.predict(.value(mask), .kind(UVM_PREDICT_WRITE)));
    void&#39;(ral.masked_oe_upper.data.predict(.value(data), .kind(UVM_PREDICT_WRITE)));
    // Coverage Sampling: Coverage on DATA_OUT values and its combinations with DATA_OE
    sample_data_out_data_oe_coverage();
  endfunction : update_gpio_oe_regs

  // Function: sample_data_out_data_oe_coverage
  function void sample_data_out_data_oe_coverage();
    if (cfg.en_cov) begin
      for (uint each_bit = 0; each_bit &lt; NUM_GPIOS; each_bit++) begin
        cov.data_out_data_oe_cov_obj[each_bit].var1_var2_cg.sample(data_out[each_bit],
                                                                   data_oe[each_bit]);
      end
    end
  endfunction : sample_data_out_data_oe_coverage

  // Function: reset
  virtual function void reset(string kind = &quot;HARD&quot;);
    super.reset(kind);
    ral.reset(kind);
    // Reset scoreboard variables
    data_out = &#39;0;
    data_oe = &#39;0;
    intr_state_update_queue = {};
    data_in_update_queue = {};
    last_intr_update_except_clearing = &#39;0;
    last_intr_test_event = &#39;0;
    cleared_intr_bits = &#39;0;
  endfunction

  // Function: check_phase
  function void check_phase(uvm_phase phase);
    super.check_phase(phase);
  endfunction

endclass : gpio_scoreboard
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-rv-timer-dv-env-rv-timer-scoreboard-sv">
<span id="error-hw-ip-rv-timer-dv-env-rv-timer-scoreboard-sv"></span><h2>hw/ip/rv_timer/dv/env/rv_timer_scoreboard.sv<a class="headerlink" href="#hw-ip-rv-timer-dv-env-rv-timer-scoreboard-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/rv_timer/dv/env/rv_timer_scoreboard.sv: Error lex/parsing-ing formatted output.  Please file a bug.
First error: token: &quot;end&quot; at 131:19-21; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class rv_timer_scoreboard extends cip_base_scoreboard #(
  .CFG_T(rv_timer_env_cfg),
  .RAL_T(rv_timer_reg_block),
  .COV_T(rv_timer_env_cov)
);

  `uvm_component_utils(rv_timer_scoreboard)
  `uvm_component_new

  // local variables
  local uint64 prescale[NUM_HARTS];
  local uint64 step[NUM_HARTS];
  local uint64 timer_val[NUM_HARTS];
  local uint64 compare_val[NUM_HARTS][NUM_TIMERS];
  local uint num_clks[NUM_HARTS][NUM_TIMERS];
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_timers;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_timers_prev;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_interrupt;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] ignore_period;
  local bit [NUM_HARTS-1:0] num_clk_update_due;
  local bit ctimecmp_update_on_fly;

  // expected values
  local uint intr_status_exp[NUM_HARTS];

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
  endfunction

  task run_phase(uvm_phase phase);
    super.run_phase(phase);
    compute_and_check_interrupt();
  endtask

  virtual task process_tl_access(tl_seq_item item, tl_channels_e channel, string ral_name);
    uvm_reg        csr;
    string         csr_name;
    bit            do_read_check = 1&#39;b1;
    bit            write = item.is_write();
    uvm_reg_addr_t csr_addr = ral.get_word_aligned_addr(item.a_addr);

    // if access was to a valid csr, get the csr handle
    if (csr_addr inside {cfg.ral_models[ral_name].csr_addrs}) begin
      csr = ral.default_map.get_reg_by_offset(csr_addr);
      `DV_CHECK_NE_FATAL(csr, null)
      csr_name = csr.get_name();
    end else begin
      `uvm_fatal(`gfn, $sformatf(&quot;Access unexpected addr 0x%0h&quot;, csr_addr))
    end

    if (!write &amp;&amp; channel == AddrChannel) begin
      if (!uvm_re_match(&quot;intr_state*&quot;, csr_name)) begin
        for (int i = 0; i &lt; NUM_HARTS; i++) begin
          if (csr_name == $sformatf(&quot;intr_state%0d&quot;, i)) begin
            if ((intr_status_exp[i] != csr.get_mirrored_value()) &amp; (ignore_period[i] == &#39;b0)) begin
              void&#39;(csr.predict(.value(intr_status_exp[i]), .kind(UVM_PREDICT_READ)));
            end
            break;
          end else if (i == (NUM_HARTS - 1)) begin
            `uvm_fatal(`gfn, $sformatf(&quot;invalid csr: %0s&quot;, csr.get_full_name()))
          end
        end
      end
    end

    // grab write transactions from address channel; grab completed transactions from data channel

    // if incoming access is a write to a valid csr, then make updates right away
    if (write &amp;&amp; channel == AddrChannel) begin
      void&#39;(csr.predict(.value(item.a_data), .kind(UVM_PREDICT_WRITE), .be(item.a_mask)));

      // process the csr req
      case (1)
        (!uvm_re_match(
            &quot;ctrl*&quot;, csr_name
        )): begin
          for (int i = 0; i &lt; NUM_HARTS; i++) begin
            for (int j = 0; j &lt; NUM_TIMERS; j++) begin
              en_timers[i][j] = get_reg_fld_mirror_value(ral, &quot;ctrl&quot;, $sformatf(&quot;active_%0d&quot;, j));
            end
            //Sample all timers active coverage for each hart
            if (cfg.en_cov) cov.ctrl_reg_cov_obj[i].timer_active_cg.sample(en_timers[i]);
          end
        end
        (!uvm_re_match(
            &quot;cfg*&quot;, csr_name
        )): begin
          for (int i = 0; i &lt; NUM_HARTS; i++) begin
            step[i]     = get_reg_fld_mirror_value(ral, $sformatf(&quot;cfg%0d&quot;, i), &quot;step&quot;);
            prescale[i] = get_reg_fld_mirror_value(ral, $sformatf(&quot;cfg%0d&quot;, i), &quot;prescale&quot;);
          end
        end
        (!uvm_re_match(
            &quot;timer_v_lower*&quot;, csr_name
        )): begin
          for (int i = 0; i &lt; NUM_HARTS; i++) begin
            timer_val[i][31:0] = get_reg_fld_mirror_value(
                ral, $sformatf(&quot;timer_v_lower%0d&quot;, i), &quot;v&quot;
            );
            num_clk_update_due[i] = 1&#39;b1;
          end
        end
        (!uvm_re_match(
            &quot;timer_v_upper*&quot;, csr_name
        )): begin
          for (int i = 0; i &lt; NUM_HARTS; i++) begin
            timer_val[i][63:32] = get_reg_fld_mirror_value(
                ral, $sformatf(&quot;timer_v_upper%0d&quot;, i), &quot;v&quot;
            );
            num_clk_update_due[i] = 1&#39;b1;
          end
        end
        (!uvm_re_match(
            &quot;compare_lower*&quot;, csr_name
        )): begin
          for (int i = 0; i &lt; NUM_HARTS; i++) begin
            for (int j = 0; j &lt; NUM_TIMERS; j++) begin
              int timer_idx = i * NUM_TIMERS + j;
              string compare_lower_str = $sformatf(&quot;compare_lower%0d_%0d&quot;, i, j);
              if (csr_name == compare_lower_str) begin
                compare_val[i][j][31:0] = csr.get_mirrored_value();
                if (en_timers[i][j] == 0) begin
                  // Reset the interrupt when mtimecmp is updated and timer is not active
                  intr_status_exp[i][j] = 0;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{&quot;rv_timer_sticky_intr_pin&quot;, $sformatf(&quot;%0d&quot;, timer_idx)
                  end
                end else begin
                  // intr stays sticky if timer is active
                  ctimecmp_update_on_fly = 1;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{&quot;rv_timer_sticky_intr_pin&quot;, $sformatf(&quot;%0d&quot;, timer_idx)
                  end
                end
                break;
              end
            end
          end
        end
        (!uvm_re_match(
            &quot;compare_upper*&quot;, csr_name
        )): begin
          for (int i = 0; i &lt; NUM_HARTS; i++) begin
            for (int j = 0; j &lt; NUM_TIMERS; j++) begin
              int timer_idx = i * NUM_TIMERS + j;
              string compare_upper_str = $sformatf(&quot;compare_upper%0d_%0d&quot;, i, j);
              if (csr_name == compare_upper_str) begin
                compare_val[i][j][63:32] = csr.get_mirrored_value();
                if (en_timers[i][j] == 0) begin
                  // Reset the interrupt when mtimecmp is updated and timer is not active
                  intr_status_exp[i][j] = 0;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{&quot;rv_timer_sticky_intr_pin&quot;, $sformatf(&quot;%0d&quot;, timer_idx)
                  end
                end else begin
                  // intr stays sticky if timer is active
                  ctimecmp_update_on_fly = 1;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{&quot;rv_timer_sticky_intr_pin&quot;, $sformatf(&quot;%0d&quot;, timer_idx)
                  end
                end
                break;
              end
            end
          end
        end
        (!uvm_re_match(
            &quot;intr_enable*&quot;, csr_name
        )): begin
          for (int i = 0; i &lt; NUM_HARTS; i++) begin
            for (int j = 0; j &lt; NUM_TIMERS; j++) begin
              en_interrupt[i][j] = get_reg_fld_mirror_value(
                  ral, $sformatf(&quot;intr_enable%0d&quot;, i), $sformatf(&quot;ie_%0d&quot;, j)
              );
            end
          end
        end
        (!uvm_re_match(
            &quot;intr_state*&quot;, csr_name
        )): begin
          for (int i = 0; i &lt; NUM_HARTS; i++) begin
            string intr_state_str = $sformatf(&quot;intr_state%0d&quot;, i);
            if (csr_name == intr_state_str) begin
              // Intr_state reg is W1C, update expected status with RAL mirrored val
              for (int j = 0; j &lt; NUM_TIMERS; j++) begin
                int timer_idx = i * NUM_TIMERS + j;
                if (item.a_data[j] == 1) begin
                  if (en_timers[i][j] == 0) begin
                    intr_status_exp[i][j] = 0;
                    if (cfg.en_cov) begin
                      cov.sticky_intr_cov[{&quot;rv_timer_sticky_intr_pin&quot;, $sformatf(&quot;%0d&quot;, timer_idx)
                    end
                  end else if (cfg.en_cov) begin  // sticky interrupt
                    cov.sticky_intr_cov[{&quot;rv_timer_sticky_intr_pin&quot;, $sformatf(&quot;%0d&quot;, timer_idx)
                  end
                end
              end
              break;
            end
          end
        end
        (!uvm_re_match(
            &quot;intr_test*&quot;, csr_name
        )): begin
          for (int i = 0; i &lt; NUM_HARTS; i++) begin
            string intr_test_str = $sformatf(&quot;intr_test%0d&quot;, i);
            if (csr_name == intr_test_str) begin
              uint intr_test_val = item.a_data;
              for (int j = 0; j &lt; NUM_TIMERS; j++) begin
                int intr_pin_idx = i * NUM_TIMERS + j;
                if (intr_test_val[j]) intr_status_exp[i][j] = intr_test_val[j];
                //Sample intr_test coverage for each bit of test reg
                if (cfg.en_cov)
                  cov.intr_test_cg.sample(intr_pin_idx, intr_test_val[j], en_interrupt[i][j],
                                          intr_status_exp[i][j]);
              end
              break;
            end
          end
        end
        default: begin
          `uvm_fatal(`gfn, $sformatf(&quot;invalid csr: %0s&quot;, csr.get_full_name()))
        end
      endcase
    end

    if (channel == DataChannel) begin
      // Check all interrupts in DataChannel of every Read/Write except when ctimecmp updated
      // during timer active. This scenario is checked in base sequence by reading the intr_state.
      // Ignored checking here because sticky intr_pin update has one cycle delay.
      // TODO #1464: temp constraint, if support external reg, this can be removed
      if (!ctimecmp_update_on_fly) check_interrupt_pin();
      ctimecmp_update_on_fly = 0;

      // On reads, if do_read_check, is set, then check mirrored_value against item.d_data
      if (!write) begin
        // exclude read check for timer_val* reg if read happended when timer is enabled
        if (!uvm_re_match(&quot;timer_v_*&quot;, csr_name)) begin
          for (int i = 0; i &lt; NUM_HARTS; i++) begin
            if (!uvm_re_match($sformatf(&quot;timer_v_*%0d&quot;, i), csr_name)) begin
              if (en_timers[i] == 0) begin
                `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data)
              end else begin
                if (!uvm_re_match(&quot;timer_v_lower*&quot;, csr_name)) begin
                  timer_val[i][31:0] = item.d_data;
                  // on timer_val read update num_clks
                  num_clk_update_due[i] = 1&#39;b1;
                end else begin
                  timer_val[i][63:32] = item.d_data;
                end
              end
              break;
            end else if (i == (NUM_HARTS - 1)) begin
              `uvm_fatal(`gfn, $sformatf(&quot;invalid csr: %0s&quot;, csr.get_full_name()))
            end
          end
        end
        // Read happened for other registers
        else
        if (do_read_check) begin
          `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data)
        end

        void&#39;(csr.predict(.value(item.d_data), .kind(UVM_PREDICT_READ)));
      end
    end
  endtask

  // Task : compute_and_check_interrupt
  // wait for expected # of clocks and check for interrupt state reg and pin
  virtual task compute_and_check_interrupt();
    bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] reset_count;

    fork
      begin
        forever begin : compute_num_clks
          // calculate number of clocks required to have interrupt
          @(en_timers or num_clk_update_due);
          wait(under_reset == 0);
          foreach (en_timers[i, j]) begin
            uint64 mtime_diff = compare_val[i][j] - timer_val[i];
            num_clks[i][j] = ((mtime_diff / step[i]) +
                              ((mtime_diff % step[i]) != 0)) * (prescale[i] + 1) + 1;
          end
          // reset count if timer is enabled and num_clks got updated
          for (int i = 0; i &lt; NUM_HARTS; i++) begin
            if (num_clk_update_due[i]) reset_count[i] = en_timers[i];
          end
          num_clk_update_due = &#39;0;
        end  // compute_num_clks
      end
    join_none

    forever begin : wait_for_interrupt
      @(en_timers or under_reset);
      wait(under_reset == 0);
      // fork a thread for enabled timer on all enabled hart
      foreach (en_timers[i, j]) begin
        automatic int a_i = i;
        automatic int a_j = j;
        fork
          if (en_timers[a_i][a_j] &amp; !en_timers_prev[a_i][a_j]) begin
            fork
              begin
                uint64 count = 0;
                en_timers_prev[a_i][a_j] = 1&#39;b1;
                forever begin
                  @cfg.clk_rst_vif.cb;
                  count = count + 1;
                  if (reset_count[a_i][a_j] == 1&#39;b1) begin
                    count = 0;
                    reset_count[a_i][a_j] = 1&#39;b0;
                  end
                  if (count &gt;= num_clks[a_i][a_j]) break;
                end
                // enabling one clock cycle of ignore period
                ignore_period[a_i][a_j] = 1&#39;b1;
                `uvm_info(`gfn, $sformatf(&quot;Timer expired check for interrupt&quot;), UVM_MEDIUM)
                // Update exp val and predict it in read address_channel
                intr_status_exp[a_i][a_j] = 1&#39;b1;
                check_interrupt_pin();
                if (cfg.en_cov) begin
                  int timer_idx = a_i * NUM_TIMERS + a_j;
                  //Sample cfg coverage for each timer
                  cov.cfg_values_cov_obj[timer_idx].timer_cfg_cg.sample(
                      step[a_i], prescale[a_i], timer_val[a_i], compare_val[a_i][a_j]);
                  //Sample toggle coverage for each prescale bit
                  for (int i = 0; i &lt; 12; i++) begin
                    cov.rv_timer_prescale_values_cov_obj[a_i][i].sample(prescale[a_i][i]);
                  end
                end
                @cfg.clk_rst_vif.cb;
                ignore_period[a_i][a_j] = 1&#39;b0;
              end
              begin
                wait((en_timers[a_i][a_j] == 0) | (under_reset == 1));
              end
            join_any
            en_timers_prev[a_i][a_j] = 1&#39;b0;
            // kill forked threads if timer disabled or interrupt occured or under reset
            disable fork;
          end
        join_none
      end
    end  // wait_for_interrupt
  endtask : compute_and_check_interrupt

  // task : check_interrupt_pin
  // check all interrupt output pins with expected intr state &amp; pin enable
  // according to issue #841, interrupt will have one clock cycle delay
  task check_interrupt_pin();
    fork
      begin
        // store the `intr_status_exp` and `en_interrupt` values into an automatic local variable
        // in case the values are being updated during the one clock cycle wait.
        automatic uint stored_intr_status_exp[NUM_HARTS] = intr_status_exp;
        automatic bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] stored_en_interrupt = en_interrupt;
        cfg.clk_rst_vif.wait_clks(1);
        if (!under_reset) begin
          for (int i = 0; i &lt; NUM_HARTS; i++) begin
            for (int j = 0; j &lt; NUM_TIMERS; j++) begin
              int intr_pin_idx = i * NUM_TIMERS + j;
              `DV_CHECK_CASE_EQ(cfg.intr_vif.sample_pin(.idx(intr_pin_idx)),
                                (stored_intr_status_exp[i][j] &amp; stored_en_interrupt[i][j]))
              // Sample interrupt and interrupt pin coverage for each timer
              if (cfg.en_cov) begin
                cov.intr_cg.sample(intr_pin_idx, stored_en_interrupt[i][j],
                                   stored_intr_status_exp[i][j]);
                cov.intr_pins_cg.sample(intr_pin_idx, cfg.intr_vif.sample_pin(.idx(intr_pin_idx)));
              end
            end
          end
        end
      end
    join_none
  endtask

  virtual function void reset(string kind = &quot;HARD&quot;);
    super.reset(kind);
    // reset the local values
    step                   = &#39;{default: 1};
    prescale               = &#39;{default: 0};
    timer_val              = &#39;{default: 0};
    compare_val            = &#39;{default: &#39;1};
    en_timers              = &#39;{default: 0};
    en_interrupt           = &#39;{default: 0};
    intr_status_exp        = &#39;{default: 0};
    ignore_period          = &#39;{default: 0};
    en_timers_prev         = &#39;{default: 0};
    ctimecmp_update_on_fly = 0;
  endfunction

  function void check_phase(uvm_phase phase);
    super.check_phase(phase);
  endfunction

endclass
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-rv-timer-dv-env-seq-lib-rv-timer-base-vseq-sv">
<span id="error-hw-ip-rv-timer-dv-env-seq-lib-rv-timer-base-vseq-sv"></span><h2>hw/ip/rv_timer/dv/env/seq_lib/rv_timer_base_vseq.sv<a class="headerlink" href="#hw-ip-rv-timer-dv-env-seq-lib-rv-timer-base-vseq-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/rv_timer/dv/env/seq_lib/rv_timer_base_vseq.sv: Error lex/parsing-ing formatted output.  Please file a bug.
First error: token: &quot;bit&quot; at 165:5-7; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class rv_timer_base_vseq extends cip_base_vseq #(
  .CFG_T              (rv_timer_env_cfg),
  .RAL_T              (rv_timer_reg_block),
  .COV_T              (rv_timer_env_cov),
  .VIRTUAL_SEQUENCER_T(rv_timer_virtual_sequencer)
);
  `uvm_object_utils(rv_timer_base_vseq)

  // random delay between consecutive transactions
  rand uint delay;

  constraint delay_c {
    delay dist {
      0                    :/ 1,
      [1 : 100]            :/ 1,
      [101 : 10_000]       :/ 8,
      [10_001 : 1_000_000] :/ 1
    };
  }

  // hart specific parameters
  // These need to be NUM_HARTS size arrays; but the current assumption is these values will be the
  // same for all harts.
  bit [TL_DW-1:0] max_prescale;
  bit [TL_DW-1:0] max_step;

  `uvm_object_new

  function void pre_randomize();
    super.pre_randomize();
    max_prescale = (1 &lt;&lt; p_sequencer.cfg.ral.cfg0.prescale.get_n_bits()) - 1;
    max_step = (1 &lt;&lt; p_sequencer.cfg.ral.cfg0.step.get_n_bits()) - 1;
  endfunction

  task pre_start();
    super.pre_start();
  endtask

  // cfg rv_timer - set a particular timer active or inactive
  virtual task cfg_timer(int hart = 0, int timer = 0, bit enable = 1&#39;b1);
    uvm_reg       ctrl_rg;
    uvm_reg_field active_fld;
    `DV_CHECK_LT_FATAL(hart, NUM_HARTS)
    `DV_CHECK_LT_FATAL(timer, NUM_TIMERS)
    ctrl_rg = ral.get_reg_by_name($sformatf(&quot;ctrl&quot;));
    `DV_CHECK_NE_FATAL(ctrl_rg, null)
    active_fld = ctrl_rg.get_field_by_name($sformatf(&quot;active_%0d&quot;, timer));
    `DV_CHECK_NE_FATAL(active_fld, null)
    active_fld.set(enable);
    csr_update(.csr(ctrl_rg));
  endtask

  // cfg rv_timer prescaler and count step
  virtual task cfg_hart(int hart = 0, int prescale = 1, int step = 1);
    uvm_reg hart_cfg_rg;
    `DV_CHECK_LT_FATAL(hart, NUM_HARTS)
    `DV_CHECK_LE_FATAL(prescale, max_prescale)
    `DV_CHECK_LE_FATAL(step, max_step)
    hart_cfg_rg = ral.get_reg_by_name($sformatf(&quot;cfg%0d&quot;, hart));
    `DV_CHECK_NE_FATAL(hart_cfg_rg, null)
    hart_cfg_rg.get_field_by_name(&quot;prescale&quot;).set(prescale);
    hart_cfg_rg.get_field_by_name(&quot;step&quot;).set(step);
    csr_update(.csr(hart_cfg_rg));
  endtask

  // set timer value for a particular HART
  virtual task set_timer_val(int hart = 0, bit [63:0] val);
    uvm_reg timer_val_l_rg;
    uvm_reg timer_val_u_rg;
    `DV_CHECK_LT_FATAL(hart, NUM_HARTS)
    timer_val_l_rg = ral.get_reg_by_name($sformatf(&quot;timer_v_lower%0d&quot;, hart));
    timer_val_u_rg = ral.get_reg_by_name($sformatf(&quot;timer_v_upper%0d&quot;, hart));
    `DV_CHECK_NE_FATAL(timer_val_l_rg, null)
    `DV_CHECK_NE_FATAL(timer_val_u_rg, null)
    timer_val_l_rg.set(val[31:0]);
    timer_val_u_rg.set(val[63:32]);
    csr_update(.csr(timer_val_l_rg));
    csr_update(.csr(timer_val_u_rg));
  endtask

  // set timer value for a particular timer
  virtual task set_compare_val(int hart = 0, int timer = 0, bit [63:0] val);
    uvm_reg compare_val_l_rg;
    uvm_reg compare_val_u_rg;
    `DV_CHECK_LT_FATAL(hart, NUM_HARTS)
    `DV_CHECK_LT_FATAL(timer, NUM_TIMERS)
    compare_val_l_rg = ral.get_reg_by_name($sformatf(&quot;compare_lower%0d_%0d&quot;, hart, timer));
    compare_val_u_rg = ral.get_reg_by_name($sformatf(&quot;compare_upper%0d_%0d&quot;, hart, timer));
    `DV_CHECK_NE_FATAL(compare_val_l_rg, null)
    `DV_CHECK_NE_FATAL(compare_val_u_rg, null)
    compare_val_l_rg.set(val[31:0]);
    compare_val_u_rg.set(val[63:32]);
    csr_update(.csr(compare_val_l_rg));
    csr_update(.csr(compare_val_u_rg));
  endtask

  // configure interrupt
  virtual task cfg_interrupt(int hart = 0, int timer = 0, bit enable = 1&#39;b1);
    uvm_reg       intr_en_rg;
    uvm_reg_field timer_intr_en_fld;
    int           intr_pin_idx = hart * NUM_TIMERS + timer;
    `DV_CHECK_LT_FATAL(hart, NUM_HARTS)
    `DV_CHECK_LT_FATAL(timer, NUM_TIMERS)
    intr_en_rg = ral.get_reg_by_name($sformatf(&quot;intr_enable%0d&quot;, hart));
    `DV_CHECK_NE_FATAL(intr_en_rg, null)
    timer_intr_en_fld = intr_en_rg.get_field_by_name($sformatf(&quot;ie_%0d&quot;, timer));
    `DV_CHECK_NE_FATAL(timer_intr_en_fld, null)
    timer_intr_en_fld.set(enable);
    csr_update(.csr(intr_en_rg));
    // also check intr output, if disabled
    if (!enable) begin
      `DV_CHECK_EQ(cfg.intr_vif.sample_pin(.idx(intr_pin_idx)), 1&#39;b0)
    end
  endtask

  // check if interrupt fired
  virtual task check_interrupt(int hart = 0, int timer = 0, bit exp_intr_state, bit exp_intr_pin);
    uvm_reg       intr_state_rg;
    uvm_reg_field timer_intr_state_fld;
    int           intr_pin_idx = hart * NUM_TIMERS + timer;
    `DV_CHECK_LT_FATAL(hart, NUM_HARTS)
    `DV_CHECK_LT_FATAL(timer, NUM_TIMERS)
    intr_state_rg = ral.get_reg_by_name($sformatf(&quot;intr_state%0d&quot;, hart));
    `DV_CHECK_NE_FATAL(intr_state_rg, null)
    timer_intr_state_fld = intr_state_rg.get_field_by_name($sformatf(&quot;is_%0d&quot;, timer));
    `DV_CHECK_NE_FATAL(timer_intr_state_fld, null)
    void&#39;(timer_intr_state_fld.predict(.value(exp_intr_state), .kind(UVM_PREDICT_DIRECT)));
    csr_rd_check(.ptr(intr_state_rg), .compare_vs_ral(1));
    // also check intr output
    `DV_CHECK_EQ(cfg.intr_vif.sample_pin(.idx(intr_pin_idx)), exp_intr_pin)
  endtask

  // task to write 1 to clear and read the interrupt status register
  virtual task clear_intr_state(int hart = 0, int timer = 0);
    uvm_reg                   intr_state_rg;
    uvm_reg_field             is_fld;
    bit           [TL_DW-1:0] status;
    bit           [TL_DW-1:0] wr_value;
    `DV_CHECK_LT_FATAL(hart, NUM_HARTS)
    `DV_CHECK_LT_FATAL(timer, NUM_TIMERS)
    // randomly clear the intr by writing intr_state or mtimecmp
    intr_state_rg = ral.get_reg_by_name($sformatf(&quot;intr_state%0d&quot;, hart));
    `DV_CHECK_NE_FATAL(intr_state_rg, null)

    if ($urandom_range(0, 1)) begin
      wr_value = 1 &lt;&lt; timer;
      csr_wr(.ptr(intr_state_rg), .value(wr_value));
    end else begin
      wr_value = $urandom();
      set_compare_val(hart, timer, wr_value);
      // wait one clk cycle then check intr, to ensure get the sticky interrupt value
      cfg.clk_rst_vif.wait_clks(1);
    end
    csr_rd(.ptr(intr_state_rg), .value(status));
  endtask

  // poll a intr_status continuously until it reads the expected value.
  virtual task intr_state_spinwait(input int hart = 0, input uint exp_data = 0,
                                   input uint spinwait_delay_ns = 0,
                                   input uint timeout_ns = 10_000_000
    bit [TL_DW-1:0] read_data;
    bit reset_asserted;
    uvm_reg intr_state_rg;
    intr_state_rg = ral.get_reg_by_name($sformatf(&quot;intr_state%0d&quot;, hart));
    `DV_CHECK_NE_FATAL(intr_state_rg, null)
    fork
      begin : isolation_fork
        fork
          begin
            wait(cfg.clk_rst_vif.rst_n == 0);
            reset_asserted = 1&#39;b1;
          end
        join_none
        fork
          while (1) begin
            csr_rd(.ptr(intr_state_rg), .value(read_data));
            if (spinwait_delay_ns) #(spinwait_delay_ns * 1ns);
            if ((read_data == exp_data) | (reset_asserted == 1)) break;
          end
          begin
            wait_timeout(timeout_ns, &quot;intr_state_spinwait&quot;, $sformatf(
                         &quot;timeout %0s (addr=0x%0h) == 0x%0h&quot;,
                         intr_state_rg.get_full_name(),
                         intr_state_rg.get_address(),
                         exp_data
                         ));
          end
        join_any
        disable fork;
      end : isolation_fork
    join
  endtask

  // task to read interrup status reg for given Hart
  virtual task read_intr_status_reg(input int hart = 0, output uint status_val);
    uvm_reg intr_state_rg;
    intr_state_rg = ral.get_reg_by_name($sformatf(&quot;intr_state%0d&quot;, hart));
    `DV_CHECK_NE_FATAL(intr_state_rg, null)
    csr_rd(.ptr(intr_state_rg), .value(status_val));
  endtask : read_intr_status_reg

  // task to read timer value reg for given Hart
  virtual task read_timer_val_reg(input int hart = 0, output uint64 mtime_val);
    bit [TL_DW-1:0] read_data;
    uvm_reg timer_val_l_rg;
    uvm_reg timer_val_u_rg;
    timer_val_l_rg = ral.get_reg_by_name($sformatf(&quot;timer_v_lower%0d&quot;, hart));
    timer_val_u_rg = ral.get_reg_by_name($sformatf(&quot;timer_v_upper%0d&quot;, hart));
    `DV_CHECK_NE_FATAL(timer_val_l_rg, null)
    `DV_CHECK_NE_FATAL(timer_val_u_rg, null)
    csr_rd(.ptr(timer_val_u_rg), .value(read_data));
    mtime_val[63:32] = read_data;
    csr_rd(.ptr(timer_val_l_rg), .value(read_data));
    mtime_val[31:0] = read_data;
  endtask : read_timer_val_reg

  // Status register read random for passed clks
  virtual task status_read_for_clks(int hart = 0, int clks);
    bit stop_reading;
    fork
      begin
        cfg.clk_rst_vif.wait_clks(clks);
        stop_reading = 1&#39;b1;
      end
      begin
        forever begin
          // read will trigger check in scoreboard
          uint rd_data;
          read_intr_status_reg(.hart(hart), .status_val(rd_data));
          fork
            begin : isolation_fork
              fork
                begin
                  delay = $urandom_range(1, 10000);
                  #(delay * 1ns);
                end
                wait(stop_reading == 1);
              join_any
              disable fork;
            end : isolation_fork
          join
          if (stop_reading == 1) break;
        end
      end
    join
  endtask : status_read_for_clks

endclass : rv_timer_base_vseq
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-otp-ctrl-dv-tb-sv">
<span id="error-hw-ip-otp-ctrl-dv-tb-sv"></span><h2>hw/ip/otp_ctrl/dv/tb.sv<a class="headerlink" href="#hw-ip-otp-ctrl-dv-tb-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/otp_ctrl/dv/tb.sv: Error lex/parsing-ing formatted output.  Please file a bug.
First error: token: &quot;uvm_config_db&quot; at 280:5-17; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
module tb;
  // dep packages
  import uvm_pkg::*;
  import dv_utils_pkg::*;
  import otp_ctrl_env_pkg::*;
  import otp_ctrl_test_pkg::*;
  import otp_ctrl_reg_pkg::*;
  import mem_bkdr_util_pkg::mem_bkdr_util;

  // macro includes
  `include &quot;uvm_macros.svh&quot;
  `include &quot;dv_macros.svh&quot;

  // TB base test ENV_T &amp; CFG_T specification
  //
  // Specify the parameters for the otp_ctrl_base_test
  // This will invoke the UVM registry and link this test type to
  // the name &#39;otp_ctrl_base_test&#39; as a test name passed by UVM_TESTNAME
  //
  // This is done explicitly only for the prim_pkg::ImplGeneric implementation
  // since partner base tests inherit from otp_ctrl_base_test#(CFG_T, ENV_T) and
  // specify directly (CFG_T, ENV_T) via the class extension and use a different
  // UVM_TESTNAME
  if (`PRIM_DEFAULT_IMPL == prim_pkg::ImplGeneric) begin : gen_spec_base_test_params
    typedef otp_ctrl_base_test#(
      .CFG_T(otp_ctrl_env_cfg),
      .ENV_T(otp_ctrl_env)
    ) otp_ctrl_base_test_t;
  end

  wire clk, rst_n;
  wire devmode;
  wire otp_ctrl_pkg::flash_otp_key_req_t flash_req;
  wire otp_ctrl_pkg::flash_otp_key_rsp_t flash_rsp;
  wire otp_ctrl_pkg::otbn_otp_key_req_t otbn_req;
  wire otp_ctrl_pkg::otbn_otp_key_rsp_t otbn_rsp;
  wire otp_ctrl_pkg::sram_otp_key_req_t [NumSramKeyReqSlots-1:0] sram_req;
  wire otp_ctrl_pkg::sram_otp_key_rsp_t [NumSramKeyReqSlots-1:0] sram_rsp;

  wire [NUM_MAX_INTERRUPTS-1:0] interrupts;
  wire intr_otp_operation_done, intr_otp_error;

  wire otp_ctrl_pkg::otp_ast_req_t ast_req;

  // interfaces
  clk_rst_if clk_rst_if (
    .clk  (clk),
    .rst_n(rst_n)
  );
  pins_if #(NUM_MAX_INTERRUPTS) intr_if (interrupts);
  pins_if #(1) devmode_if (devmode);

  // lc_otp interfaces
  push_pull_if #(
    .HostDataWidth  (LC_PROG_DATA_SIZE),
    .DeviceDataWidth(1)
  ) lc_prog_if (
    .clk  (clk),
    .rst_n(rst_n)
  );
  push_pull_if #(
    .DeviceDataWidth(SRAM_DATA_SIZE)
  ) sram_if[NumSramKeyReqSlots] (
    .clk  (clk),
    .rst_n(rst_n)
  );
  push_pull_if #(
    .DeviceDataWidth(OTBN_DATA_SIZE)
  ) otbn_if (
    .clk  (clk),
    .rst_n(rst_n)
  );
  push_pull_if #(
    .DeviceDataWidth(FLASH_DATA_SIZE)
  ) flash_addr_if (
    .clk  (clk),
    .rst_n(rst_n)
  );
  push_pull_if #(
    .DeviceDataWidth(FLASH_DATA_SIZE)
  ) flash_data_if (
    .clk  (clk),
    .rst_n(rst_n)
  );

  tl_if tl_if (
    .clk  (clk),
    .rst_n(rst_n)
  );

  otp_ctrl_if otp_ctrl_if (
    .clk_i (clk),
    .rst_ni(rst_n)
  );

  `DV_ALERT_IF_CONNECT

  // edn_clk, edn_rst_n and edn_if are defined and driven in below macro
  `DV_EDN_IF_CONNECT

  assign otp_ctrl_if.lc_prog_req = lc_prog_if.req;
  assign otp_ctrl_if.lc_prog_err = lc_prog_if.d_data;
  // This signal probes design&#39;s alert request to avoid additional logic for triggering alert and
  // disable assertions.
  // Alert checkings are done independently in otp_ctrl&#39;s scb.
  // The correctness of this probed signal is checked in otp_ctrl&#39;s scb as well.
  assign otp_ctrl_if.alert_reqs  = dut.alerts[0] | dut.alerts[1];

  // leave this unconnected for now.
  wire otp_ext_voltage_h;

  // dut
  otp_ctrl dut (
    .clk_i                     (clk),
    .rst_ni                    (rst_n),
    // edn
    .clk_edn_i                 (edn_clk),
    .rst_edn_ni                (edn_rst_n),
    .edn_o                     (edn_if.req),
    .edn_i                     ({edn_if.ack, edn_if.d_data}),
    // bus interfaces
    .core_tl_i                 (tl_if.h2d),
    .core_tl_o                 (tl_if.d2h),
    // TODO: add second TL interface
    .prim_tl_i                 (&#39;0),
    .prim_tl_o                 (&#39;0),
    // interrupt
    .intr_otp_operation_done_o (intr_otp_operation_done),
    .intr_otp_error_o          (intr_otp_error),
    // alert
    .alert_rx_i                (alert_rx),
    .alert_tx_o                (alert_tx),
    // ast
    .otp_ast_pwr_seq_o         (ast_req),
    .otp_ast_pwr_seq_h_i       (ast_req),
    .otp_alert_o               (otp_ctrl_if.otp_alert_o),
    // pwrmgr
    .pwr_otp_i                 (otp_ctrl_if.pwr_otp_init_i),
    .pwr_otp_o                 ({otp_ctrl_if.pwr_otp_done_o, otp_ctrl_if.pwr_otp_idle_o}),
    // lc
    .lc_otp_program_i          ({lc_prog_if.req, lc_prog_if.h_data, otp_ctrl_if.otp_test_ctrl_i}),
    .lc_otp_program_o          ({lc_prog_if.d_data, lc_prog_if.ack}),
    .lc_creator_seed_sw_rw_en_i(otp_ctrl_if.lc_creator_seed_sw_rw_en_i),
    .lc_seed_hw_rd_en_i        (otp_ctrl_if.lc_seed_hw_rd_en_i),
    .lc_dft_en_i               (otp_ctrl_if.lc_dft_en_i),
    .lc_escalate_en_i          (otp_ctrl_if.lc_escalate_en_i),
    .lc_check_byp_en_i         (otp_ctrl_if.lc_check_byp_en_i),
    .otp_lc_data_o             (otp_ctrl_if.lc_data_o),
    // keymgr
    .otp_keymgr_key_o          (otp_ctrl_if.keymgr_key_o),
    // flash
    .flash_otp_key_i           (flash_req),
    .flash_otp_key_o           (flash_rsp),
    // sram
    .sram_otp_key_i            (sram_req),
    .sram_otp_key_o            (sram_rsp),
    // otbn
    .otbn_otp_key_i            (otbn_req),
    .otbn_otp_key_o            (otbn_rsp),

    .otp_hw_cfg_o        (otp_ctrl_if.otp_hw_cfg_o),
    .otp_ext_voltage_h_io(otp_ext_voltage_h),

    //scan
    .scan_en_i  (otp_ctrl_if.scan_en_i),
    .scan_rst_ni(otp_ctrl_if.scan_rst_ni),
    .scanmode_i (lc_ctrl_pkg::Off),

    // Test-related GPIO output
    .cio_test_o   (),
    .cio_test_en_o()
  );

  for (genvar i = 0; i &lt; NumSramKeyReqSlots; i++) begin : gen_sram_pull_if
    assign sram_req[i]       = sram_if[i].req;
    assign sram_if[i].ack    = sram_rsp[i].ack;
    assign sram_if[i].d_data = {sram_rsp[i].key, sram_rsp[i].nonce, sram_rsp[i].seed_valid};
    initial begin
      uvm_config_db#(virtual push_pull_if #(.DeviceDataWidth(SRAM_DATA_SIZE)))::set(
                                            null,
                                            $sformatf(
                                                &quot;*env.m_sram_pull_agent[%0d]*&quot;, i
                                            ),
                                            &quot;vif&quot;,
                                            sram_if[i]);
    end
  end
  assign otbn_req                     = otbn_if.req;
  assign otbn_if.ack                  = otbn_rsp.ack;
  assign otbn_if.d_data               = {otbn_rsp.key, otbn_rsp.nonce, otbn_rsp.seed_valid};

  assign flash_req                    = {flash_data_if.req, flash_addr_if.req};
  assign flash_data_if.ack            = flash_rsp.data_ack;
  assign flash_addr_if.ack            = flash_rsp.addr_ack;
  assign flash_data_if.d_data         = {flash_rsp.key, flash_rsp.seed_valid};
  assign flash_addr_if.d_data         = {flash_rsp.key, flash_rsp.seed_valid};

  assign interrupts[OtpOperationDone] = intr_otp_operation_done;
  assign interrupts[OtpErr]           = intr_otp_error;

  // Instantitate the memory backdoor util instance only for OS implementation
  // Proprietary IP will instantiate their own backdoor util

  if (`PRIM_DEFAULT_IMPL == prim_pkg::ImplGeneric) begin : gen_impl_generic
    `define MEM_MODULE_PATH \
        tb.dut.u_otp.gen_generic.u_impl_generic.u_prim_ram_1p_adv

    `define MEM_ARRAY_PATH \
        `MEM_MODULE_PATH.u_mem.gen_generic.u_impl_generic.mem

    initial begin : mem_bkdr_util_gen
      mem_bkdr_util m_mem_bkdr_util;
      m_mem_bkdr_util = new(
      .name(&quot;mem_bkdr_util&quot;),
      .path(`DV_STRINGIFY(`MEM_ARRAY_PATH)),
      .depth($size(`MEM_ARRAY_PATH)),
      .n_bits($bits(`MEM_ARRAY_PATH)),
      .err_detection_scheme(mem_bkdr_util_pkg::EccHamming_22_16)
      );

      uvm_config_db#(mem_bkdr_util)::set(null, &quot;*.env&quot;, &quot;mem_bkdr_util&quot;, m_mem_bkdr_util);
    end : mem_bkdr_util_gen

    `undef MEM_ARRAY_PATH
    `undef MEM_MODULE_PATH
  end : gen_impl_generic

  initial begin
    // These SVA checks the lc_escalate_en is either Off or On, we will use more than these
    // 2 values.
    // If it&#39;s not Off, it should be On.
    $assertoff(0, tb.dut.u_prim_lc_sync_escalate_en.CheckTransients_A);
    $assertoff(0, tb.dut.u_prim_lc_sync_escalate_en.CheckTransients0_A);
    $assertoff(0, tb.dut.u_prim_lc_sync_escalate_en.CheckTransients1_A);

    // These SVA checks the lc_sync_seed_hw_rd_en is either Off or On, we will use more than these
    // 2 values.
    // If it&#39;s not On, it should be Off.
    $assertoff(0, tb.dut.u_prim_lc_sync_seed_hw_rd_en.CheckTransients_A);
    $assertoff(0, tb.dut.u_prim_lc_sync_seed_hw_rd_en.CheckTransients0_A);
    $assertoff(0, tb.dut.u_prim_lc_sync_seed_hw_rd_en.CheckTransients1_A);

    // These SVA checks the lc_check_byp_en is either Off or On, we will use more than these
    // 2 values.
    // If it&#39;s not On, it should be Off.
    $assertoff(0, tb.dut.u_prim_lc_sync_check_byp_en.CheckTransients_A);
    $assertoff(0, tb.dut.u_prim_lc_sync_check_byp_en.CheckTransients0_A);
    $assertoff(0, tb.dut.u_prim_lc_sync_check_byp_en.CheckTransients1_A);

    // DV forced otp_cmd_i to reach invalid state, thus violate the assertions
    $assertoff(0, tb.dut.gen_partitions[2].gen_buffered.u_part_buf.OtpErrorState_A);
    $assertoff(0, tb.dut.gen_partitions[3].gen_buffered.u_part_buf.OtpErrorState_A);
    $assertoff(0, tb.dut.gen_partitions[4].gen_buffered.u_part_buf.OtpErrorState_A);
    $assertoff(0, tb.dut.gen_partitions[5].gen_buffered.u_part_buf.OtpErrorState_A);

    // drive clk and rst_n from clk_if
    clk_rst_if.set_active();
    uvm_config_db#(virtual clk_rst_if)::set(null, &quot;*.env&quot;, &quot;clk_rst_vif&quot;, clk_rst_if);
    uvm_config_db#(virtual tl_if)::set(null, &quot;*.env.m_tl_agent_otp_ctrl_core_reg_block*&quot;, &quot;vif&quot;,
                                       tl_if);
    uvm_config_db#(virtual push_pull_if #(.DeviceDataWidth(OTBN_DATA_SIZE)))::set(
                                          null, &quot;*env.m_otbn_pull_agent*&quot;, &quot;vif&quot;, otbn_if);
    uvm_config_db#(virtual push_pull_if #(.DeviceDataWidth(FLASH_DATA_SIZE)))::set(
                                          null,
                                          &quot;*env.m_flash_data_pull_agent*&quot;,
                                          &quot;vif&quot;,
                                          flash_data_if);
    uvm_config_db#(virtual push_pull_if #(.DeviceDataWidth(FLASH_DATA_SIZE)))::set(
                                          null,
                                          &quot;*env.m_flash_addr_pull_agent*&quot;,
                                          &quot;vif&quot;,
                                          flash_addr_if);
    uvm_config_db#(virtual push_pull_if #(.HostDataWidth(LC_PROG_DATA_SIZE), .DeviceDataWidth(1)


    uvm_config_db#(intr_vif)::set(null, &quot;*.env&quot;, &quot;intr_vif&quot;, intr_if);
    uvm_config_db#(devmode_vif)::set(null, &quot;*.env&quot;, &quot;devmode_vif&quot;, devmode_if);

    uvm_config_db#(virtual otp_ctrl_if)::set(null, &quot;*.env&quot;, &quot;otp_ctrl_vif&quot;, otp_ctrl_if);
    $timeformat(-12, 0, &quot; ps&quot;, 12);
    run_test();
  end

endmodule
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-otp-ctrl-dv-env-otp-ctrl-env-sv">
<span id="error-hw-ip-otp-ctrl-dv-env-otp-ctrl-env-sv"></span><h2>hw/ip/otp_ctrl/dv/env/otp_ctrl_env.sv<a class="headerlink" href="#hw-ip-otp-ctrl-dv-env-otp-ctrl-env-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/otp_ctrl/dv/env/otp_ctrl_env.sv: Error lex/parsing-ing formatted output.  Please file a bug.
First error: token: &quot;if&quot; at 94:5; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class otp_ctrl_env #(
  type CFG_T = otp_ctrl_env_cfg,
  type COV_T = otp_ctrl_env_cov,
  type VIRTUAL_SEQUENCER_T = otp_ctrl_virtual_sequencer,
  type SCOREBOARD_T = otp_ctrl_scoreboard
) extends cip_base_env #(
  .CFG_T              (CFG_T),
  .COV_T              (COV_T),
  .VIRTUAL_SEQUENCER_T(VIRTUAL_SEQUENCER_T),
  .SCOREBOARD_T       (SCOREBOARD_T)
);
  `uvm_component_param_utils(otp_ctrl_env#(CFG_T, COV_T, VIRTUAL_SEQUENCER_T, SCOREBOARD_T))

  `uvm_component_new

  push_pull_agent #(.DeviceDataWidth(SRAM_DATA_SIZE)) m_sram_pull_agent[NumSramKeyReqSlots];
  push_pull_agent #(.DeviceDataWidth(OTBN_DATA_SIZE)) m_otbn_pull_agent;
  push_pull_agent #(.DeviceDataWidth(FLASH_DATA_SIZE)) m_flash_addr_pull_agent;
  push_pull_agent #(.DeviceDataWidth(FLASH_DATA_SIZE)) m_flash_data_pull_agent;
  push_pull_agent #(
    .DeviceDataWidth(1),
    .HostDataWidth  (LC_PROG_DATA_SIZE)
  ) m_lc_prog_pull_agent;

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);

    // build sram-otp pull agent
    for (int i = 0; i &lt; NumSramKeyReqSlots; i++) begin
      string sram_agent_name = $sformatf(&quot;m_sram_pull_agent[%0d]&quot;, i);
      m_sram_pull_agent[i] = push_pull_agent#(
        .DeviceDataWidth(SRAM_DATA_SIZE)
      )::type_id::create(
          sram_agent_name, this
      );
      uvm_config_db#(push_pull_agent_cfg#(.DeviceDataWidth(SRAM_DATA_SIZE)))::set(
                                          this,
                                          $sformatf(
                                              &quot;%0s*&quot;, sram_agent_name
                                          ),
                                          &quot;cfg&quot;,
                                          cfg.m_sram_pull_agent_cfg[i]);
    end

    // build otbn-otp pull agent
    m_otbn_pull_agent = push_pull_agent#(
      .DeviceDataWidth(OTBN_DATA_SIZE)
    )::type_id::create(
        &quot;m_otbn_pull_agent&quot;, this
    );
    uvm_config_db#(push_pull_agent_cfg#(.DeviceDataWidth(OTBN_DATA_SIZE)))::set(
                                        this,
                                        &quot;m_otbn_pull_agent&quot;,
                                        &quot;cfg&quot;,
                                        cfg.m_otbn_pull_agent_cfg);

    // build flash-otp pull agent
    m_flash_addr_pull_agent = push_pull_agent#(
      .DeviceDataWidth(FLASH_DATA_SIZE)
    )::type_id::create(
        &quot;m_flash_addr_pull_agent&quot;, this
    );
    uvm_config_db#(push_pull_agent_cfg#(.DeviceDataWidth(FLASH_DATA_SIZE)))::set(
                                        this,
                                        &quot;m_flash_addr_pull_agent&quot;,
                                        &quot;cfg&quot;,
                                        cfg.m_flash_addr_pull_agent_cfg);
    m_flash_data_pull_agent = push_pull_agent#(
      .DeviceDataWidth(FLASH_DATA_SIZE)
    )::type_id::create(
        &quot;m_flash_data_pull_agent&quot;, this
    );
    uvm_config_db#(push_pull_agent_cfg#(.DeviceDataWidth(FLASH_DATA_SIZE)))::set(
                                        this,
                                        &quot;m_flash_data_pull_agent&quot;,
                                        &quot;cfg&quot;,
                                        cfg.m_flash_data_pull_agent_cfg);

    // build lc-otp program pull agent
    m_lc_prog_pull_agent = push_pull_agent#(
      .HostDataWidth  (LC_PROG_DATA_SIZE),
      .DeviceDataWidth(1)
    )::type_id::create(
        &quot;m_lc_prog_pull_agent&quot;, this
    );
    uvm_config_db#(push_pull_agent_cfg#(.HostDataWidth(LC_PROG_DATA_SIZE), .DeviceDataWidth(1)


    // config mem virtual interface
    if (!uvm_config_db#(mem_bkdr_util)::get(this, &quot;&quot;, &quot;mem_bkdr_util&quot;, cfg.mem_bkdr_util_h)) begin
      `uvm_fatal(`gfn, &quot;failed to get mem_bkdr_util from uvm_config_db&quot;)
    end

    // config otp_ctrl output data virtual interface
    if (!uvm_config_db#(otp_ctrl_vif)::get(this, &quot;&quot;, &quot;otp_ctrl_vif&quot;, cfg.otp_ctrl_vif)) begin
      `uvm_fatal(`gfn, &quot;failed to get otp_ctrl_vif from uvm_config_db&quot;)
    end
  endfunction

  function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);

    // connect SRAM sequencer and analysis ports
    for (int i = 0; i &lt; NumSramKeyReqSlots; i++) begin
      virtual_sequencer.sram_pull_sequencer_h[i] = m_sram_pull_agent[i].sequencer;
      if (cfg.en_scb) begin
        m_sram_pull_agent[i].monitor.analysis_port.connect(
            scoreboard.sram_fifos[i].analysis_export);
      end
    end

    virtual_sequencer.otbn_pull_sequencer_h       = m_otbn_pull_agent.sequencer;
    virtual_sequencer.flash_addr_pull_sequencer_h = m_flash_addr_pull_agent.sequencer;
    virtual_sequencer.flash_data_pull_sequencer_h = m_flash_data_pull_agent.sequencer;
    virtual_sequencer.lc_prog_pull_sequencer_h    = m_lc_prog_pull_agent.sequencer;
    if (cfg.en_scb) begin
      m_otbn_pull_agent.monitor.analysis_port.connect(scoreboard.otbn_fifo.analysis_export);
      m_flash_addr_pull_agent.monitor.analysis_port.connect(
          scoreboard.flash_addr_fifo.analysis_export);
      m_flash_data_pull_agent.monitor.analysis_port.connect(
          scoreboard.flash_data_fifo.analysis_export);
      m_lc_prog_pull_agent.monitor.analysis_port.connect(scoreboard.lc_prog_fifo.analysis_export);
    end
  endfunction

endclass
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-otp-ctrl-dv-env-otp-ctrl-scoreboard-sv">
<span id="error-hw-ip-otp-ctrl-dv-env-otp-ctrl-scoreboard-sv"></span><h2>hw/ip/otp_ctrl/dv/env/otp_ctrl_scoreboard.sv<a class="headerlink" href="#hw-ip-otp-ctrl-dv-env-otp-ctrl-scoreboard-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/otp_ctrl/dv/env/otp_ctrl_scoreboard.sv: Formatted output is lexically different from the input.    Please file a bug.  Details:
Mismatched token enums.  got: (&#39;)&#39;) (#41: &quot;)&quot;) vs. (MacroCallCloseToEndLine) (#746: &quot;)&quot;)
First mismatched token [3993]: (&#39;)&#39;) (#41: &quot;)&quot;) vs. (MacroCallCloseToEndLine) (#746: &quot;)&quot;)
; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class otp_ctrl_scoreboard #(
  type CFG_T = otp_ctrl_env_cfg
) extends cip_base_scoreboard #(
  .CFG_T(CFG_T),
  .RAL_T(otp_ctrl_core_reg_block),
  .COV_T(otp_ctrl_env_cov)
);
  `uvm_component_param_utils(otp_ctrl_scoreboard#(CFG_T))

  // local variables
  bit [TL_DW-1:0] otp_a[OTP_ARRAY_SIZE];

  // lc_state and lc_cnt that stored in OTP
  bit [LC_PROG_DATA_SIZE-1:0] otp_lc_data;
  bit [EDN_BUS_WIDTH-1:0] edn_data_q[$];

  // This flag is used when reset is issued during otp dai write access.
  bit dai_wr_ip;
  int dai_digest_ip = LifeCycleIdx;  // Default to LC as it does not have digest.
  bit ignore_digest_chk = 0;

  // This bit is used for DAI interface to mark if the read access is valid.
  bit dai_read_valid;

  // Status related variables
  bit under_chk, under_dai_access;
  bit [TL_DW-1:0] exp_status, status_mask;

  otp_alert_e exp_alert = OtpNoAlert;

  // TLM agent fifos
  uvm_tlm_analysis_fifo #(push_pull_item #(
    .DeviceDataWidth(SRAM_DATA_SIZE)
  )) sram_fifos[NumSramKeyReqSlots];
  uvm_tlm_analysis_fifo #(push_pull_item #(.DeviceDataWidth(OTBN_DATA_SIZE))) otbn_fifo;
  uvm_tlm_analysis_fifo #(push_pull_item #(.DeviceDataWidth(FLASH_DATA_SIZE))) flash_addr_fifo;
  uvm_tlm_analysis_fifo #(push_pull_item #(.DeviceDataWidth(FLASH_DATA_SIZE))) flash_data_fifo;
  uvm_tlm_analysis_fifo #(push_pull_item #(
    .DeviceDataWidth(1),
    .HostDataWidth  (LC_PROG_DATA_SIZE)
  )) lc_prog_fifo;

  // local queues to hold incoming packets pending comparison

  `uvm_component_new

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    for (int i = 0; i &lt; NumSramKeyReqSlots; i++) begin
      sram_fifos[i] = new($sformatf(&quot;sram_fifos[%0d]&quot;, i), this);
    end
    otbn_fifo       = new(&quot;otbn_fifo&quot;, this);
    flash_addr_fifo = new(&quot;flash_addr_fifo&quot;, this);
    flash_data_fifo = new(&quot;flash_data_fifo&quot;, this);
    lc_prog_fifo    = new(&quot;lc_prog_fifo&quot;, this);
  endfunction

  function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
  endfunction

  task run_phase(uvm_phase phase);
    super.run_phase(phase);
    fork
      process_wipe_mem();
      process_otp_power_up();
      process_lc_esc();
      process_lc_prog_req();
      process_edn_req();
      check_otbn_rsp();
      check_flash_rsps();
      check_sram_rsps();
      recover_lc_prog_req();
    join_none
  endtask

  // Once sequence uses backdoor method to clear memory, this task resets internal otp_a and
  // resets `cfg.backdoor_clear_mem` to 0.
  virtual task process_wipe_mem();
    forever begin
      @(posedge cfg.backdoor_clear_mem) begin
        bit [SCRAMBLE_DATA_SIZE-1:0] data = descramble_data(0, Secret0Idx);
        otp_a       = &#39;{default: 0};
        otp_lc_data = &#39;{default: 0};
        // secret partitions have been scrambled before writing to OTP.
        // here calculate the pre-srambled raw data when clearing internal OTP to all 0s.
        for (int i = SECRET0_START_ADDR; i &lt;= SECRET0_END_ADDR; i++) begin
          otp_a[i] = ((i - SECRET0_START_ADDR) % 2) ? data[SCRAMBLE_DATA_SIZE-1:TL_DW] :
                                                      data[TL_DW-1:0];
        end
        data = descramble_data(0, Secret1Idx);
        for (int i = SECRET1_START_ADDR; i &lt;= SECRET1_END_ADDR; i++) begin
          otp_a[i] = ((i - SECRET1_START_ADDR) % 2) ? data[SCRAMBLE_DATA_SIZE-1:TL_DW] :
                                                      data[TL_DW-1:0];
        end
        data = descramble_data(0, Secret2Idx);
        for (int i = SECRET2_START_ADDR; i &lt;= SECRET2_END_ADDR; i++) begin
          otp_a[i] = ((i - SECRET2_START_ADDR) % 2) ? data[SCRAMBLE_DATA_SIZE-1:TL_DW] :
                                                      data[TL_DW-1:0];
        end
        `uvm_info(`gfn, &quot;clear internal memory and digest&quot;, UVM_HIGH)
        cfg.backdoor_clear_mem = 0;
        dai_wr_ip = 0;
        dai_digest_ip = LifeCycleIdx;
      end
    end
  endtask

  // This task process the following logic in during otp_power_up:
  // 1. After reset deasserted, otp access is locked until pwr_otp_done_o is set
  // 2. After reset deasserted, if power otp_init request is on, and if testbench uses backdoor to
  //    clear OTP memory to all zeros, clear all digests and re-calculate secret partitions
  virtual task process_otp_power_up();
    if (cfg.en_scb) begin
      forever begin
        @(posedge cfg.otp_ctrl_vif.pwr_otp_done_o || cfg.under_reset ||
                  cfg.otp_ctrl_vif.alert_reqs) begin
          if (!cfg.under_reset &amp;&amp; !cfg.otp_ctrl_vif.alert_reqs) begin
            otp_ctrl_part_pkg::otp_hw_cfg_data_t exp_hwcfg_data;
            otp_ctrl_pkg::otp_keymgr_key_t       exp_keymgr_data;
            otp_ctrl_pkg::otp_lc_data_t          exp_lc_data;
            bit [otp_ctrl_pkg::KeyMgrKeyWidth-1:0] exp_keymgr_key0, exp_keymgr_key1;

            if (dai_digest_ip != LifeCycleIdx) begin
              bit [TL_DW-1:0] otp_addr = PART_OTP_DIGEST_ADDRS[dai_digest_ip];
              otp_a[otp_addr] = cfg.mem_bkdr_util_h.read32(otp_addr &lt;&lt; 2);
              otp_a[otp_addr+1] = cfg.mem_bkdr_util_h.read32((otp_addr &lt;&lt; 2) + 4);
              dai_digest_ip = LifeCycleIdx;
            end
            predict_digest_csrs();

            if (cfg.otp_ctrl_vif.under_error_states() == 0) begin
              // Dai access is unlocked because the power init is done
              void&#39;(ral.direct_access_regwen.predict(1));

              // Dai idle is set because the otp init is done
              exp_status[OtpDaiIdleIdx] = 1;
            end

            // Hwcfg_o gets data from OTP HW cfg partition
            exp_hwcfg_data = cfg.otp_ctrl_vif.under_error_states() ?
                             otp_ctrl_part_pkg::PartInvDefault[HwCfgOffset*8 +: HwCfgSize*8] :
                             otp_hw_cfg_data_t&#39;({&lt;&lt;32 {otp_a[HwCfgOffset/4 +: HwCfgSize/4]}});
            `DV_CHECK_EQ(cfg.otp_ctrl_vif.otp_hw_cfg_o.data, exp_hwcfg_data)

            if (!cfg.otp_ctrl_vif.under_error_states() &amp;&amp; cfg.en_scb) begin
              // ---------------------- Check lc_data_o output -----------------------------------
              // Because initialization was succesful, the valid should be set and error should be
              // reset.
              exp_lc_data.valid = 1;
              exp_lc_data.error = 0;

              // Secrets and tokens valid signals are depend on whether secret partitions are
              // locked.
              exp_lc_data.secrets_valid = get_otp_digest_val(Secret2Idx) ? On : Off;
              exp_lc_data.test_tokens_valid = get_otp_digest_val(Secret0Idx) ? On : Off;
              exp_lc_data.rma_token_valid = get_otp_digest_val(Secret2Idx) ? On : Off;

              // LC output is depend on LC partitions value.
              exp_lc_data.count = otp_lc_data[0+:LcCountWidth];
              exp_lc_data.state = otp_lc_data[LcCountWidth+:LcStateWidth];

              // Token values are depend on secret partitions value.
              exp_lc_data.test_unlock_token =
                      {&lt;&lt;32 {otp_a[TestUnlockTokenOffset/4 +: TestUnlockTokenSize/4]}};
              exp_lc_data.test_exit_token =
                      {&lt;&lt;32 {otp_a[TestExitTokenOffset/4 +: TestExitTokenSize/4]}};
              exp_lc_data.rma_token = {&lt;&lt;32{otp_a[RmaTokenOffset/4+:RmaTokenSize/4]}};

              // Check otp_lc_data_t struct by item is easier to debug.
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.lc_data_o.valid, exp_lc_data.valid)
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.lc_data_o.error, exp_lc_data.error)
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.lc_data_o.state, exp_lc_data.state)
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.lc_data_o.count, exp_lc_data.count)
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.lc_data_o.secrets_valid, exp_lc_data.secrets_valid)
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.lc_data_o.test_tokens_valid,
                           exp_lc_data.test_tokens_valid)
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.lc_data_o.test_unlock_token,
                           exp_lc_data.test_unlock_token)
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.lc_data_o.test_exit_token, exp_lc_data.test_exit_token)
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.lc_data_o.rma_token_valid, exp_lc_data.rma_token_valid)
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.lc_data_o.rma_token, exp_lc_data.rma_token)

              // Check otp_lc_data_t all together in case there is any missed item.
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.lc_data_o, exp_lc_data)

              // ---------------------- Check keymgr_key_o output ---------------------------------
              // Otp_keymgr outputs creator root key shares from the secret2 partition.
              // Depends on lc_seed_hw_rd_en_i, it will output the real keys or a constant
              exp_keymgr_data.valid = get_otp_digest_val(Secret2Idx) != 0;
              if (cfg.otp_ctrl_vif.lc_seed_hw_rd_en_i == lc_ctrl_pkg::On) begin
                exp_keymgr_data.key_share0 =
                    {&lt;&lt;32 {otp_a[CreatorRootKeyShare0Offset/4 +: CreatorRootKeyShare0Size/4]}};
                exp_keymgr_data.key_share1 =
                    {&lt;&lt;32 {otp_a[CreatorRootKeyShare1Offset/4 +: CreatorRootKeyShare1Size/4]}};
              end else begin
                exp_keymgr_data.key_share0 =
                    PartInvDefault[CreatorRootKeyShare0Offset*8 +: CreatorRootKeyShare0Size*8];
                exp_keymgr_data.key_share1 =
                    PartInvDefault[CreatorRootKeyShare1Offset*8 +: CreatorRootKeyShare1Size*8];
              end

              // Check otp_keymgr_key_t struct by item is easier to debug.
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.keymgr_key_o.valid, exp_keymgr_data.valid)
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.keymgr_key_o.key_share0, exp_keymgr_data.key_share0)
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.keymgr_key_o.key_share1, exp_keymgr_data.key_share1)

              // Check otp_keymgr_key_t struct all together in case there is any missed item.
              `DV_CHECK_EQ(cfg.otp_ctrl_vif.keymgr_key_o, exp_keymgr_data)

              if (cfg.en_cov) begin
                cov.keymgr_o_cg.sample(cfg.otp_ctrl_vif.lc_seed_hw_rd_en_i == lc_ctrl_pkg::On,
                                       exp_keymgr_data.valid);
              end
            end
          end else if (cfg.otp_ctrl_vif.alert_reqs) begin
            // Ignore digest CSR check when otp_ctrl initialization is interrupted by fatal errors.
            // SCB cannot predict how many partitions already finished initialization and updated
            // the digest value to CSRs.
            ignore_digest_chk = 1;
          end
          if (cfg.en_cov) begin
            bit [NumPart-2:0] parts_locked;
            foreach (parts_locked[i]) parts_locked[i] = (get_otp_digest_val(i) != 0);
            cov.power_on_cg.sample(cfg.otp_ctrl_vif.lc_esc_on, parts_locked);
          end
        end
      end
    end
  endtask

  // This task monitors internal escalation triggered by two methods:
  // 1. Externally lc_escalation_en is set to lc_ctrl_pkg::On.
  // 2. Internal fatal alert triggered and all partitions are driven to error states.
  virtual task process_lc_esc();
    forever begin
      wait(cfg.otp_ctrl_vif.alert_reqs == 1 &amp;&amp; cfg.en_scb);

      if (cfg.otp_ctrl_vif.lc_esc_on == 0) `DV_CHECK_NE(exp_alert, OtpNoAlert)

      if (exp_alert != OtpCheckAlert) set_exp_alert(&quot;fatal_check_error&quot;, 1, 5);

      // If the lc_escalation is triggered by internal fatal alert, wait 2 negedge until status is
      // updated internally
      if (cfg.otp_ctrl_vif.lc_esc_on == 0) begin
        cfg.clk_rst_vif.wait_n_clks(2);
        exp_status[OtpCheckPendingIdx] = 0;
        exp_status[OtpDaiIdleIdx] = 0;
      end else begin
        exp_status = &#39;0;
        // Only lc_esc_on will set these bits to 1.
        exp_status[OtpDerivKeyFsmErrIdx:OtpLfsrFsmErrIdx] = &#39;1;
      end

      // Update status bits.
      foreach (FATAL_EXP_STATUS[i]) begin
        if (FATAL_EXP_STATUS[i]) begin
          predict_err(.status_err_idx(otp_status_e&#39;(i)), .err_code(OtpFsmStateError),
                      .update_esc_err(1));
        end
      end

      // Update digest values and direct_access_regwen.
      predict_rdata(1, 0, 0);
      void&#39;(ral.direct_access_regwen.predict(.value(0), .kind(UVM_PREDICT_READ)));

      // DAI access is locked until reset, so no need to backdoor read otp write value until reset.

      wait(cfg.otp_ctrl_vif.alert_reqs == 0);
    end
  endtask

  // This task monitors if lc_program req is interrupted by reset.
  // If it happens, scb cannot predict how many bits have been written to OTP_CTRL.
  // So here we will backdoor read back OTP lc partitions bits.
  virtual task recover_lc_prog_req();
    forever begin
      wait(cfg.otp_ctrl_vif.lc_prog_req == 1);
      wait(cfg.otp_ctrl_vif.lc_prog_req == 0);
      // Wait one 1ps to avoid race condition.
      #1ps;
      if (cfg.otp_ctrl_vif.rst_ni == 0) begin
        for (int i = 0; i &lt; LC_PROG_DATA_SIZE / 32; i++) begin
          otp_lc_data[i*32+:32] = cfg.mem_bkdr_util_h.read32(LifeCycleOffset + i * 4);
        end
      end
    end
  endtask

  virtual task process_lc_prog_req();
    forever begin
      push_pull_item #(
        .DeviceDataWidth(1),
        .HostDataWidth  (LC_PROG_DATA_SIZE)
      ) rcv_item;
      bit exp_err_bit;
      bit [15:0] rcv_words[LC_PROG_DATA_SIZE/16];

      lc_prog_fifo.get(rcv_item);

      // LCI is updated by OTP word.
      rcv_words = {&lt;&lt;16{rcv_item.h_data}};
      foreach (rcv_words[i]) begin
        bit [15:0] curr_word = otp_lc_data[i*16+:16];
        if ((curr_word &amp; rcv_words[i]) == curr_word) otp_lc_data[i*16+:16] = rcv_words[i];
        else exp_err_bit = 1;
      end

      if (exp_err_bit) predict_err(OtpLciErrIdx, OtpMacroWriteBlankError);
      else predict_no_err(OtpLciErrIdx);

      // LC program request data is valid means no OTP macro error.
      `DV_CHECK_EQ(rcv_item.d_data, exp_err_bit)

      if (cfg.en_cov) cov.lc_prog_cg.sample(exp_err_bit);
    end
  endtask

  virtual task process_edn_req();
    forever begin
      push_pull_item #(.DeviceDataWidth(EDN_DATA_WIDTH)) edn_item;
      edn_fifo.get(edn_item);
      edn_data_q.push_back(edn_item.d_data[EDN_BUS_WIDTH-1:0]);
    end
  endtask

  virtual task check_otbn_rsp();
    forever begin
      push_pull_item #(.DeviceDataWidth(OTBN_DATA_SIZE)) rcv_item;
      bit [SCRAMBLE_KEY_SIZE-1:0] edn_key2, edn_key1;
      bit [SCRAMBLE_KEY_SIZE-1:0] sram_key;
      bit [SCRAMBLE_DATA_SIZE-1:0] exp_key_lower, exp_key_higher;
      bit [OtbnKeyWidth-1:0] key, exp_key;
      bit [OtbnNonceWidth-1:0] nonce, exp_nonce;
      bit seed_valid;
      bit part_locked;

      otbn_fifo.get(rcv_item);
      seed_valid  = rcv_item.d_data[0];
      nonce       = rcv_item.d_data[1+:OtbnNonceWidth];
      key         = rcv_item.d_data[OtbnNonceWidth+1+:OtbnKeyWidth];
      part_locked = {`gmv(ral.secret1_digest[0]), `gmv(ral.secret1_digest[1])} != &#39;0;

      // seed is valid as long as secret1 is locked
      `DV_CHECK_EQ(seed_valid, part_locked, &quot;otbn seed_valid mismatch&quot;)

      // If edn_data_q matches the OTBN requested size, check OTBN outputs
      if (edn_data_q.size() == NUM_OTBN_EDN_REQ) begin
        {exp_nonce, edn_key2, edn_key1} = {&lt;&lt;32{edn_data_q}};

        // check nonce value
        `DV_CHECK_EQ(nonce, exp_nonce, &quot;otbn nonce mismatch&quot;)

        // calculate key
        sram_key = get_key_from_otp(part_locked, SramDataKeySeedOffset / 4);
        exp_key_lower = present_encode_with_final_const(
            .data(RndCnstDigestIV[SramDataKey]),
            .key(sram_key),
            .final_const(RndCnstDigestConst[SramDataKey]),
            .second_key(edn_key1),
            .num_round(2)
        );

        exp_key_higher = present_encode_with_final_const(
            .data(RndCnstDigestIV[SramDataKey]),
            .key(sram_key),
            .final_const(RndCnstDigestConst[SramDataKey]),
            .second_key(edn_key2),
            .num_round(2)
        );
        exp_key = {exp_key_higher, exp_key_lower};
        `DV_CHECK_EQ(key, exp_key, &quot;otbn key mismatch&quot;)

        if (cfg.en_cov) cov.otbn_req_cg.sample(part_locked);

        // If during OTBN key request, the LFSR timer expired and trigger an EDN request to acquire
        // two EDN keys, then ignore the OTBN output checking, because scb did not know which EDN
        // keys are used for LFSR.
        // Thus any edn_data_q size equal to (16+2*N) is exempted from checking.
      end else if ((edn_data_q.size() - NUM_OTBN_EDN_REQ) % 2 != 0) begin
        `uvm_error(`gfn, $sformatf(
                   &quot;Unexpected edn_data_q size (%0d) during OTBN request&quot;, edn_data_q.size()))
      end
      edn_data_q.delete();
    end
  endtask

  virtual task check_flash_rsps();
    for (int i = FlashDataKey; i &lt;= FlashAddrKey; i++) begin
      automatic digest_sel_e sel_flash = i;
      fork
        forever begin
          push_pull_item #(.DeviceDataWidth(FLASH_DATA_SIZE)) rcv_item;
          bit [SCRAMBLE_KEY_SIZE-1:0] flash_key;
          bit [SCRAMBLE_DATA_SIZE-1:0] exp_key_lower, exp_key_higher;
          bit [FlashKeyWidth-1:0] key, exp_key;
          bit seed_valid, part_locked;
          int flash_key_index;

          if (sel_flash == FlashAddrKey) begin
            flash_addr_fifo.get(rcv_item);
            flash_key_index = FlashAddrKeySeedOffset / 4;
          end else begin
            flash_data_fifo.get(rcv_item);
            flash_key_index = FlashDataKeySeedOffset / 4;
          end
          seed_valid  = rcv_item.d_data[0];
          key         = rcv_item.d_data[1+:FlashKeyWidth];
          part_locked = {`gmv(ral.secret1_digest[0]), `gmv(ral.secret1_digest[1])} != &#39;0;
          `DV_CHECK_EQ(seed_valid, part_locked, $sformatf(
                       &quot;flash %0s seed_valid mismatch&quot;, sel_flash.name()))

          // calculate key
          flash_key = get_key_from_otp(part_locked, flash_key_index);
          exp_key_lower = present_encode_with_final_const(
              .data(RndCnstDigestIV[sel_flash]),
              .key(flash_key),
              .final_const(RndCnstDigestConst[sel_flash])
          );

          flash_key = get_key_from_otp(part_locked, flash_key_index + 4);
          exp_key_higher = present_encode_with_final_const(
              .data(RndCnstDigestIV[sel_flash]),
              .key(flash_key),
              .final_const(RndCnstDigestConst[sel_flash])
          );
          exp_key = {exp_key_higher, exp_key_lower};
          `DV_CHECK_EQ(key, exp_key, $sformatf(&quot;flash %s key mismatch&quot;, sel_flash.name()))

          if (cfg.en_cov) cov.flash_req_cg.sample(sel_flash, part_locked);
        end
      join_none
      ;
    end
  endtask

  virtual task check_sram_rsps();
    for (int i = 0; i &lt; NumSramKeyReqSlots; i++) begin
      automatic int index = i;
      fork
        forever begin
          push_pull_item #(.DeviceDataWidth(SRAM_DATA_SIZE)) rcv_item;
          sram_key_t key, exp_key;
          sram_nonce_t nonce, exp_nonce;
          bit seed_valid, part_locked;
          bit [SCRAMBLE_KEY_SIZE-1:0] edn_key2, edn_key1;
          bit [SCRAMBLE_KEY_SIZE-1:0] sram_key;  // key used as input to present algo
          bit [SCRAMBLE_DATA_SIZE-1:0] exp_key_lower, exp_key_higher;

          sram_fifos[index].get(rcv_item);
          seed_valid  = rcv_item.d_data[0];
          part_locked = {`gmv(ral.secret1_digest[0]), `gmv(ral.secret1_digest[1])} != &#39;0;

          // seed is valid as long as secret1 is locked
          `DV_CHECK_EQ(seed_valid, part_locked, $sformatf(&quot;sram_%0d seed_valid mismatch&quot;, index))

          // If edn_data_q matches the OTBN requested size, check OTBN outputs
          if (edn_data_q.size() == NUM_SRAM_EDN_REQ) begin
            {exp_nonce, edn_key2, edn_key1} = {&lt;&lt;32{edn_data_q}};

            // check nonce value
            `DV_CHECK_EQ(nonce, exp_nonce, $sformatf(&quot;sram_%0d nonce mismatch&quot;, index))

            // calculate key
            sram_key = get_key_from_otp(part_locked, SramDataKeySeedOffset / 4);
            exp_key_lower = present_encode_with_final_const(
                .data(RndCnstDigestIV[SramDataKey]),
                .key(sram_key),
                .final_const(RndCnstDigestConst[SramDataKey]),
                .second_key(edn_key1),
                .num_round(2)
            );

            exp_key_higher = present_encode_with_final_const(
                .data(RndCnstDigestIV[SramDataKey]),
                .key(sram_key),
                .final_const(RndCnstDigestConst[SramDataKey]),
                .second_key(edn_key2),
                .num_round(2)
            );
            exp_key = {exp_key_higher, exp_key_lower};
            `DV_CHECK_EQ(key, exp_key, $sformatf(&quot;sram_%0d key mismatch&quot;, index))
            if (cfg.en_cov) cov.sram_req_cg.sample(index, part_locked);

          end else if ((edn_data_q.size() - NUM_SRAM_EDN_REQ) % 2 != 0) begin
            `uvm_error(`gfn, $sformatf(
                       &quot;Unexpected edn_data_q size (%0d) during SRAM request&quot;, edn_data_q.size()))
          end
          edn_data_q.delete();
        end
      join_none
    end
  endtask

  virtual task process_tl_access(tl_seq_item item, tl_channels_e channel, string ral_name);
    uvm_reg                    csr;
    dv_base_reg                dv_reg;
    bit                        do_read_check = 1;
    bit                        write = item.is_write();
    uvm_reg_addr_t             csr_addr = ral.get_word_aligned_addr(item.a_addr);
    bit            [TL_AW-1:0] addr_mask = ral.get_addr_mask();

    bit                        addr_phase_read = (!write &amp;&amp; channel == AddrChannel);
    bit                        addr_phase_write = (write &amp;&amp; channel == AddrChannel);
    bit                        data_phase_read = (!write &amp;&amp; channel == DataChannel);
    bit                        data_phase_write = (write &amp;&amp; channel == DataChannel);

    // if access was to a valid csr, get the csr handle
    if (csr_addr inside {cfg.ral_models[ral_name].csr_addrs}) begin
      csr = ral.default_map.get_reg_by_offset(csr_addr);
      `DV_CHECK_NE_FATAL(csr, null)
      `downcast(dv_reg, csr)
      // SW CFG window
    end else if ((csr_addr &amp; addr_mask) inside
        {[SW_WINDOW_BASE_ADDR : SW_WINDOW_BASE_ADDR + SW_WINDOW_SIZE]}) begin
      if (data_phase_read) begin
        bit [TL_AW-1:0] otp_addr = (csr_addr &amp; addr_mask - SW_WINDOW_BASE_ADDR) &gt;&gt; 2;
        // TODO: macro ecc uncorrectable error once mem_bkdr_util supports
        //`DV_CHECK_EQ(item.d_data, 0,
        //             $sformatf(&quot;mem read mismatch at TLUL addr %0h, csr_addr %0h&quot;,
        //             csr_addr, otp_addr &lt;&lt; 2))
        `DV_CHECK_EQ(item.d_data, otp_a[otp_addr], $sformatf(
                     &quot;mem read mismatch at TLUL addr %0h, csr_addr %0h&quot;, csr_addr, otp_addr &lt;&lt; 2))
      end
      return;
      // TEST ACCESS window
    end else if ((csr_addr &amp; addr_mask) inside
         {[TEST_ACCESS_BASE_ADDR : TEST_ACCESS_BASE_ADDR + TEST_ACCESS_WINDOW_SIZE]}) begin
      return;
    end else begin
      `uvm_fatal(`gfn, $sformatf(&quot;Access unexpected addr 0x%0h&quot;, csr_addr))
    end

    if (addr_phase_write) begin
      if (cfg.en_cov &amp;&amp; cfg.otp_ctrl_vif.alert_reqs &amp;&amp; csr.get_name == &quot;direct_access_cmd&quot;) begin
        cov.req_dai_access_after_alert_cg.sample(item.a_data);
      end

      // Skip predict if the register is locked by `direct_access_regwen`.
      if (ral.direct_access_regwen.locks_reg_or_fld(dv_reg) &amp;&amp; `gmv(ral.direct_access_regwen) == 0)
        return;

      void&#39;(csr.predict(.value(item.a_data), .kind(UVM_PREDICT_WRITE), .be(item.a_mask)));
    end

    // process the csr req
    // for write, update local variable and fifo at address phase
    // for read, update predication at address phase and compare at data phase
    case (csr.get_name())
      // add individual case item for each csr
      &quot;intr_state&quot;: begin
        if (data_phase_read) begin
          // Disable intr_state checking when lc_program is in progress, because scb cannot
          // accurately predict when program_error will be triggered.
          // We will check the intr_state after lc_program request is done, and the error bit will
          // be checked in the `process_lc_prog_req` task.
          if (cfg.otp_ctrl_vif.lc_prog_no_sta_check) do_read_check = 0;
          if (do_read_check) begin
            bit [         TL_DW-1:0] intr_en = `gmv(ral.intr_enable);
            bit [NumOtpCtrlIntr-1:0] intr_exp = `gmv(ral.intr_state);

            foreach (intr_exp[i]) begin
              otp_intr_e intr = otp_intr_e&#39;(i);
              `DV_CHECK_CASE_EQ(cfg.intr_vif.pins[i], (intr_en[i] &amp; intr_exp[i]), $sformatf(
                                &quot;Interrupt_pin: %0s&quot;, intr.name));
              if (cfg.en_cov) begin
                cov.intr_cg.sample(i, intr_en[i], item.d_data[i]);
                cov.intr_pins_cg.sample(i, cfg.intr_vif.pins[i]);
              end
            end
          end
        end
      end
      &quot;intr_test&quot;: begin
        if (addr_phase_write) begin
          bit [TL_DW-1:0] intr_en = `gmv(ral.intr_enable);
          bit [NumOtpCtrlIntr-1:0] intr_exp = `gmv(ral.intr_state) | item.a_data;

          void&#39;(ral.intr_state.predict(.value(intr_exp)));
          if (cfg.en_cov) begin
            foreach (intr_exp[i]) begin
              cov.intr_test_cg.sample(i, item.a_data[i], intr_en[i], intr_exp[i]);
            end
          end
        end
      end
      &quot;direct_access_cmd&quot;: begin
        if (addr_phase_write &amp;&amp; !cfg.otp_ctrl_vif.under_error_states()) begin
          // here only normalize to 2 lsb, if is secret, will be reduced further
          bit [TL_AW-1:0] dai_addr = normalize_dai_addr(`gmv(ral.direct_access_address));
          int part_idx = get_part_index(dai_addr);
          void&#39;(ral.direct_access_regwen.predict(0));
          under_dai_access = 1;

          // LC partition cannot be access via DAI
          if (part_idx == LifeCycleIdx) begin
            predict_err(OtpDaiErrIdx, OtpAccessError);
            if (item.a_data == DaiRead) predict_rdata(is_secret(dai_addr), 0, 0);
          end else begin
            if (cfg.en_cov &amp;&amp; part_idx == Secret2Idx) begin
              cov.dai_access_secret2_cg.sample(
                  !(cfg.otp_ctrl_vif.lc_creator_seed_sw_rw_en_i == lc_ctrl_pkg::Off), item.a_data);
            end

            case (item.a_data)
              DaiDigest: cal_digest_val(part_idx);
              DaiRead: begin
                // Check if it is sw partition read lock
                bit sw_read_lock = 0;
                if (part_idx == CreatorSwCfgIdx) begin
                  sw_read_lock = `gmv(ral.creator_sw_cfg_read_lock) == 0;
                end else if (part_idx == OwnerSwCfgIdx) begin
                  sw_read_lock = `gmv(ral.owner_sw_cfg_read_lock) == 0;
                end

                // SW partitions write read_lock_csr can lock read access.
                if (sw_read_lock ||
                    // Secret partitions cal digest can also lock read access.
                    // However, digest is always readable except SW partitions (Issue #5752).
                    (is_secret(
                        dai_addr
                    ) &amp;&amp; get_digest_reg_val(
                        part_idx
                    ) != 0 &amp;&amp; !is_digest(
                        dai_addr
                    )) ||
                    // If the partition is secret2 and lc_creator_seed_sw_rw is disable, then
                    // return access error.
                    (part_idx == Secret2Idx &amp;&amp; !is_digest(
                        dai_addr
                    ) &amp;&amp; cfg.otp_ctrl_vif.lc_creator_seed_sw_rw_en_i == lc_ctrl_pkg::Off)) begin
                  predict_err(OtpDaiErrIdx, OtpAccessError);
                  predict_rdata(is_secret(dai_addr) || is_digest(dai_addr), 0, 0);
                  // DAI interface access error, even though injected ECC error, it won&#39;t be read
                  // out and detected. (TODO: can remove this once ECC is adopted in mem_bkdr_util)
                  cfg.ecc_err = OtpNoEccErr;

                end else begin
                  bit [TL_AW-1:0] otp_addr = get_scb_otp_addr();
                  // Check if write has any write_blank_error, then potentially read might have ECC
                  // error.
                  bit [TL_DW-1:0] err_code = `gmv(ral.err_code);
                  if (get_field_val(
                          ral.err_code.err_code_7, err_code
                      ) == OtpMacroWriteBlankError || cfg.ecc_err != OtpNoEccErr) begin
                    bit [TL_DW-1:0] read_out;
                    int ecc_err = read_a_word_with_ecc(dai_addr, read_out);
                    if (is_secret(dai_addr) || is_digest(dai_addr)) begin
                      ecc_err = max2(read_a_word_with_ecc(dai_addr + 4, read_out), ecc_err);
                    end

                    if (ecc_err == OtpEccCorrErr) begin
                      predict_err(OtpDaiErrIdx, OtpMacroEccCorrError);
                      backdoor_update_otp_array(dai_addr);
                      predict_rdata(is_secret(dai_addr) || is_digest(dai_addr), otp_a[otp_addr],
                                    otp_a[otp_addr+1]);
                    end else if (ecc_err == OtpEccUncorrErr) begin
                      predict_err(OtpDaiErrIdx, OtpMacroEccUncorrError);
                      // Max wait 20 clock cycles because scb did not know when exactly OTP will
                      // finish reading and reporting the uncorrectable error.
                      set_exp_alert(&quot;fatal_macro_error&quot;, 1, 20);
                      predict_rdata(1, 0, 0);
                    end else begin
                      predict_rdata(is_secret(dai_addr) || is_digest(dai_addr), otp_a[otp_addr],
                                    otp_a[otp_addr+1]);
                    end

                    // In sequence, we backdoor write back to non-error value, so here scb reset
                    // the ecc_err back to NoErr.
                    if (cfg.ecc_err == OtpEccCorrErr) cfg.ecc_err = OtpNoEccErr;
                  end else begin
                    predict_no_err(OtpDaiErrIdx);
                    predict_rdata(is_secret(dai_addr) || is_digest(dai_addr), otp_a[otp_addr],
                                  otp_a[otp_addr+1]);
                  end
                end
              end
              DaiWrite: begin
                bit [TL_AW-1:0] otp_addr = get_scb_otp_addr();
                // check if write locked
                if (get_digest_reg_val(
                        part_idx
                    ) != 0 || (part_idx == Secret2Idx &amp;&amp; !is_digest(
                        dai_addr
                    ) &amp;&amp; cfg.otp_ctrl_vif.lc_creator_seed_sw_rw_en_i == lc_ctrl_pkg::Off)) begin
                  predict_err(OtpDaiErrIdx, OtpAccessError);
                end else begin
                  predict_no_err(OtpDaiErrIdx);
                  // write digest
                  if (is_sw_digest(dai_addr)) begin
                    bit [TL_DW*2-1:0] curr_digest, prev_digest;
                    curr_digest = {
                      `gmv(ral.direct_access_wdata[1]), `gmv(ral.direct_access_wdata[0])
                    };
                    prev_digest = {otp_a[otp_addr+1], otp_a[otp_addr]};
                    dai_wr_ip = 1;
                    // allow bit write
                    if ((prev_digest &amp; curr_digest) == prev_digest) begin
                      update_digest_to_otp(part_idx, curr_digest);
                    end else begin
                      predict_err(OtpDaiErrIdx, OtpMacroWriteBlankError);
                    end
                  end else if (is_digest(dai_addr)) begin
                    predict_err(OtpDaiErrIdx, OtpAccessError);
                    // write OTP memory
                  end else begin
                    dai_wr_ip = 1;
                    if (!is_secret(dai_addr)) begin
                      bit [TL_DW-1:0] wr_data = `gmv(ral.direct_access_wdata[0]);
                      // allow bit write
                      if ((otp_a[otp_addr] &amp; wr_data) == otp_a[otp_addr]) begin
                        otp_a[otp_addr] = wr_data;
                        check_otp_idle(.val(0), .wait_clks(3));
                      end else begin
                        predict_err(OtpDaiErrIdx, OtpMacroWriteBlankError);
                      end
                    end else begin
                      bit [SCRAMBLE_DATA_SIZE-1:0] secret_data = {
                        otp_a[otp_addr+1], otp_a[otp_addr]
                      };
                      bit [SCRAMBLE_DATA_SIZE-1:0] wr_data = {
                        `gmv(ral.direct_access_wdata[1]), `gmv(ral.direct_access_wdata[0])
                      };
                      wr_data = scramble_data(wr_data, part_idx);
                      secret_data = scramble_data(secret_data, part_idx);
                      if ((secret_data &amp; wr_data) == secret_data) begin
                        otp_a[otp_addr]   = `gmv(ral.direct_access_wdata[0]);
                        otp_a[otp_addr+1] = `gmv(ral.direct_access_wdata[1]);
                        // wait until secret scrambling is done
                        check_otp_idle(.val(0), .wait_clks(34));
                      end else begin
                        predict_err(OtpDaiErrIdx, OtpMacroWriteBlankError);
                      end
                    end
                  end
                end
              end
              default: begin
                `uvm_fatal(`gfn, $sformatf(&quot;invalid cmd: %0d&quot;, item.a_data))
              end
            endcase
            // regwen is set to 0 only if the dai operation is successfully
            if (`gmv(ral.intr_state.otp_error) == 0) void&#39;(ral.direct_access_regwen.predict(0));
          end
        end
      end
      &quot;status&quot;: begin
        if (addr_phase_read) begin
          void&#39;(ral.status.predict(.value(exp_status), .kind(UVM_PREDICT_READ)));

          // update status mask
          status_mask = 0;
          // Mask out check_pending field - we do not know how long it takes to process checks.
          // Check failure can trigger all kinds of errors.
          if (under_chk) status_mask = &#39;1;

          // Mask out otp_dai access related field - we do not know how long it takes to finish
          // DAI access.
          if (under_dai_access) begin
            status_mask[OtpDaiIdleIdx] = 1;
            status_mask[OtpDaiErrIdx]  = 1;
          end

          // Mask out LCI error bit if lc_req is set.
          if (cfg.otp_ctrl_vif.lc_prog_no_sta_check) status_mask[OtpLciErrIdx] = 1;

        end else if (data_phase_read) begin
          if (cfg.en_cov) begin
            cov.collect_status_cov(item.d_data);
            if (cfg.otp_ctrl_vif.alert_reqs)
              cov.csr_rd_after_alert_cg_wrap.sample(csr.get_offset());
          end

          if (item.d_data[OtpDaiIdleIdx]) begin
            check_otp_idle(1);
            dai_wr_ip = 0;
            dai_digest_ip = LifeCycleIdx;
          end

          // STATUS register check with mask
          if (do_read_check) begin
            `DV_CHECK_EQ((csr.get_mirrored_value() | status_mask), (item.d_data | status_mask),
                         $sformatf(&quot;reg name: status, compare_mask %0h&quot;, status_mask))
          end

          // Check if OtpCheckPending is set correctly, then ignore checking until check is done
          if (under_chk) begin
            if (item.d_data[OtpCheckPendingIdx] == 0) begin
              exp_status[OtpCheckPendingIdx] = 0;
              under_chk = 0;
            end
          end

          if (under_dai_access &amp;&amp; !cfg.otp_ctrl_vif.under_error_states()) begin
            if (item.d_data[OtpDaiIdleIdx]) begin
              under_dai_access = 0;
              void&#39;(ral.direct_access_regwen.predict(1));
              void&#39;(ral.intr_state.otp_operation_done.predict(1));
            end
          end
        end
        // checked in this block above
        do_read_check = 0;
      end
      &quot;check_trigger&quot;: begin
        if (addr_phase_write &amp;&amp; cfg.en_cov &amp;&amp; cfg.otp_ctrl_vif.alert_reqs) begin
          cov.issue_checks_after_alert_cg.sample(item.a_data);
        end

        if (addr_phase_write &amp;&amp;
            `gmv(ral.check_trigger_regwen)
            &amp;&amp; item.a_data inside {[1 : 3]}) begin
          exp_status[OtpCheckPendingIdx] = 1;
          under_chk = 1;
          if (`gmv(ral.check_timeout) &gt; 0 &amp;&amp; `gmv(ral.check_timeout) &lt;= CHK_TIMEOUT_CYC) begin
            set_exp_alert(&quot;fatal_check_error&quot;, 1, `gmv(ral.check_timeout));
            predict_err(OtpTimeoutErrIdx);
          end else begin
            if (get_field_val(ral.check_trigger.consistency, item.a_data)) begin
              foreach (cfg.ecc_chk_err[i]) begin
                if (cfg.ecc_chk_err[i] == OtpEccCorrErr) predict_err(i, OtpMacroEccCorrError);
              end
            end
          end
        end
      end
      &quot;err_code&quot;: begin
        // If lc_prog in progress, err_code might update anytime in DUT. Ignore checking until req
        // is acknowledged.
        if (cfg.m_lc_prog_pull_agent_cfg.vif.req) do_read_check = 0;
        if (cfg.en_cov &amp;&amp; do_read_check) begin
          bit [TL_DW-1:0] dai_addr = `gmv(ral.direct_access_address) &gt;&gt; 2 &lt;&lt; 2;
          int part_idx = get_part_index(dai_addr);
          cov.collect_err_code_cov(item.d_data, part_idx);
        end
      end
      &quot;hw_cfg_digest_0&quot;, &quot;hw_cfg_digest_1&quot;, &quot;secret0_digest_0&quot;, &quot;secret0_digest_1&quot;,
      &quot;secret1_digest_0&quot;, &quot;secret1_digest_1&quot;, &quot;secret2_digest_0&quot;, &quot;secret2_digest_1&quot;,
      &quot;creator_sw_cfg_digest_0&quot;, &quot;creator_sw_cfg_digest_1&quot;, &quot;owner_sw_cfg_digest_0&quot;,
      &quot;owner_sw_cfg_digest_1&quot;: begin
        if (ignore_digest_chk) do_read_check = 0;
      end
      &quot;direct_access_regwen&quot;, &quot;direct_access_wdata_0&quot;, &quot;direct_access_wdata_1&quot;,
      &quot;direct_access_address&quot;, &quot;direct_access_rdata_0&quot;, &quot;direct_access_rdata_1&quot;,
      &quot;check_regwen&quot;, &quot;check_trigger_regwen&quot;, &quot;check_trigger&quot;, &quot;check_timeout&quot;, &quot;intr_enable&quot;,
      &quot;creator_sw_cfg_read_lock&quot;, &quot;owner_sw_cfg_read_lock&quot;, &quot;integrity_check_period&quot;,
      &quot;consistency_check_period&quot;, &quot;alert_test&quot;: begin
        // Do nothing
      end
      default: begin
        `uvm_fatal(`gfn, $sformatf(&quot;invalid csr: %0s&quot;, csr.get_full_name()))
      end
    endcase

    // On reads, if do_read_check, is set, then check mirrored_value against item.d_data
    if (data_phase_read) begin
      if (do_read_check) begin
        `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data, $sformatf(
                     &quot;reg name: %0s&quot;, csr.get_full_name()))
        if (cfg.en_cov &amp;&amp; cfg.otp_ctrl_vif.alert_reqs) begin
          cov.csr_rd_after_alert_cg_wrap.sample(csr.get_offset());
        end
      end
      void&#39;(csr.predict(.value(item.d_data), .kind(UVM_PREDICT_READ)));
    end
  endtask

  // If reset or lc_escalate_en is issued during otp program, this function will backdoor update
  // otp memory write value because scb did not know how many cells haven been written.
  // We won&#39;t update csr `direct_access_address` after fatal alert happened, so in this function
  // we can directly call method `get_scb_otp_addr` to get the interrupted dai address.
  virtual function void recover_interrupted_op();
    if (dai_wr_ip) begin
      bit [TL_DW-1:0] otp_addr = get_scb_otp_addr();
      bit [TL_DW-1:0] dai_addr = otp_addr &lt;&lt; 2;
      backdoor_update_otp_array(dai_addr);
      dai_wr_ip = 0;
    end
  endfunction

  virtual function void backdoor_update_otp_array(bit [TL_DW-1:0] dai_addr);
    bit [TL_DW-1:0] otp_addr = dai_addr &gt;&gt; 2;
    bit [TL_DW-1:0] readout_word, readout_word1;
    void&#39;(read_a_word_with_ecc(dai_addr, readout_word));
    void&#39;(read_a_word_with_ecc(dai_addr + 4, readout_word1));
    otp_a[otp_addr] = readout_word;

    if (is_digest(dai_addr)) begin
      otp_a[otp_addr+1] = readout_word1;
    end else if (is_secret(dai_addr)) begin
      int part_idx = get_part_index(dai_addr);
      bit [TL_DW*2-1:0] mem_rd_val, descrambled_val;
      mem_rd_val        = {readout_word1, readout_word};
      descrambled_val   = descramble_data(mem_rd_val, part_idx);
      otp_a[otp_addr+1] = descrambled_val[TL_DW*2-1:TL_DW];
      otp_a[otp_addr]   = descrambled_val[TL_DW-1:0];
    end
  endfunction

  virtual function bit [1:0] read_a_word_with_ecc(bit [TL_DW-1:0] dai_addr,
                                                  ref bit [TL_DW-1:0] readout_word);
    prim_secded_pkg::secded_28_22_t ecc_rd_data0 = cfg.mem_bkdr_util_h.ecc_read16(dai_addr);
    prim_secded_pkg::secded_28_22_t ecc_rd_data1 = cfg.mem_bkdr_util_h.ecc_read16(dai_addr + 2);
    readout_word[15:0]  = ecc_rd_data0.data;
    readout_word[31:16] = ecc_rd_data1.data;
    return max2(ecc_rd_data0.err, ecc_rd_data1.err);
  endfunction

  virtual function void reset(string kind = &quot;HARD&quot;);
    recover_interrupted_op();
    super.reset(kind);
    // flush fifos
    otbn_fifo.flush();
    flash_addr_fifo.flush();
    flash_data_fifo.flush();
    lc_prog_fifo.flush();
    for (int i = 0; i &lt; NumSramKeyReqSlots; i++) begin
      sram_fifos[i].flush();
    end

    under_chk         = 0;
    under_dai_access  = 0;
    ignore_digest_chk = 0;
    exp_status        = `gmv(ral.status);
    exp_alert         = OtpNoAlert;

    edn_data_q.delete();

    // Out of reset: lock dai access until power init is done
    if (cfg.en_scb) void&#39;(ral.direct_access_regwen.predict(0));
  endfunction

  virtual function void check_otp_idle(bit val, int wait_clks = 0);
    fork
      begin
        fork
          begin
            // use negedge to avoid race condition
            cfg.clk_rst_vif.wait_n_clks(wait_clks + 1);
            `uvm_error(`gfn, $sformatf(
                       &quot;pwr_otp_idle output is %0b while expect %0b within %0d cycles&quot;,
                       cfg.otp_ctrl_vif.pwr_otp_idle_o,
                       val,
                       wait_clks
                       ))
          end
          begin
            wait(cfg.under_reset || cfg.otp_ctrl_vif.pwr_otp_idle_o == val ||
            // Due to OTP access arbitration, any KDI request during DAI access might block
            // write secret until KDI request is completed. Since the KDI process time could
            // vary depends on the push-pull-agent, we are going to ignore the checking if
            // this scenario happens.
            cfg.m_otbn_pull_agent_cfg.vif.req ||
                 cfg.m_flash_data_pull_agent_cfg.vif.req ||
                 cfg.m_flash_addr_pull_agent_cfg.vif.req ||
                 cfg.m_sram_pull_agent_cfg[0].vif.req ||
                 cfg.m_sram_pull_agent_cfg[1].vif.req ||
                 cfg.m_lc_prog_pull_agent_cfg.vif.req ||
            // When lc_escalation is on, the DAI interface goes to ErrorSt, so ignore
            // otp_idle checking.
            cfg.otp_ctrl_vif.alert_reqs ||
            // Check timeout will keep doing background check, issue #5616
            exp_status[OtpTimeoutErrIdx]);
          end
        join_any
        disable fork;
      end
    join_none
  endfunction

  // predict digest registers
  virtual function void predict_digest_csrs();
    void&#39;(ral.creator_sw_cfg_digest[0].predict(
        .value(otp_a[PART_OTP_DIGEST_ADDRS[CreatorSwCfgIdx]]), .kind(UVM_PREDICT_DIRECT)
    ));
    void&#39;(ral.creator_sw_cfg_digest[1].predict(
        .value(otp_a[PART_OTP_DIGEST_ADDRS[CreatorSwCfgIdx]+1]), .kind(UVM_PREDICT_DIRECT)
    ));

    void&#39;(ral.owner_sw_cfg_digest[0].predict(
        .value(otp_a[PART_OTP_DIGEST_ADDRS[OwnerSwCfgIdx]]), .kind(UVM_PREDICT_DIRECT)
    ));
    void&#39;(ral.owner_sw_cfg_digest[1].predict(
        .value(otp_a[PART_OTP_DIGEST_ADDRS[OwnerSwCfgIdx]+1]), .kind(UVM_PREDICT_DIRECT)
    ));

    void&#39;(ral.hw_cfg_digest[0].predict(
        .value(cfg.otp_ctrl_vif.under_error_states() ? 0 : otp_a[PART_OTP_DIGEST_ADDRS[HwCfgIdx]]),
        .kind(UVM_PREDICT_DIRECT)
    ));
    void&#39;(ral.hw_cfg_digest[1].predict(
        .value(cfg.otp_ctrl_vif.under_error_states() ? 0 :
          otp_a[PART_OTP_DIGEST_ADDRS[HwCfgIdx] + 1]),
        .kind(UVM_PREDICT_DIRECT)
    ));

    void&#39;(ral.secret0_digest[0].predict(
        .value(cfg.otp_ctrl_vif.under_error_states() ? 0 :
          otp_a[PART_OTP_DIGEST_ADDRS[Secret0Idx]]),
        .kind(UVM_PREDICT_DIRECT)
    ));
    void&#39;(ral.secret0_digest[1].predict(
        .value(cfg.otp_ctrl_vif.under_error_states() ? 0 :
          otp_a[PART_OTP_DIGEST_ADDRS[Secret0Idx] + 1]),
        .kind(UVM_PREDICT_DIRECT)
    ));

    void&#39;(ral.secret1_digest[0].predict(
        .value(cfg.otp_ctrl_vif.under_error_states() ? 0 :
          otp_a[PART_OTP_DIGEST_ADDRS[Secret1Idx]]),
        .kind(UVM_PREDICT_DIRECT)
    ));
    void&#39;(ral.secret1_digest[1].predict(
        .value(cfg.otp_ctrl_vif.under_error_states() ? 0 :
          otp_a[PART_OTP_DIGEST_ADDRS[Secret1Idx] + 1]),
        .kind(UVM_PREDICT_DIRECT)
    ));

    void&#39;(ral.secret2_digest[0].predict(
        .value(cfg.otp_ctrl_vif.under_error_states() ? 0 :
          otp_a[PART_OTP_DIGEST_ADDRS[Secret2Idx]]),
        .kind(UVM_PREDICT_DIRECT)
    ));
    void&#39;(ral.secret2_digest[1].predict(
        .value(cfg.otp_ctrl_vif.under_error_states() ? 0 :
          otp_a[PART_OTP_DIGEST_ADDRS[Secret2Idx] + 1]),
        .kind(UVM_PREDICT_DIRECT)
    ));
  endfunction

  function void update_digest_to_otp(int part_idx, bit [TL_DW*2-1:0] digest);
    otp_a[PART_OTP_DIGEST_ADDRS[part_idx]]   = digest[31:0];
    otp_a[PART_OTP_DIGEST_ADDRS[part_idx]+1] = digest[63:32];
  endfunction

  function void check_phase(uvm_phase phase);
    super.check_phase(phase);
    // post test checks - ensure that all local fifos and queues are empty
  endfunction

  // Calculate digest value for each partition
  // According to the design spec, the calculation is based on 64-rounds of PRESENT cipher
  // The 64-bit data_in state is initialized with a silicon creator constant, and each 128 bit
  // chunk of partition data are fed in as keys
  // The last 64-round PRESENT calculation will use a global digest constant as key input
  function void cal_digest_val(int part_idx);
    bit [             TL_DW-1:0] mem_q      [$];
    int                          array_size;
    bit [SCRAMBLE_DATA_SIZE-1:0] digest;

    if (cfg.otp_ctrl_vif.under_error_states()) return;

    if (get_digest_reg_val(
            part_idx
        ) != 0 || part_idx inside {CreatorSwCfgIdx, OwnerSwCfgIdx, LifeCycleIdx}) begin
      predict_err(OtpDaiErrIdx, OtpAccessError);
      return;
    end else if (part_idx == Secret2Idx &amp;&amp;
                 cfg.otp_ctrl_vif.lc_creator_seed_sw_rw_en_i == lc_ctrl_pkg::Off) begin
      predict_err(OtpDaiErrIdx, OtpAccessError);
      return;
    end else begin
      predict_no_err(OtpDaiErrIdx);
      dai_digest_ip = part_idx;
    end
    case (part_idx)
      HwCfgIdx:   mem_q = otp_a[HW_CFG_START_ADDR:HW_CFG_END_ADDR];
      Secret0Idx: mem_q = otp_a[SECRET0_START_ADDR:SECRET0_END_ADDR];
      Secret1Idx: mem_q = otp_a[SECRET1_START_ADDR:SECRET1_END_ADDR];
      Secret2Idx: mem_q = otp_a[SECRET2_START_ADDR:SECRET2_END_ADDR];
      default: begin
        `uvm_fatal(`gfn, $sformatf(&quot;Access unexpected partition %0d&quot;, part_idx))
      end
    endcase

    array_size = mem_q.size();

    // for secret partitions, need to use otp scrambled value as data input
    if (part_idx inside {[Secret0Idx : Secret2Idx]}) begin
      bit [TL_DW-1:0] scrambled_mem_q[$];
      for (int i = 0; i &lt; array_size / 2; i++) begin
        bit [SCRAMBLE_DATA_SIZE-1:0] scrambled_data;
        scrambled_data = scramble_data({mem_q[i*2+1], mem_q[i*2]}, part_idx);
        scrambled_mem_q.push_back(scrambled_data[TL_DW-1:0]);
        scrambled_mem_q.push_back(scrambled_data[SCRAMBLE_DATA_SIZE-1:TL_DW]);
      end
      mem_q = scrambled_mem_q;
    end

    digest = otp_scrambler_pkg::cal_digest(part_idx, mem_q);
    update_digest_to_otp(part_idx, digest);
  endfunction


  // this function go through present encode algo two or three iterations:
  // first iteration with input key,
  // second iteration with second_key, this iteration only happens if num_round is 2
  // third iteration with a final constant as key
  // this is mainly used for unlock token hashing, key derivation
  virtual function bit [SCRAMBLE_DATA_SIZE-1:0] present_encode_with_final_const(
      bit [SCRAMBLE_DATA_SIZE-1:0] data, bit [SCRAMBLE_KEY_SIZE-1:0] key,
      bit [SCRAMBLE_KEY_SIZE-1:0] final_const, bit [SCRAMBLE_KEY_SIZE-1:0] second_key = &#39;0,
      int num_round = 1);
    bit [NUM_ROUND-1:0][SCRAMBLE_DATA_SIZE-1:0] enc_array;
    bit [SCRAMBLE_DATA_SIZE-1:0] intermediate_state;
    crypto_dpi_present_pkg::sv_dpi_present_encrypt(data, key, SCRAMBLE_KEY_SIZE == 80, enc_array);
    // XOR the previous state into the digest result according to the Davies-Meyer scheme.
    intermediate_state = data ^ enc_array[NUM_ROUND-1];

    if (num_round == 2) begin
      crypto_dpi_present_pkg::sv_dpi_present_encrypt(intermediate_state, second_key,
                                                     SCRAMBLE_KEY_SIZE == 80, enc_array);
      intermediate_state = intermediate_state ^ enc_array[NUM_ROUND-1];
    end else if (num_round &gt; 2) begin
      `uvm_fatal(`gfn, $sformatf(&quot;does not support num_round: %0d &gt; 2&quot;, num_round))
    end

    crypto_dpi_present_pkg::sv_dpi_present_encrypt(intermediate_state, final_const,
                                                   SCRAMBLE_KEY_SIZE == 80, enc_array);
    // XOR the previous state into the digest result according to the Davies-Meyer scheme.
    present_encode_with_final_const = enc_array[NUM_ROUND-1] ^ intermediate_state;
  endfunction

  // Get address for scoreboard&#39;s otp_a array from the `direct_access_address` CSR
  function bit [TL_DW-1:0] get_scb_otp_addr();
    bit [TL_DW-1:0] dai_addr = `gmv(ral.direct_access_address);
    get_scb_otp_addr = normalize_dai_addr(dai_addr) &gt;&gt; 2;
  endfunction

  // This function predict OTP error related registers: intr_state, status, and err_code
  virtual function void predict_err(otp_status_e status_err_idx,
                                    otp_err_code_e err_code = OtpNoError, bit update_esc_err = 0);
    if (cfg.otp_ctrl_vif.under_error_states() &amp;&amp; !update_esc_err) return;

    // Update intr_state
    void&#39;(ral.intr_state.otp_error.predict(.value(1), .kind(UVM_PREDICT_READ)));
    // Update status
    exp_status[status_err_idx] = 1;

    // Only first 8 status errors have corresponding err_code
    if (status_err_idx &lt;= OtpLciErrIdx) begin
      dv_base_reg_field err_code_flds[$];
      if (err_code == OtpNoError) begin
        `uvm_error(`gfn, $sformatf(&quot;please set status error: %0s error code&quot;, status_err_idx.name))
      end
      ral.err_code.get_dv_base_reg_fields(err_code_flds);

      if (`gmv(err_code_flds[status_err_idx]) inside {OTP_TERMINAL_ERRS}) begin
        `uvm_info(`gfn, &quot;terminal error cannot be updated&quot;, UVM_HIGH)
      end else if (status_err_idx == OtpLciErrIdx &amp;&amp;
          `gmv(err_code_flds[status_err_idx])
          != OtpNoError) begin
        `uvm_info(`gfn, &quot;For LC partition, all errors are terminal error!&quot;, UVM_HIGH)
      end else begin
        void&#39;(err_code_flds[status_err_idx].predict(.value(err_code), .kind(UVM_PREDICT_READ)));
      end
    end

  endfunction

  // TODO: consider combine it with function predict_err()
  virtual function void predict_no_err(otp_status_e status_err_idx);
    if (cfg.otp_ctrl_vif.under_error_states()) return;

    exp_status[status_err_idx] = 0;
    if (status_err_idx == OtpDaiErrIdx) exp_status[OtpDaiIdleIdx] = 1;

    if (status_err_idx &lt;= OtpLciErrIdx) begin
      dv_base_reg_field err_code_flds[$];
      ral.err_code.get_dv_base_reg_fields(err_code_flds);
      void&#39;(err_code_flds[status_err_idx].predict(OtpNoError));
    end
  endfunction

  virtual function void predict_rdata(bit is_64_bits, bit [TL_DW-1:0] rdata0,
                                      bit [TL_DW-1:0] rdata1 = 0);
    void&#39;(ral.direct_access_rdata[0].predict(.value(rdata0), .kind(UVM_PREDICT_READ)));
    if (is_64_bits) begin
      void&#39;(ral.direct_access_rdata[1].predict(.value(rdata1), .kind(UVM_PREDICT_READ)));
    end
  endfunction

  // this function retrieves keys (128 bits) from scb&#39;s otp_array with a starting address
  // if not locked, it will return 0
  // this is mainly used for scrambling key algo
  virtual function bit [SCRAMBLE_KEY_SIZE-1:0] get_key_from_otp(bit locked, int start_i);
    bit [SCRAMBLE_KEY_SIZE-1:0] key;
    if (!locked) return 0;
    for (int i = 0; i &lt; 4; i++) key |= otp_a[i+start_i] &lt;&lt; (TL_DW * i);
    return key;
  endfunction

  // The following two methods are all retrieving digest val.
  // get_otp_digest_val: is the digest value from OTP memory
  // get_digest_reg_val: is the digest value in register. This value is identical to OTP
  // memory&#39;s digest value after a power cycle reset.
  virtual function bit [TL_DW*2-1:0] get_otp_digest_val(int part_idx);
    get_otp_digest_val[31:0]  = otp_a[PART_OTP_DIGEST_ADDRS[part_idx]];
    get_otp_digest_val[63:32] = otp_a[PART_OTP_DIGEST_ADDRS[part_idx]+1];
  endfunction

  virtual function bit [TL_DW*2-1:0] get_digest_reg_val(int part_idx);
    bit [TL_DW*2-1:0] digest;
    case (part_idx)
      CreatorSwCfgIdx: begin
        digest = {`gmv(ral.creator_sw_cfg_digest[1]), `gmv(ral.creator_sw_cfg_digest[0])};
      end
      OwnerSwCfgIdx: digest = {`gmv(ral.owner_sw_cfg_digest[1]), `gmv(ral.owner_sw_cfg_digest[0])};
      HwCfgIdx: digest = {`gmv(ral.hw_cfg_digest[1]), `gmv(ral.hw_cfg_digest[0])};
      Secret0Idx: digest = {`gmv(ral.secret0_digest[1]), `gmv(ral.secret0_digest[0])};
      Secret1Idx: digest = {`gmv(ral.secret1_digest[1]), `gmv(ral.secret1_digest[0])};
      Secret2Idx: digest = {`gmv(ral.secret2_digest[1]), `gmv(ral.secret2_digest[0])};
      default: `uvm_fatal(`gfn, $sformatf(&quot;Partition %0d does not have digest&quot;, part_idx))
    endcase
    return digest;
  endfunction

  virtual function bit is_tl_mem_access_allowed(input tl_seq_item item, input string ral_name,
                                                output bit mem_byte_access_err,
                                                output bit mem_wo_err, output bit mem_ro_err);
    // If sw partition is read locked, then access policy changes from RO to no access
    uvm_reg_addr_t addr = ral.get_word_aligned_addr(item.a_addr);
    if (`gmv(ral.creator_sw_cfg_read_lock) == 0 || cfg.otp_ctrl_vif.under_error_states()) begin
      if (addr inside {[cfg.ral_models[ral_name].mem_ranges[0].start_addr :
          cfg.ral_models[ral_name].mem_ranges[0].start_addr + CreatorSwCfgSize - 1]}) begin
        predict_err(OtpCreatorSwCfgErrIdx, OtpAccessError);
        `DV_CHECK_EQ(item.d_data, 0, $sformatf(
                     &quot;locked mem read mismatch at TLUL addr %0h in CreatorSwCfg&quot;, addr))
        return 0;
      end
    end
    if (`gmv(ral.owner_sw_cfg_read_lock) == 0 || cfg.otp_ctrl_vif.under_error_states()) begin
      if (addr inside {[cfg.ral_models[ral_name].mem_ranges[0].start_addr + OwnerSwCfgOffset :
                        cfg.ral_models[ral_name].mem_ranges[0].start_addr +
                            OwnerSwCfgSize + OwnerSwCfgOffset - 1]}) begin
        predict_err(OtpOwnerSwCfgErrIdx, OtpAccessError);
        `DV_CHECK_EQ(item.d_data, 0, $sformatf(
                     &quot;locked mem read mismatch at TLUL addr %0h in OwnerSwCfg&quot;, addr))
        return 0;
      end
    end
    return super.is_tl_mem_access_allowed(
        item, ral_name, mem_byte_access_err, mem_wo_err, mem_ro_err
    );
  endfunction

  virtual function void set_exp_alert(string alert_name, bit is_fatal = 0, int max_delay = 0);
    exp_alert = alert_name == &quot;fatal_check_error&quot; ? OtpCheckAlert : OtpMacroAlert;
    super.set_exp_alert(alert_name, is_fatal, max_delay);
  endfunction

endclass
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-otp-ctrl-dv-env-otp-ctrl-if-sv">
<span id="error-hw-ip-otp-ctrl-dv-env-otp-ctrl-if-sv"></span><h2>hw/ip/otp_ctrl/dv/env/otp_ctrl_if.sv<a class="headerlink" href="#hw-ip-otp-ctrl-dv-env-otp-ctrl-if-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>F20210805 12:57:39.215369  2940 token_partition_tree.cc:61] Check failed: parent_begin == children_begin (663 vs. 664) node:
{ (&gt;&gt;&gt;&gt;&gt;&gt;[&lt;auto&gt;], policy: fit-else-expand) @{12,1,52,1,1,1,0,1,0}
  { (&gt;&gt;&gt;&gt;&gt;&gt;[`BUF_PART_OTP_CMD_PATH (], policy: fit-else-expand) }
  { (&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;[2 )], policy: fit-else-expand, (origin: &quot;2&quot;)) }
}
*** Check failure stack trace: ***
    @     0x56423796568e  google::LogMessage::SendToLog()
    @     0x564237963ad6  google::LogMessage::Flush()
    @     0x564237965b79  google::LogMessageFatal::~LogMessageFatal()
    @     0x5642378ff581  verible::VerifyTreeNodeFormatTokenRanges()
    @     0x5642378fc88d  verible::VectorTree&lt;&gt;::ApplyPreOrder()
    @     0x5642378ff940  verible::VerifyFullTreeFormatTokenRanges()
    @     0x5642378f90ef  verible::TreeUnwrapper::Unwrap()
    @     0x5642378d0b4f  verilog::formatter::Formatter::Format()
    @     0x5642378d2a95  verilog::formatter::FormatVerilog()
    @     0x5642378bbede  main
    @     0x7fbe24a9cebb  __libc_start_main
    @     0x5642378c166a  _start
    @              (nil)  (unknown)
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-lc-ctrl-dv-tb-sv">
<span id="error-hw-ip-lc-ctrl-dv-tb-sv"></span><h2>hw/ip/lc_ctrl/dv/tb.sv<a class="headerlink" href="#hw-ip-lc-ctrl-dv-tb-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/lc_ctrl/dv/tb.sv: Error lex/parsing-ing formatted output.  Please file a bug.
First error: token: &quot;uvm_config_db&quot; at 179:5-17; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
module tb;
  // dep packages
  import uvm_pkg::*;
  import dv_utils_pkg::*;
  import lc_ctrl_env_pkg::*;
  import lc_ctrl_test_pkg::*;
  import otp_ctrl_pkg::*;
  import jtag_riscv_agent_pkg::*;

  // macro includes
  `include &quot;uvm_macros.svh&quot;
  `include &quot;dv_macros.svh&quot;

  wire clk, rst_n;
  wire devmode;
  wire [LcPwrIfWidth-1:0] pwr_lc;

  // TODO: need to connect this properly
  wire [OtpTestCtrlWidth-1:0] otp_test_ctrl;

  // interfaces
  clk_rst_if clk_rst_if (
    .clk  (clk),
    .rst_n(rst_n)
  );
  pins_if #(1) devmode_if (devmode);
  pins_if #(LcPwrIfWidth) pwr_lc_if (pwr_lc);
  tl_if tl_if (
    .clk  (clk),
    .rst_n(rst_n)
  );
  lc_ctrl_if lc_ctrl_if (
    .clk  (clk),
    .rst_n(rst_n)
  );
  alert_esc_if esc_scrap_state1_if (
    .clk  (clk),
    .rst_n(rst_n)
  );
  alert_esc_if esc_scrap_state0_if (
    .clk  (clk),
    .rst_n(rst_n)
  );
  jtag_if jtag_if ();
  push_pull_if #(
    .HostDataWidth  (OTP_PROG_HDATA_WIDTH),
    .DeviceDataWidth(OTP_PROG_DDATA_WIDTH)
  ) otp_prog_if (
    .clk  (clk),
    .rst_n(rst_n)
  );
  push_pull_if #(
    .HostDataWidth(lc_ctrl_state_pkg::LcTokenWidth)
  ) otp_token_if (
    .clk  (clk),
    .rst_n(rst_n)
  );

  // TODO: need to properly hook up KMAC agent.
  logic req_q;
  lc_ctrl_state_pkg::lc_token_t token_q;
  kmac_pkg::app_rsp_t kmac_data_in;
  kmac_pkg::app_req_t kmac_data_out;
  assign kmac_data_in.ready = 1&#39;b1;
  assign kmac_data_in.done = otp_token_if.ack;
  assign kmac_data_in.digest_share0 = kmac_pkg::AppDigestW&#39;(otp_token_if.d_data);
  assign kmac_data_in.digest_share1 = &#39;0;
  assign kmac_data_in.error = 1&#39;b0;

  assign otp_token_if.req = req_q;
  assign otp_token_if.h_data = token_q;

  always_ff @(posedge clk or negedge rst_n) begin : p_kmac_regs
    if (!rst_n) begin
      req_q   &lt;= 1&#39;b0;
      token_q &lt;= &#39;0;
    end else begin
      req_q &lt;= req_q &amp; ~otp_token_if.ack;
      if (kmac_data_out.valid) begin
        if (kmac_data_out.last) begin
          req_q &lt;= 1&#39;b1;
          token_q[64+:64] &lt;= kmac_data_out.data;
        end else begin
          token_q[0+:64] &lt;= kmac_data_out.data;
        end
      end
    end
  end


  `DV_ALERT_IF_CONNECT

  // dut
  lc_ctrl dut (
    .clk_i (clk),
    .rst_ni(rst_n),

    // TODO: connect this to a different clock
    .clk_kmac_i (clk),
    .rst_kmac_ni(rst_n),

    .tl_i      (tl_if.h2d),
    .tl_o      (tl_if.d2h),
    .alert_rx_i(alert_rx),
    .alert_tx_o(alert_tx),

    .jtag_i    ({jtag_if.tck, jtag_if.tms, jtag_if.trst_n, jtag_if.tdi}),
    .jtag_o    ({jtag_if.tdo, lc_ctrl_if.tdo_oe}),
    .scanmode_i(1&#39;b0),

    .esc_scrap_state0_tx_i(esc_scrap_state0_if.esc_tx),
    .esc_scrap_state0_rx_o(esc_scrap_state0_if.esc_rx),
    .esc_scrap_state1_tx_i(esc_scrap_state1_if.esc_tx),
    .esc_scrap_state1_rx_o(esc_scrap_state1_if.esc_rx),

    .pwr_lc_i(pwr_lc[LcPwrInitReq]),
    .pwr_lc_o(pwr_lc[LcPwrDoneRsp:LcPwrIdleRsp]),

    .lc_otp_program_o({otp_prog_if.req, otp_prog_if.h_data, otp_test_ctrl}),
    .lc_otp_program_i({otp_prog_if.d_data, otp_prog_if.ack}),

    .kmac_data_i(kmac_data_in),
    .kmac_data_o(kmac_data_out),

    .otp_lc_data_i(lc_ctrl_if.otp_i),

    .lc_dft_en_o               (lc_ctrl_if.lc_dft_en_o),
    .lc_nvm_debug_en_o         (lc_ctrl_if.lc_nvm_debug_en_o),
    .lc_hw_debug_en_o          (lc_ctrl_if.lc_hw_debug_en_o),
    .lc_cpu_en_o               (lc_ctrl_if.lc_cpu_en_o),
    .lc_creator_seed_sw_rw_en_o(lc_ctrl_if.lc_creator_seed_sw_rw_en_o),
    .lc_owner_seed_sw_rw_en_o  (lc_ctrl_if.lc_owner_seed_sw_rw_en_o),
    .lc_iso_part_sw_rd_en_o    (lc_ctrl_if.lc_iso_part_sw_rd_en_o),
    .lc_iso_part_sw_wr_en_o    (lc_ctrl_if.lc_iso_part_sw_wr_en_o),
    .lc_seed_hw_rd_en_o        (lc_ctrl_if.lc_seed_hw_rd_en_o),
    .lc_keymgr_en_o            (lc_ctrl_if.lc_keymgr_en_o),
    .lc_escalate_en_o          (lc_ctrl_if.lc_escalate_en_o),
    .lc_check_byp_en_o         (lc_ctrl_if.lc_check_byp_en_o),

    .lc_clk_byp_req_o(lc_ctrl_if.clk_byp_req_o),
    .lc_clk_byp_ack_i(lc_ctrl_if.clk_byp_ack_i),

    .lc_flash_rma_seed_o(lc_ctrl_if.flash_rma_seed_o),
    .lc_flash_rma_req_o (lc_ctrl_if.flash_rma_req_o),
    .lc_flash_rma_ack_i (lc_ctrl_if.flash_rma_ack_i),

    .lc_keymgr_div_o(lc_ctrl_if.keymgr_div_o),

    .otp_device_id_i(lc_ctrl_if.otp_device_id_i),

    .otp_manuf_state_i(lc_ctrl_if.otp_manuf_state_i)
  );

  initial begin
    // drive clk and rst_n from clk_if
    clk_rst_if.set_active();
    uvm_config_db#(virtual clk_rst_if)::set(null, &quot;*.env&quot;, &quot;clk_rst_vif&quot;, clk_rst_if);
    uvm_config_db#(devmode_vif)::set(null, &quot;*.env&quot;, &quot;devmode_vif&quot;, devmode_if);
    uvm_config_db#(virtual tl_if)::set(null, &quot;*.env.m_tl_agent*&quot;, &quot;vif&quot;, tl_if);
    uvm_config_db#(pwr_lc_vif)::set(null, &quot;*.env&quot;, &quot;pwr_lc_vif&quot;, pwr_lc_if);
    uvm_config_db#(virtual lc_ctrl_if)::set(null, &quot;*.env&quot;, &quot;lc_ctrl_vif&quot;, lc_ctrl_if);

    // The jtag_agent is a low_level agent that configured inside jtag_riscv_agent.
    uvm_config_db#(virtual jtag_if)::set(null, &quot;*.env.m_jtag_riscv_agent.m_jtag_agent*&quot;, &quot;vif&quot;,
                                         jtag_if);

    uvm_config_db#(virtual alert_esc_if)::set(null, &quot;*env.m_esc_scrap_state1_agent*&quot;, &quot;vif&quot;,
                                              esc_scrap_state1_if);
    uvm_config_db#(virtual alert_esc_if)::set(null, &quot;*env.m_esc_scrap_state0_agent*&quot;, &quot;vif&quot;,
                                              esc_scrap_state0_if);

    uvm_config_db#(virtual push_pull_if #(.HostDataWidth(OTP_PROG_HDATA_WIDTH),
                                          .DeviceDataWidth(OTP_PROG_DDATA_WIDTH)

    uvm_config_db#(virtual push_pull_if #(.HostDataWidth(lc_ctrl_state_pkg::LcTokenWidth)))::set(
                                          null,
                                          &quot;*env.m_otp_token_pull_agent*&quot;,
                                          &quot;vif&quot;,
                                          otp_token_if);
    $timeformat(-12, 0, &quot; ps&quot;, 12);
    run_test();
  end

endmodule
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-lc-ctrl-dv-env-lc-ctrl-scoreboard-sv">
<span id="error-hw-ip-lc-ctrl-dv-env-lc-ctrl-scoreboard-sv"></span><h2>hw/ip/lc_ctrl/dv/env/lc_ctrl_scoreboard.sv<a class="headerlink" href="#hw-ip-lc-ctrl-dv-env-lc-ctrl-scoreboard-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/lc_ctrl/dv/env/lc_ctrl_scoreboard.sv: Formatted output is lexically different from the input.    Please file a bug.  Details:
Mismatched token enums.  got: (&#39;)&#39;) (#41: &quot;)&quot;) vs. (MacroCallCloseToEndLine) (#746: &quot;)&quot;)
First mismatched token [19]: (&#39;)&#39;) (#41: &quot;)&quot;) vs. (MacroCallCloseToEndLine) (#746: &quot;)&quot;)
First mismatched token [450]: (MacroArg) (#745: &quot;{`gmv(ral.transition_token[3]),
                                       `gmv(ral.transition_token[2]),
                                       `gmv(ral.transition_token[1]),
                                       `gmv(ral.transition_token[0])}&quot;) vs. (MacroArg) (#745: &quot;{
                     `gmv(ral.transition_token[3]),
                     `gmv(ral.transition_token[2]),
                     `gmv(ral.transition_token[1]),
                     `gmv(ral.transition_token[0])
                     }&quot;)
; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class lc_ctrl_scoreboard extends cip_base_scoreboard #(
  .CFG_T(lc_ctrl_env_cfg),
  .RAL_T(lc_ctrl_reg_block),
  .COV_T(lc_ctrl_env_cov)
);
  `uvm_component_utils(lc_ctrl_scoreboard)

  // local variables
  bit is_personalized = 0;

  // TLM agent fifos
  uvm_tlm_analysis_fifo #(push_pull_item #(
    .HostDataWidth  (OTP_PROG_HDATA_WIDTH),
    .DeviceDataWidth(OTP_PROG_DDATA_WIDTH)
  )) otp_prog_fifo;
  uvm_tlm_analysis_fifo #(push_pull_item #(
    .HostDataWidth(lc_ctrl_state_pkg::LcTokenWidth)
  )) otp_token_fifo;
  uvm_tlm_analysis_fifo #(alert_esc_seq_item) esc_wipe_secrets_fifo;
  uvm_tlm_analysis_fifo #(alert_esc_seq_item) esc_scrap_state_fifo;

  // local queues to hold incoming packets pending comparison

  `uvm_component_new

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    otp_prog_fifo = new(&quot;otp_prog_fifo&quot;, this);
    otp_token_fifo = new(&quot;otp_token_fifo&quot;, this);
    esc_wipe_secrets_fifo = new(&quot;esc_wipe_secrets_fifo&quot;, this);
    esc_scrap_state_fifo = new(&quot;esc_scrap_state_fifo&quot;, this);
  endfunction

  function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
  endfunction

  task run_phase(uvm_phase phase);
    super.run_phase(phase);
    fork
      check_lc_output();
      process_otp_prog_rsp();
      process_otp_token_rsp();
    join_none
  endtask

  virtual task check_lc_output();
    forever begin
      @(posedge cfg.pwr_lc_vif.pins[LcPwrDoneRsp] &amp;&amp; cfg.en_scb) begin
        // TODO: add coverage
        dec_lc_state_e lc_state = dec_lc_state(cfg.lc_ctrl_vif.otp_i.state);
        lc_outputs_t   exp_lc_o = EXP_LC_OUTPUTS[int&#39;(lc_state)];
        string         err_msg = $sformatf(&quot;LC_St %0s&quot;, lc_state.name);
        cfg.clk_rst_vif.wait_n_clks(1);

        // lc_creator_seed_sw_rw_en_o is ON only when device has NOT been personalized or RMA state
        if (is_personalized &amp;&amp; lc_state != DecLcStRma) begin
          exp_lc_o.lc_creator_seed_sw_rw_en_o = lc_ctrl_pkg::Off;
        end
        // lc_seed_hw_rd_en_o is ON only when device has been personalized or RMA state
        if (!is_personalized &amp;&amp; lc_state != DecLcStRma) begin
          exp_lc_o.lc_seed_hw_rd_en_o = lc_ctrl_pkg::Off;
        end

        check_lc_outputs(exp_lc_o, err_msg);

        // predict LC state and cnt csr
        void&#39;(ral.lc_state.predict(lc_state));
        void&#39;(ral.lc_transition_cnt.predict(dec_lc_cnt(cfg.lc_ctrl_vif.otp_i.count)));
      end
    end
  endtask

  virtual task process_otp_prog_rsp();
    forever begin
      push_pull_item #(
        .HostDataWidth  (OTP_PROG_HDATA_WIDTH),
        .DeviceDataWidth(OTP_PROG_DDATA_WIDTH)
      ) item_rcv;
      otp_prog_fifo.get(item_rcv);
      if (item_rcv.d_data == 1 &amp;&amp; cfg.en_scb) begin
        set_exp_alert(.alert_name(&quot;fatal_prog_error&quot;), .is_fatal(1));
      end
    end
  endtask

  virtual task process_otp_token_rsp();
    forever begin
      push_pull_item #(.HostDataWidth(lc_ctrl_state_pkg::LcTokenWidth)) item_rcv;
      otp_token_fifo.get(item_rcv);
      if (cfg.en_scb) begin
        `DV_CHECK_EQ(item_rcv.h_data, {
                     `gmv(ral.transition_token[3]),
                     `gmv(ral.transition_token[2]),
                     `gmv(ral.transition_token[1]),
                     `gmv(ral.transition_token[0])
                     })
      end
    end
  endtask

  // check lc outputs, default all off
  virtual function void check_lc_outputs(lc_outputs_t exp_o = &#39;{default: lc_ctrl_pkg::Off},
                                         string msg = &quot;expect all output OFF&quot;);
    `DV_CHECK_EQ(cfg.lc_ctrl_vif.lc_dft_en_o, exp_o.lc_dft_en_o, msg)
    `DV_CHECK_EQ(cfg.lc_ctrl_vif.lc_nvm_debug_en_o, exp_o.lc_nvm_debug_en_o, msg)
    `DV_CHECK_EQ(cfg.lc_ctrl_vif.lc_hw_debug_en_o, exp_o.lc_hw_debug_en_o, msg)
    `DV_CHECK_EQ(cfg.lc_ctrl_vif.lc_cpu_en_o, exp_o.lc_cpu_en_o, msg)
    `DV_CHECK_EQ(cfg.lc_ctrl_vif.lc_keymgr_en_o, exp_o.lc_keymgr_en_o, msg)
    `DV_CHECK_EQ(cfg.lc_ctrl_vif.lc_escalate_en_o, exp_o.lc_escalate_en_o, msg)
    `DV_CHECK_EQ(cfg.lc_ctrl_vif.lc_owner_seed_sw_rw_en_o, exp_o.lc_owner_seed_sw_rw_en_o, msg)
    `DV_CHECK_EQ(cfg.lc_ctrl_vif.lc_iso_part_sw_rd_en_o, exp_o.lc_iso_part_sw_rd_en_o, msg)
    `DV_CHECK_EQ(cfg.lc_ctrl_vif.lc_iso_part_sw_wr_en_o, exp_o.lc_iso_part_sw_wr_en_o, msg)
    `DV_CHECK_EQ(cfg.lc_ctrl_vif.lc_seed_hw_rd_en_o, exp_o.lc_seed_hw_rd_en_o, msg)
    `DV_CHECK_EQ(cfg.lc_ctrl_vif.lc_creator_seed_sw_rw_en_o, exp_o.lc_creator_seed_sw_rw_en_o, msg)
  endfunction

  virtual task process_tl_access(tl_seq_item item, tl_channels_e channel, string ral_name);
    uvm_reg        csr;
    bit            do_read_check = 1&#39;b0;
    bit            write = item.is_write();
    uvm_reg_addr_t csr_addr = ral.get_word_aligned_addr(item.a_addr);
    lc_outputs_t   exp = &#39;{default: lc_ctrl_pkg::Off};

    bit            addr_phase_read = (!write &amp;&amp; channel == AddrChannel);
    bit            addr_phase_write = (write &amp;&amp; channel == AddrChannel);
    bit            data_phase_read = (!write &amp;&amp; channel == DataChannel);
    bit            data_phase_write = (write &amp;&amp; channel == DataChannel);

    // if access was to a valid csr, get the csr handle
    if (csr_addr inside {cfg.ral_models[ral_name].csr_addrs}) begin
      csr = ral.default_map.get_reg_by_offset(csr_addr);
      `DV_CHECK_NE_FATAL(csr, null)
    end else begin
      `uvm_fatal(`gfn, $sformatf(&quot;Access unexpected addr 0x%0h&quot;, csr_addr))
    end

    // if incoming access is a write to a valid csr, then make updates right away
    if (addr_phase_write) begin
      void&#39;(csr.predict(.value(item.a_data), .kind(UVM_PREDICT_WRITE), .be(item.a_mask)));
    end

    // process the csr req
    // for write, update local variable and fifo at address phase
    // for read, update predication at address phase and compare at data phase
    case (csr.get_name())
      // TODO: temp enable read checking, once do_read_check default set to 1, should not need this.
      &quot;lc_transition_cnt&quot;, &quot;lc_state&quot;: do_read_check = 1;
      &quot;status&quot;: begin
        if (data_phase_read) begin
          // when lc successfully req a transition, all outputs are turned off.
          if (item.d_data[ral.status.transition_successful.get_lsb_pos()]) check_lc_outputs(exp);
        end
      end
      default: begin
        // `uvm_fatal(`gfn, $sformatf(&quot;invalid csr: %0s&quot;, csr.get_full_name()))
      end
    endcase

    // On reads, if do_read_check, is set, then check mirrored_value against item.d_data
    if (data_phase_read) begin
      if (do_read_check) begin
        `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data, $sformatf(
                     &quot;reg name: %0s&quot;, csr.get_full_name()))
      end
      void&#39;(csr.predict(.value(item.d_data), .kind(UVM_PREDICT_READ)));
    end
  endtask

  virtual function void reset(string kind = &quot;HARD&quot;);
    super.reset(kind);
    // reset local fifos queues and variables
  endfunction

  function void check_phase(uvm_phase phase);
    super.check_phase(phase);
    // post test checks - ensure that all local fifos and queues are empty
  endfunction

endclass
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-lc-ctrl-dv-env-lc-ctrl-env-sv">
<span id="error-hw-ip-lc-ctrl-dv-env-lc-ctrl-env-sv"></span><h2>hw/ip/lc_ctrl/dv/env/lc_ctrl_env.sv<a class="headerlink" href="#hw-ip-lc-ctrl-dv-env-lc-ctrl-env-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/lc_ctrl/dv/env/lc_ctrl_env.sv: Error lex/parsing-ing formatted output.  Please file a bug.
First error: token: &quot;cfg&quot; at 59:5-7; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class lc_ctrl_env extends cip_base_env #(
  .CFG_T              (lc_ctrl_env_cfg),
  .COV_T              (lc_ctrl_env_cov),
  .VIRTUAL_SEQUENCER_T(lc_ctrl_virtual_sequencer),
  .SCOREBOARD_T       (lc_ctrl_scoreboard)
);
  `uvm_component_utils(lc_ctrl_env)

  push_pull_agent #(
    .HostDataWidth  (OTP_PROG_HDATA_WIDTH),
    .DeviceDataWidth(OTP_PROG_DDATA_WIDTH)
  ) m_otp_prog_pull_agent;
  push_pull_agent #(.HostDataWidth(lc_ctrl_state_pkg::LcTokenWidth)) m_otp_token_pull_agent;
  alert_esc_agent m_esc_scrap_state1_agent;
  alert_esc_agent m_esc_scrap_state0_agent;
  jtag_riscv_agent m_jtag_riscv_agent;

  `uvm_component_new

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);

    // config power manager pin
    if (!uvm_config_db#(pwr_lc_vif)::get(this, &quot;&quot;, &quot;pwr_lc_vif&quot;, cfg.pwr_lc_vif)) begin
      `uvm_fatal(get_full_name(), &quot;failed to get pwr_lc_vif from uvm_config_db&quot;)
    end
    if (!uvm_config_db#(lc_ctrl_vif)::get(this, &quot;&quot;, &quot;lc_ctrl_vif&quot;, cfg.lc_ctrl_vif)) begin
      `uvm_fatal(`gfn, &quot;failed to get lc_ctrl_vif from uvm_config_db&quot;)
    end

    m_esc_scrap_state1_agent = alert_esc_agent::type_id::create(&quot;m_esc_scrap_state1_agent&quot;, this);
    uvm_config_db#(alert_esc_agent_cfg)::set(this, &quot;m_esc_scrap_state1_agent&quot;, &quot;cfg&quot;,
                                             cfg.m_esc_scrap_state1_agent_cfg);
    cfg.m_esc_scrap_state1_agent_cfg.en_cov = cfg.en_cov;

    m_esc_scrap_state0_agent = alert_esc_agent::type_id::create(&quot;m_esc_scrap_state0_agent&quot;, this);
    uvm_config_db#(alert_esc_agent_cfg)::set(this, &quot;m_esc_scrap_state0_agent&quot;, &quot;cfg&quot;,
                                             cfg.m_esc_scrap_state0_agent_cfg);
    cfg.m_esc_scrap_state0_agent_cfg.en_cov = cfg.en_cov;

    m_jtag_riscv_agent = jtag_riscv_agent::type_id::create(&quot;m_jtag_riscv_agent&quot;, this);
    uvm_config_db#(jtag_riscv_agent_cfg)::set(this, &quot;m_jtag_riscv_agent&quot;, &quot;cfg&quot;,
                                              cfg.m_jtag_riscv_agent_cfg);
    cfg.m_jtag_riscv_agent_cfg.en_cov = cfg.en_cov;

    m_otp_prog_pull_agent = push_pull_agent#(
      .HostDataWidth  (OTP_PROG_HDATA_WIDTH),
      .DeviceDataWidth(OTP_PROG_DDATA_WIDTH)
    )::type_id::create(
        &quot;m_otp_prog_pull_agent&quot;, this
    );
    uvm_config_db#(push_pull_agent_cfg#(.HostDataWidth(OTP_PROG_HDATA_WIDTH),
                                        .DeviceDataWidth(OTP_PROG_DDATA_WIDTH)

    cfg.m_otp_prog_pull_agent_cfg.en_cov = cfg.en_cov;

    m_otp_token_pull_agent = push_pull_agent#(
      .HostDataWidth(lc_ctrl_state_pkg::LcTokenWidth)
    )::type_id::create(
        &quot;m_otp_token_pull_agent&quot;, this
    );
    uvm_config_db#(push_pull_agent_cfg#(.HostDataWidth(lc_ctrl_state_pkg::LcTokenWidth)))::set(
                                        this,
                                        &quot;m_otp_token_pull_agent&quot;,
                                        &quot;cfg&quot;,
                                        cfg.m_otp_token_pull_agent_cfg);
    cfg.m_otp_token_pull_agent_cfg.en_cov = cfg.en_cov;
  endfunction

  function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
    virtual_sequencer.otp_prog_pull_sequencer_h = m_otp_prog_pull_agent.sequencer;
    virtual_sequencer.otp_token_pull_sequencer_h = m_otp_token_pull_agent.sequencer;
    virtual_sequencer.esc_wipe_secrets_sequencer_h = m_esc_scrap_state1_agent.sequencer;
    virtual_sequencer.esc_scrap_state_sequencer_h = m_esc_scrap_state0_agent.sequencer;
    virtual_sequencer.jtag_riscv_sequencer_h = m_jtag_riscv_agent.sequencer;
    if (cfg.en_scb) begin
      m_otp_prog_pull_agent.monitor.analysis_port.connect(scoreboard.otp_prog_fifo.analysis_export);
      m_otp_token_pull_agent.monitor.analysis_port.connect(
          scoreboard.otp_token_fifo.analysis_export);
      m_esc_scrap_state1_agent.monitor.analysis_port.connect(
          scoreboard.esc_wipe_secrets_fifo.analysis_export);
      m_esc_scrap_state0_agent.monitor.analysis_port.connect(
          scoreboard.esc_scrap_state_fifo.analysis_export);
    end
  endfunction

endclass
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-spi-device-rtl-spi-device-sv">
<span id="error-hw-ip-spi-device-rtl-spi-device-sv"></span><h2>hw/ip/spi_device/rtl/spi_device.sv<a class="headerlink" href="#hw-ip-spi-device-rtl-spi-device-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/spi_device/rtl/spi_device.sv: Error lex/parsing-ing formatted output.  Please file a bug.
First error: token: &quot;spi_s2p&quot; at 765:3-9; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Serial Peripheral Interface (SPI) Device module.
//

`include &quot;prim_assert.sv&quot;

module spi_device
  import spi_device_reg_pkg::*;
#(
  parameter logic [NumAlerts-1:0] AlertAsyncOn = {NumAlerts{1&#39;b1}}
) (
  input clk_i,
  input rst_ni,

  // Register interface
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

  // Alerts
  input  prim_alert_pkg::alert_rx_t [NumAlerts-1:0] alert_rx_i,
  output prim_alert_pkg::alert_tx_t [NumAlerts-1:0] alert_tx_o,

  // SPI Interface
  input              cio_sck_i,
  input              cio_csb_i,
  output logic [3:0] cio_sd_o,
  output logic [3:0] cio_sd_en_o,
  input        [3:0] cio_sd_i,

  // Passthrough interface
  output spi_device_pkg::passthrough_req_t passthrough_o,
  input  spi_device_pkg::passthrough_rsp_t passthrough_i,

  // Interrupts
  output logic intr_rxf_o,  // RX FIFO Full
  output logic intr_rxlvl_o,  // RX FIFO above level
  output logic intr_txlvl_o,  // TX FIFO below level
  output logic intr_rxerr_o,  // RX Frame error
  output logic intr_rxoverflow_o,  // RX Async FIFO Overflow
  output logic intr_txunderflow_o,  // TX Async FIFO Underflow

  // Memory configuration
  input prim_ram_2p_pkg::ram_2p_cfg_t ram_cfg_i,

  // DFT related controls
  input mbist_en_i,
  input scan_clk_i,
  input scan_rst_ni,
  input lc_ctrl_pkg::lc_tx_t scanmode_i
);

  import spi_device_pkg::*;

  localparam int FifoWidth = $bits(spi_byte_t);
  localparam int FifoDepth = 8;  // 2 DWords
  localparam int SDW = $clog2(SramDw / FifoWidth);
  localparam int PtrW = SramAw + 1 + SDW;
  localparam int AsFifoDepthW = $clog2(FifoDepth + 1);

  logic clk_spi_in, clk_spi_in_muxed, clk_spi_in_buf;  // clock for latch SDI
  logic clk_spi_out, clk_spi_out_muxed, clk_spi_out_buf;  // clock for driving SDO

  spi_device_reg2hw_t              reg2hw;
  spi_device_hw2reg_t              hw2reg;

  tlul_pkg::tl_h2d_t               tl_sram_h2d;
  tlul_pkg::tl_d2h_t               tl_sram_d2h;

  // Dual-port SRAM Interface: Refer prim_ram_2p_wrapper.sv
  logic                            sram_clk;
  logic                            sram_clk_en;
  logic                            sram_clk_ungated;
  logic                            sram_clk_muxed;
  logic                            sram_rst_n;
  logic                            sram_rst_n_noscan;

  logic                            mem_a_req;
  logic                            mem_a_write;
  logic               [SramAw-1:0] mem_a_addr;
  logic               [SramDw-1:0] mem_a_wdata;
  logic                            mem_a_rvalid;
  logic               [SramDw-1:0] mem_a_rdata;
  logic               [       1:0] mem_a_rerror;

  logic                            mem_b_req;
  logic                            mem_b_write;
  logic               [SramAw-1:0] mem_b_addr;
  logic               [SramDw-1:0] mem_b_wdata;
  logic                            mem_b_rvalid;
  logic               [SramDw-1:0] mem_b_rdata;
  logic               [       1:0] mem_b_rerror;


  // Submoule SRAM Requests
  logic                            sub_sram_req      [IoModeEnd];
  logic                            sub_sram_write    [IoModeEnd];
  logic               [SramAw-1:0] sub_sram_addr     [IoModeEnd];
  logic               [SramDw-1:0] sub_sram_wdata    [IoModeEnd];
  logic                            sub_sram_rvalid   [IoModeEnd];
  logic               [SramDw-1:0] sub_sram_rdata    [IoModeEnd];
  logic               [       1:0] sub_sram_rerror   [IoModeEnd];

  // Host return path mux
  logic [3:0] internal_sd, internal_sd_en;
  logic [3:0] passthrough_sd, passthrough_sd_en;

  /////////////////////
  // Control signals //
  /////////////////////

  logic cpol;  // Clock polarity
  logic cpha;  // Phase : Not complete
  logic txorder;  // TX bitstream order: 0(bit 7 to 0), 1(bit 0 to 7)
  logic rxorder;  // RX bitstream order: 0(bit 7 to 0), 1(bit 0 to 7)

  logic abort;  // Abort current operations (txf only at this time)
  // Think how FW knows abort is done.
  //logic abort_done; // TODO: Not implemented yet

  logic csb_syncd;

  logic rst_txfifo_n, rst_rxfifo_n;
  logic rst_txfifo_reg, rst_rxfifo_reg;

  //spi_addr_size_e addr_size; // Not used in fwmode
  spi_mode_e spi_mode;
  //spi_byte_t fw_dummy_byte;
  logic [255:0] cfg_upload_mask;
  logic cfg_addr_4b_en;

  logic intr_sram_rxf_full, intr_fwm_rxerr;
  logic intr_fwm_rxlvl, rxlvl, rxlvl_d, intr_fwm_txlvl, txlvl, txlvl_d;
  logic intr_fwm_rxoverflow, intr_fwm_txunderflow;

  logic rxf_overflow, txf_underflow;

  logic [7:0] timer_v;  // Wait timer inside rxf control
  logic [PtrW-1:0] sram_rxf_rptr, sram_rxf_wptr;
  logic [PtrW-1:0] sram_txf_rptr, sram_txf_wptr;
  logic [PtrW-1:0] sram_rxf_depth, sram_txf_depth;

  logic [SramAw-1:0] sram_rxf_bindex, sram_txf_bindex;
  logic [SramAw-1:0] sram_rxf_lindex, sram_txf_lindex;

  logic [AsFifoDepthW-1:0] as_txfifo_depth, as_rxfifo_depth;

  logic rxf_empty, rxf_full, txf_empty, txf_full;
  logic rxf_full_syncd, txf_empty_syncd;  // sync signals

  // SPI S2P signals
  // io_mode: Determine s2p/p2s behavior. As of now, only fwmode exists.
  // TODO: Add FlashMode IO, passthrough IO
  // based on the SPI protocol, the mode should be changed at the negedge of
  // SPI_CLK. The sub_iomode value is changed based on the input of SPI,
  // it is latched by clk_spi_out.
  // TODO: Add this path to DC constraint
  io_mode_e io_mode, io_mode_outclk;
  io_mode_e                sub_iomode          [IoModeEnd];
  logic                    s2p_data_valid;
  spi_byte_t               s2p_data;
  logic      [BitCntW-1:0] s2p_bitcnt;

  logic                    p2s_valid;
  spi_byte_t               p2s_data;
  logic                    p2s_sent;

  logic                    sub_p2s_valid       [IoModeEnd];
  spi_byte_t               sub_p2s_data        [IoModeEnd];
  logic                    sub_p2s_sent        [IoModeEnd];

  // Read commands related signals
  logic      [       31:0] readbuf_addr_sck;
  logic      [       31:0] readbuf_addr_busclk;

  // CMD interface
  sel_datapath_e cmd_dp_sel, cmd_dp_sel_outclk;

  // Mailbox in Passthrough needs to take SPI if readcmd hits mailbox address
  logic mailbox_assumed, passthrough_assumed_by_internal;

  // Passthrouth config signals
  logic        [          255:0]                cmd_filter;

  logic        [           31:0]                addr_swap_mask;
  logic        [           31:0]                addr_swap_data;

  // Command Info structure
  cmd_info_t [                  NumCmdInfo-1:0] cmd_info;
  // Broadcasted cmd_info. cmdparse compares the opcode up to CmdInfoReadCmdEnd
  // and latches the cmd_info and broadcast to submodules
  cmd_info_t                                    cmd_info_broadcast;
  logic        [CmdInfoIdxW-1:0]                cmd_info_idx_broadcast;

  // Bus clock pulse event of CSb de-assertion. It is used to latch the SCK
  // domain variables into the bus clock domain.
  logic                                         csb_deasserted_busclk;

  // Read Status input and broadcast
  logic                                         status_busy_set;  // set by HW (upload)
  logic                                         status_busy_broadcast;  // from spid_status

  // Jedec ID
  logic        [           23:0]                jedec_id;

  //////////////////////////////////////////////////////////////////////
  // Connect phase (between control signals above and register module //
  //////////////////////////////////////////////////////////////////////

  assign cpol = reg2hw.cfg.cpol.q;
  assign cpha = reg2hw.cfg.cpha.q;
  assign txorder = reg2hw.cfg.tx_order.q;
  assign rxorder = reg2hw.cfg.rx_order.q;

  assign rst_txfifo_reg = reg2hw.control.rst_txfifo.q;
  assign rst_rxfifo_reg = reg2hw.control.rst_rxfifo.q;

  assign sram_clk_en = reg2hw.control.sram_clk_en.q;

  assign timer_v = reg2hw.cfg.timer_v.q;

  assign cfg_addr_4b_en = reg2hw.cfg.addr_4b_en.q;

  assign sram_rxf_bindex = reg2hw.rxf_addr.base.q[SDW+:SramAw];
  assign sram_rxf_lindex = reg2hw.rxf_addr.limit.q[SDW+:SramAw];
  assign sram_txf_bindex = reg2hw.txf_addr.base.q[SDW+:SramAw];
  assign sram_txf_lindex = reg2hw.txf_addr.limit.q[SDW+:SramAw];

  assign sram_rxf_rptr = reg2hw.rxf_ptr.rptr.q[PtrW-1:0];
  assign hw2reg.rxf_ptr.wptr.d = {{(16 - PtrW) {1&#39;b0}}, sram_rxf_wptr};
  assign hw2reg.rxf_ptr.wptr.de = 1&#39;b1;

  assign sram_txf_wptr = reg2hw.txf_ptr.wptr.q[PtrW-1:0];
  assign hw2reg.txf_ptr.rptr.d = {{(16 - PtrW) {1&#39;b0}}, sram_txf_rptr};
  assign hw2reg.txf_ptr.rptr.de = 1&#39;b1;

  assign abort = reg2hw.control.abort.q;
  assign hw2reg.status.abort_done.d = 1&#39;b1;

  assign hw2reg.status.rxf_empty.d = rxf_empty;
  assign hw2reg.status.txf_full.d = txf_full;

  // SYNC logic required
  assign hw2reg.status.rxf_full.d = rxf_full_syncd;
  assign hw2reg.status.txf_empty.d = txf_empty_syncd;

  // CSb : after 2stage synchronizer
  assign hw2reg.status.csb.d = csb_syncd;
  prim_flop_2sync #(
    .Width(1)
  ) u_sync_csb (
    .clk_i,
    .rst_ni,
    .d_i(cio_csb_i),
    .q_o(csb_syncd)
  );

  logic rxf_full_q, txf_empty_q;
  always_ff @(posedge clk_spi_in_buf or negedge rst_ni) begin
    if (!rst_ni) rxf_full_q &lt;= 1&#39;b0;
    else rxf_full_q &lt;= rxf_full;
  end
  always_ff @(posedge clk_spi_out_buf or negedge rst_ni) begin
    if (!rst_ni) txf_empty_q &lt;= 1&#39;b1;
    else txf_empty_q &lt;= txf_empty;
  end
  prim_flop_2sync #(
    .Width(1)
  ) u_sync_rxf (
    .clk_i,
    .rst_ni,
    .d_i(rxf_full_q),
    .q_o(rxf_full_syncd)
  );
  prim_flop_2sync #(
    .Width(1),
    .ResetValue(1&#39;b1)
  ) u_sync_txe (
    .clk_i,
    .rst_ni,
    .d_i(txf_empty_q),
    .q_o(txf_empty_syncd)
  );

  assign spi_mode = spi_mode_e&#39;(reg2hw.control.mode.q);

  // TODO: Define and connect masks.
  assign cfg_upload_mask = &#39;0;

  // Async FIFO level
  //  rx rdepth, tx wdepth to be in main clock domain
  assign hw2reg.async_fifo_level.txlvl.d = {{(8 - AsFifoDepthW) {1&#39;b0}}, as_txfifo_depth};
  assign hw2reg.async_fifo_level.rxlvl.d = {{(8 - AsFifoDepthW) {1&#39;b0}}, as_rxfifo_depth};

  // Interrupt

  // Edge
  logic sram_rxf_full_q, fwm_rxerr_q;
  logic sram_rxf_full, fwm_rxerr;

  // TODO: Check if CE# deasserted in the middle of bit transfer
  assign fwm_rxerr = 1&#39;b0;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      sram_rxf_full_q &lt;= 1&#39;b0;
      fwm_rxerr_q     &lt;= 1&#39;b0;
    end else begin
      sram_rxf_full_q &lt;= sram_rxf_full;
      fwm_rxerr_q     &lt;= fwm_rxerr;
    end
  end

  // Interrupt
  assign intr_sram_rxf_full = ~sram_rxf_full_q &amp; sram_rxf_full;
  assign intr_fwm_rxerr     = ~fwm_rxerr_q &amp; fwm_rxerr;

  assign rxlvl_d            = (sram_rxf_depth &gt;= reg2hw.fifo_level.rxlvl.q[PtrW-1:0]);
  assign txlvl_d            = (sram_txf_depth &lt; reg2hw.fifo_level.txlvl.q[PtrW-1:0]);

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      rxlvl &lt;= 1&#39;b0;
      txlvl &lt;= 1&#39;b0;
    end else begin
      rxlvl &lt;= rxlvl_d;
      txlvl &lt;= txlvl_d;
    end
  end
  assign intr_fwm_rxlvl = ~rxlvl &amp;&amp; rxlvl_d;
  assign intr_fwm_txlvl = ~txlvl &amp;&amp; txlvl_d;

  // rxf_overflow
  //    Could trigger lint error for input clock.
  //    It&#39;s unavoidable due to the characteristics of SPI intf
  prim_pulse_sync u_rxf_overflow (
    .clk_src_i  (clk_spi_in_buf),
    .rst_src_ni (rst_ni),
    .src_pulse_i(rxf_overflow),
    .clk_dst_i  (clk_i),
    .rst_dst_ni (rst_ni),
    .dst_pulse_o(intr_fwm_rxoverflow)
  );

  // txf_underflow
  //    Could trigger lint error for input clock.
  //    It&#39;s unavoidable due to the characteristics of SPI intf
  prim_pulse_sync u_txf_underflow (
    .clk_src_i  (clk_spi_out_buf),
    .rst_src_ni (rst_ni),
    .src_pulse_i(txf_underflow),
    .clk_dst_i  (clk_i),
    .rst_dst_ni (rst_ni),
    .dst_pulse_o(intr_fwm_txunderflow)
  );

  assign intr_rxlvl_o = reg2hw.intr_enable.rxlvl.q &amp; reg2hw.intr_state.rxlvl.q;
  assign intr_txlvl_o = reg2hw.intr_enable.txlvl.q &amp; reg2hw.intr_state.txlvl.q;
  assign intr_rxf_o = reg2hw.intr_enable.rxf.q &amp; reg2hw.intr_state.rxf.q;
  assign intr_rxerr_o = reg2hw.intr_enable.rxerr.q &amp; reg2hw.intr_state.rxerr.q;
  assign intr_rxoverflow_o = reg2hw.intr_enable.rxoverflow.q &amp; reg2hw.intr_state.rxoverflow.q;
  assign intr_txunderflow_o = reg2hw.intr_enable.txunderflow.q &amp; reg2hw.intr_state.txunderflow.q;

  assign hw2reg.intr_state.rxf.d = 1&#39;b1;
  assign hw2reg.intr_state.rxf.de   = intr_sram_rxf_full |
                                      (reg2hw.intr_test.rxf.qe   &amp; reg2hw.intr_test.rxf.q);
  assign hw2reg.intr_state.rxerr.d = 1&#39;b1;
  assign hw2reg.intr_state.rxerr.de = intr_fwm_rxerr |
                                      (reg2hw.intr_test.rxerr.qe &amp; reg2hw.intr_test.rxerr.q);
  assign hw2reg.intr_state.rxlvl.d = 1&#39;b1;
  assign hw2reg.intr_state.rxlvl.de = intr_fwm_rxlvl |
                                      (reg2hw.intr_test.rxlvl.qe &amp; reg2hw.intr_test.rxlvl.q);
  assign hw2reg.intr_state.txlvl.d = 1&#39;b1;
  assign hw2reg.intr_state.txlvl.de = intr_fwm_txlvl |
                                      (reg2hw.intr_test.txlvl.qe &amp; reg2hw.intr_test.txlvl.q);
  assign hw2reg.intr_state.rxoverflow.d = 1&#39;b1;
  assign hw2reg.intr_state.rxoverflow.de  = intr_fwm_rxoverflow |
      (reg2hw.intr_test.rxoverflow.qe  &amp; reg2hw.intr_test.rxoverflow.q);
  assign hw2reg.intr_state.txunderflow.d = 1&#39;b1;
  assign hw2reg.intr_state.txunderflow.de = intr_fwm_txunderflow |
      (reg2hw.intr_test.txunderflow.qe &amp; reg2hw.intr_test.txunderflow.q);

  // SPI Flash commands registers
  // TODO: Add 2FF sync? or just waive?
  assign hw2reg.last_read_addr.d = readbuf_addr_busclk;

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      readbuf_addr_busclk &lt;= &#39;0;
    end else if (csb_deasserted_busclk) begin
      readbuf_addr_busclk &lt;= readbuf_addr_sck;
    end
  end

  // Jedec ID
  assign jedec_id = {reg2hw.jedec_id.mf.q, reg2hw.jedec_id.id.q};

  // Passthrough config: value shall be stable while SPI transaction is active
  //assign cmd_filter = reg2hw.cmd_filter.q;
  always_comb begin
    for (int unsigned i = 0; i &lt; 256; i++) begin
      cmd_filter[i] = reg2hw.cmd_filter[i].q;
    end
  end

  assign addr_swap_mask = reg2hw.addr_swap_mask.q;
  assign addr_swap_data = reg2hw.addr_swap_data.q;

  // Connect command info
  always_comb begin
    for (int unsigned i = 0; i &lt; spi_device_reg_pkg::NumCmdInfo; i++) begin
      cmd_info[i] = &#39;{
        opcode:           reg2hw.cmd_info[i].opcode.q,
        addr_en:          reg2hw.cmd_info[i].addr_en.q,
        addr_swap_en:     reg2hw.cmd_info[i].addr_swap_en.q,
        addr_4b_affected: reg2hw.cmd_info[i].addr_4b_affected.q,
        mbyte_en:         reg2hw.cmd_info[i].mbyte_en.q,
        dummy_en:         reg2hw.cmd_info[i].dummy_en.q,
        dummy_size:       reg2hw.cmd_info[i].dummy_size.q,
        payload_en:       reg2hw.cmd_info[i].payload_en.q,
        payload_dir:      payload_dir_e&#39;(reg2hw.cmd_info[i].payload_dir.q)
      };
    end
  end

  //////////////////////////////
  // // Clock &amp; reset control //
  //////////////////////////////
  //  clk_spi cannot use glitch-free clock mux as clock switching in glitch-free
  //  requires two clocks to propagate clock selection and enable but SPI clock
  //  doesn&#39;t exist until it transmits data through SDI
  logic sck_n;
  logic rst_spi_n;
  lc_ctrl_pkg::lc_tx_t [ScanModeUseLast-1:0] scanmode;

  prim_lc_sync #(
    .NumCopies(int&#39;(ScanModeUseLast)),
    .AsyncOn  (0)
  ) u_scanmode_sync (
    .clk_i  (1&#39;b0),  //unused
    .rst_ni (1&#39;b1),  //unused
    .lc_en_i(scanmode_i),
    .lc_en_o(scanmode)
  );

  prim_clock_inv u_clk_spi (
    .clk_i(cio_sck_i),
    .clk_no(sck_n),
    .scanmode_i(scanmode[ClkInvSel] == lc_ctrl_pkg::On)
  );

  assign clk_spi_in  = (cpha ^ cpol) ? sck_n : cio_sck_i;
  assign clk_spi_out = (cpha ^ cpol) ? cio_sck_i : sck_n;

  prim_clock_mux2 #(
    .NoFpgaBufG(1&#39;b1)
  ) u_clk_spi_in_mux (
    .clk0_i(clk_spi_in),
    .clk1_i(scan_clk_i),
    .sel_i (scanmode[ClkMuxSel] == lc_ctrl_pkg::On),
    .clk_o (clk_spi_in_muxed)
  );

  prim_clock_buf u_clk_spi_in_buf (
    .clk_i(clk_spi_in_muxed),
    .clk_o(clk_spi_in_buf)
  );

  prim_clock_mux2 #(
    .NoFpgaBufG(1&#39;b1)
  ) u_clk_spi_out_mux (
    .clk0_i(clk_spi_out),
    .clk1_i(scan_clk_i),
    .sel_i (scanmode[ClkMuxSel] == lc_ctrl_pkg::On),
    .clk_o (clk_spi_out_muxed)
  );

  prim_clock_buf u_clk_spi_out_buf (
    .clk_i(clk_spi_out_muxed),
    .clk_o(clk_spi_out_buf)
  );

  prim_clock_mux2 #(
    .NoFpgaBufG(1&#39;b1)
  ) u_csb_rst_scan_mux (
    .clk0_i(rst_ni &amp; ~cio_csb_i),
    .clk1_i(scan_rst_ni),
    .sel_i (scanmode[CsbRstMuxSel] == lc_ctrl_pkg::On),
    .clk_o (rst_spi_n)
  );

  prim_clock_mux2 #(
    .NoFpgaBufG(1&#39;b1)
  ) u_tx_rst_scan_mux (
    .clk0_i(rst_ni &amp; ~rst_txfifo_reg),
    .clk1_i(scan_rst_ni),
    .sel_i (scanmode[TxRstMuxSel] == lc_ctrl_pkg::On),
    .clk_o (rst_txfifo_n)
  );

  prim_clock_mux2 #(
    .NoFpgaBufG(1&#39;b1)
  ) u_rx_rst_scan_mux (
    .clk0_i(rst_ni &amp; ~rst_rxfifo_reg),
    .clk1_i(scan_rst_ni),
    .sel_i (scanmode[RxRstMuxSel] == lc_ctrl_pkg::On),
    .clk_o (rst_rxfifo_n)
  );

  // SRAM clock
  // If FwMode, SRAM clock for B port uses peripheral clock (clk_i)
  // If FlashMode or PassThrough, SRAM clock for B port uses SPI_CLK
  // To remove glitch, CG cell is put after clock mux
  // The enable signal is not synchronized to SRAM_CLK when clock is
  // switched into SPI_CLK. So, change the clock only when SPI_CLK is
  // not toggle.
  //
  // Programming sequence:
  // Change to SPI_CLK
  //  1. Check if SPI line is idle.
  //  2. Clear sram_clk_en to 0.
  //  3. Change mode to FlashMode or PassThrough
  //  4. Set sram_clk_en to 1.
  // Change to peripheral clk
  //  1. Check if SPI_CLK is idle
  //  2. Clear sram_clk_en to 0.
  //  3. Change mode to FwMode
  //  4. Set sram_clk_en to 1.
  prim_clock_mux2 #(
    .NoFpgaBufG(1&#39;b1)
  ) u_sram_clk_sel (
    .clk0_i(clk_spi_in_muxed),
    .clk1_i(clk_i),
    .sel_i (spi_mode == FwMode),
    .clk_o (sram_clk_ungated)
  );

  prim_clock_mux2 #(
    .NoFpgaBufG(1&#39;b1)
  ) u_sram_clk_scan (
    .clk0_i(sram_clk_ungated),
    .clk1_i(scan_clk_i),
    .sel_i ((scanmode[ClkSramSel] == lc_ctrl_pkg::On) | mbist_en_i),
    .clk_o (sram_clk_muxed)
  );

  prim_clock_gating u_sram_clk_cg (
    .clk_i  (sram_clk_muxed),
    .en_i   (sram_clk_en),
    .test_en_i ((scanmode[ClkSramSel] == lc_ctrl_pkg::On) | mbist_en_i),
    .clk_o  (sram_clk)
  );

  prim_clock_mux2 #(
    .NoFpgaBufG(1&#39;b1)
  ) u_sram_rst_sel (
    .clk0_i(rst_spi_n),
    .clk1_i(rst_ni),
    .sel_i (spi_mode == FwMode),
    .clk_o (sram_rst_n_noscan)
  );

  prim_clock_mux2 #(
    .NoFpgaBufG(1&#39;b1)
  ) u_sram_rst_scanmux (
    .clk0_i(sram_rst_n_noscan),
    .clk1_i(scan_rst_ni),
    .sel_i (scanmode[RstSramSel] == lc_ctrl_pkg::On),
    .clk_o (sram_rst_n)
  );

  // CSb deassertion pulse generator
  logic csb_sync, csb_sync_q;
  prim_flop_2sync #(
    .Width     (1),
    .ResetValue(1&#39;b1)
  ) u_csb_sync (
    .clk_i,
    .rst_ni,
    .d_i(cio_csb_i),
    .q_o(csb_sync)
  );
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) csb_sync_q &lt;= 1&#39;b1;
    else csb_sync_q &lt;= csb_sync;
  end

  assign csb_deasserted_busclk = !csb_sync_q &amp;&amp; csb_sync;

  // CSb pulse
  logic csb_sckin_sync_d, csb_sckin_sync_q, csb_asserted_pulse_sckin;
  prim_flop_2sync #(
    .Width     (1),
    .ResetValue(1&#39;b1)
  ) u_csb_sckin_sync (
    .clk_i(clk_spi_in_buf),
    .rst_ni(rst_spi_n),  //Use CSb as a reset
    .d_i(1&#39;b0),
    .q_o(csb_sckin_sync_d)
  );
  always_ff @(posedge clk_spi_in_buf or negedge rst_spi_n) begin
    if (!rst_spi_n) csb_sckin_sync_q &lt;= 1&#39;b1;
    else csb_sckin_sync_q &lt;= csb_sckin_sync_d;
  end

  assign csb_asserted_pulse_sckin = csb_sckin_sync_q &amp;&amp; !csb_sckin_sync_d;

  //////////////////////////////
  // SPI_DEVICE mode selector //
  //////////////////////////////
  // This logic chooses appropriate signals based on input SPI_DEVICE mode.
  // e.g) If FwMode is selected. all data connected to spi_fwmode logic

  // Assume spi_mode does not change dynamically

  // io_mode to spi_s2p io_mode should be affected at the negedge of SPI_CLK
  // based on SPI protocol. the internal io_mode signal is generated by SPI
  // input signals. So, the io_mode should be latched at clk_spi_out to not
  // introduce the timing loop.
  //
  // example: cmdparse triggers sel_dp at 8th beat of CMD bit.
  //       -&gt; readcmd activates, it also changes IoMode if opcode is DualIO
  //          or QuadIO commands
  //       -&gt; changed io_mode affects spi_s2p module, which again affects
  //          cmdparse module.
  always_ff @(posedge clk_spi_out_buf or negedge rst_spi_n) begin
    if (!rst_spi_n) io_mode_outclk &lt;= SingleIO;
    else io_mode_outclk &lt;= io_mode;
  end

  always_ff @(posedge clk_spi_out_buf or negedge rst_spi_n) begin
    if (!rst_spi_n) cmd_dp_sel_outclk &lt;= DpNone;
    else cmd_dp_sel_outclk &lt;= cmd_dp_sel;
  end

  always_comb begin
    io_mode         = SingleIO;
    p2s_valid       = 1&#39;b0;
    p2s_data        = 8&#39;h0;
    sub_p2s_sent    = &#39;{default: 1&#39;b0};

    mem_b_req       = 1&#39;b0;
    mem_b_write     = 1&#39;b0;
    mem_b_addr      = &#39;0;
    mem_b_wdata     = &#39;0;
    sub_sram_rvalid = &#39;{default: 1&#39;b0};
    sub_sram_rdata  = &#39;{default: &#39;0};
    sub_sram_rerror = &#39;{default: 2&#39;b00};

    unique case (spi_mode)
      FwMode: begin
        io_mode = sub_iomode[IoModeFw];

        p2s_valid = sub_p2s_valid[IoModeFw];
        p2s_data  = sub_p2s_data[IoModeFw];
        sub_p2s_sent[IoModeFw] = p2s_sent;

        // SRAM:: Remember this has glitch
        // switch should happen only when clock gate is disabled.
        mem_b_req   = sub_sram_req   [IoModeFw];
        mem_b_write = sub_sram_write [IoModeFw];
        mem_b_addr  = sub_sram_addr  [IoModeFw];
        mem_b_wdata = sub_sram_wdata [IoModeFw];
        sub_sram_rvalid [IoModeFw] = mem_b_rvalid;
        sub_sram_rdata  [IoModeFw] = mem_b_rdata;
        sub_sram_rerror [IoModeFw] = mem_b_rerror;
      end

      FlashMode, PassThrough: begin
        unique case (cmd_dp_sel_outclk)
          DpNone: begin
            io_mode = sub_iomode[IoModeCmdParse];

            sub_p2s_sent[IoModeCmdParse] = p2s_sent;

            // Leave SRAM default;
          end
          DpReadCmd: begin
            io_mode = sub_iomode[IoModeReadCmd];

            p2s_valid = sub_p2s_valid[IoModeReadCmd];
            p2s_data  = sub_p2s_data[IoModeReadCmd];
            sub_p2s_sent[IoModeReadCmd] = p2s_sent;

            // SRAM:: Remember this has glitch
            // switch should happen only when clock gate is disabled.
            mem_b_req   = sub_sram_req   [IoModeReadCmd];
            mem_b_write = sub_sram_write [IoModeReadCmd];
            mem_b_addr  = sub_sram_addr  [IoModeReadCmd];
            mem_b_wdata = sub_sram_wdata [IoModeReadCmd];
            sub_sram_rvalid [IoModeReadCmd] = mem_b_rvalid;
            sub_sram_rdata  [IoModeReadCmd] = mem_b_rdata;
            sub_sram_rerror [IoModeReadCmd] = mem_b_rerror;
          end
          DpReadStatus: begin
            io_mode = sub_iomode[IoModeStatus];

            p2s_valid = sub_p2s_valid[IoModeStatus];
            p2s_data = sub_p2s_data[IoModeStatus];
            sub_p2s_sent[IoModeStatus] = p2s_sent;

            // default memory (tied)
          end

          DpReadSFDP: begin
            io_mode = sub_iomode[IoModeJedec];

            p2s_valid = sub_p2s_valid[IoModeJedec];
            p2s_data = sub_p2s_data[IoModeJedec];
            sub_p2s_sent[IoModeJedec] = p2s_sent;
          end
          // DpReadJEDEC:
          // DpUpload:
          // DpUnknown:
          default: begin
            io_mode = sub_iomode[IoModeCmdParse];

            sub_p2s_sent[IoModeCmdParse] = p2s_sent;
          end
        endcase
      end

      default: begin
        io_mode = SingleIO;
      end
    endcase
  end
  `ASSERT_KNOWN(SpiModeKnown_A, spi_mode)

  always_comb begin
    cio_sd_o    = internal_sd;
    cio_sd_en_o = internal_sd_en;

    unique case (spi_mode)
      FwMode, FlashMode: begin
        cio_sd_o    = internal_sd;
        cio_sd_en_o = internal_sd_en;
      end

      PassThrough: begin
        if (passthrough_assumed_by_internal) begin
          cio_sd_o    = internal_sd;
          cio_sd_en_o = internal_sd_en;
        end else begin
          cio_sd_o    = passthrough_sd;
          cio_sd_en_o = passthrough_sd_en;
        end
      end

      default: begin
        cio_sd_o    = internal_sd;
        cio_sd_en_o = internal_sd_en;
      end
    endcase
  end
  assign passthrough_assumed_by_internal = mailbox_assumed
      // TOGO: Uncomment below when those submodules are implemented.
      // | readstatus_assumed | readsfdp_assumed | readjedec_assumed    ;

  ////////////////////////////
  // SPI Serial to Parallel //
  ////////////////////////////
  spi_s2p u_s2p (
    .clk_i (clk_spi_in_buf),
    .rst_ni(rst_spi_n),

    // SPI interface
    .s_i(cio_sd_i),

    .data_valid_o(s2p_data_valid),
    .data_o      (s2p_data),
    .bitcnt_o    (s2p_bitcnt),

    // Config (changed dynamically)
    .order_i  (rxorder),
    .io_mode_i(io_mode_outclk)
  );

  spi_p2s u_p2s (
    .clk_i (clk_spi_out_buf),
    .rst_ni(rst_spi_n),

    .data_valid_i(p2s_valid),
    .data_i      (p2s_data),
    .data_sent_o (p2s_sent),

    .csb_i (cio_csb_i),
    .s_en_o(internal_sd_en),
    .s_o   (internal_sd),

    .cpha_i   (cpha),
    .order_i  (txorder),
    .io_mode_i(io_mode_outclk)
  );

  /////////////
  // FW Mode //
  /////////////
  spi_fwmode #(
    .FifoWidth(FifoWidth),
    .FifoDepth(FifoDepth)
  ) u_fwmode (
    .clk_i (sram_clk),
    .rst_ni(sram_rst_n),

    .clk_spi_in_i (clk_spi_in_buf),
    .rst_rxfifo_ni(rst_rxfifo_n),
    .clk_spi_out_i(clk_spi_out_buf),
    .rst_txfifo_ni(rst_txfifo_n),

    .rxf_overflow_o (rxf_overflow),
    .txf_underflow_o(txf_underflow),

    // SRAM interface
    .fwm_req_o   (sub_sram_req[IoModeFw]),
    .fwm_write_o (sub_sram_write[IoModeFw]),
    .fwm_addr_o  (sub_sram_addr[IoModeFw]),
    .fwm_wdata_o (sub_sram_wdata[IoModeFw]),
    .fwm_rvalid_i(sub_sram_rvalid[IoModeFw]),
    .fwm_rdata_i (sub_sram_rdata[IoModeFw]),
    .fwm_rerror_i(sub_sram_rerror[IoModeFw]),

    // Input from S2P
    .rx_data_valid_i(s2p_data_valid),
    .rx_data_i      (s2p_data),

    // Output to S2P (mode select)
    .io_mode_o(sub_iomode[IoModeFw]),

    // P2S
    .tx_wvalid_o(sub_p2s_valid[IoModeFw]),
    .tx_data_o  (sub_p2s_data[IoModeFw]),
    .tx_wready_i(sub_p2s_sent[IoModeFw]),

    // CSRs
    .timer_v_i   (timer_v),
    .sram_rxf_bindex_i (sram_rxf_bindex),
    .sram_txf_bindex_i (sram_txf_bindex),
    .sram_rxf_lindex_i (sram_rxf_lindex),
    .sram_txf_lindex_i (sram_txf_lindex),

    .abort_i(abort),

    .sram_rxf_rptr_i (sram_rxf_rptr),
    .sram_rxf_wptr_o (sram_rxf_wptr),
    .sram_txf_rptr_o (sram_txf_rptr),
    .sram_txf_wptr_i (sram_txf_wptr),
    .sram_rxf_depth_o(sram_rxf_depth),
    .sram_txf_depth_o(sram_txf_depth),
    .sram_rxf_full_o (sram_rxf_full),

    .as_txfifo_depth_o(as_txfifo_depth),
    .as_rxfifo_depth_o(as_rxfifo_depth),

    .rxf_empty_o(rxf_empty),
    .rxf_full_o (rxf_full),
    .txf_empty_o(txf_empty),
    .txf_full_o (txf_full)

  );

  ////////////////////
  // SPI Flash Mode //
  ////////////////////

  spi_cmdparse u_cmdparse (
    .clk_i (clk_spi_in_buf),
    .rst_ni(rst_spi_n),

    .data_valid_i(s2p_data_valid),
    .data_i      (s2p_data),

    .spi_mode_i(spi_mode),

    .upload_mask_i(cfg_upload_mask),

    .cmd_info_i(cmd_info),

    .io_mode_o(sub_iomode[IoModeCmdParse]),

    .sel_dp_o      (cmd_dp_sel),
    .cmd_info_o    (cmd_info_broadcast),
    .cmd_info_idx_o(cmd_info_idx_broadcast),

    // Not used for now
    .cmd_config_req_o(),
    .cmd_config_idx_o()
  );

  spi_readcmd u_readcmd (
    .clk_i (clk_spi_in_buf),
    .rst_ni(rst_spi_n),

    .clk_out_i(clk_spi_out_buf),

    .sys_rst_ni(rst_ni),

    .sel_dp_i(cmd_dp_sel),

    // SRAM interface
    .sram_req_o   (sub_sram_req[IoModeReadCmd]),
    .sram_we_o    (sub_sram_write[IoModeReadCmd]),
    .sram_addr_o  (sub_sram_addr[IoModeReadCmd]),
    .sram_wdata_o (sub_sram_wdata[IoModeReadCmd]),
    .sram_rvalid_i(sub_sram_rvalid[IoModeReadCmd]),
    .sram_rdata_i (sub_sram_rdata[IoModeReadCmd]),
    .sram_rerror_i(sub_sram_rerror[IoModeReadCmd]),

    // S2P
    .s2p_valid_i (s2p_data_valid),
    .s2p_byte_i  (s2p_data),
    .s2p_bitcnt_i(s2p_bitcnt),

    // P2S
    .p2s_valid_o(sub_p2s_valid[IoModeReadCmd]),
    .p2s_byte_o (sub_p2s_data[IoModeReadCmd]),
    .p2s_sent_i (sub_p2s_sent[IoModeReadCmd]),

    .spi_mode_i(spi_mode),

    .cmd_info_i    (cmd_info_broadcast),
    .cmd_info_idx_i(cmd_info_idx_broadcast),

    .readbuf_threshold_i(&#39;0),  //$clog2(ReadBufferDepth)-1

    .addr_4b_en_i(cfg_addr_4b_en),

    .mailbox_en_i     (1&#39;b0),
    .mailbox_addr_i   (&#39;0),  // 32
    .mailbox_assumed_o(mailbox_assumed),

    .readbuf_address_o(readbuf_addr_sck),

    .io_mode_o(sub_iomode[IoModeReadCmd]),

    .read_watermark_o()
  );

  // Begin: Read Status ==============================================
  logic readstatus_qe;
  logic [23:0] readstatus_q;
  logic [23:0] readstatus_d;

  assign readstatus_qe = reg2hw.flash_status.busy.qe &amp;&amp; reg2hw.flash_status.status.qe;
  assign readstatus_q = {reg2hw.flash_status.status.q, reg2hw.flash_status.busy.q};
  assign hw2reg.flash_status.busy.d = readstatus_d[0];
  assign hw2reg.flash_status.status.d = readstatus_d[23:1];

  spid_status u_spid_status (
    .clk_i (clk_spi_in_buf),
    .rst_ni(rst_spi_n),

    .clk_out_i(clk_spi_out_buf),

    .sys_clk_i (clk_i),
    .sys_rst_ni(rst_ni),

    .csb_i(cio_csb_i),

    .sys_status_we_i(readstatus_qe),
    .sys_status_i   (readstatus_q),
    .sys_status_o   (readstatus_d),

    .sel_dp_i      (cmd_dp_sel),
    .cmd_info_i    (cmd_info_broadcast),
    .cmd_info_idx_i(cmd_info_idx_broadcast),

    .outclk_p2s_valid_o(sub_p2s_valid[IoModeStatus]),
    .outclk_p2s_byte_o (sub_p2s_data[IoModeStatus]),
    .outclk_p2s_sent_i (sub_p2s_sent[IoModeStatus]),

    .io_mode_o(sub_iomode[IoModeStatus]),

    .inclk_busy_set_i(status_busy_set),  // SCK domain

    .inclk_busy_broadcast_o(status_busy_broadcast)  // SCK domain
  );

  // Temporary:
  logic unused_busy;
  assign unused_busy = status_busy_broadcast;
  // TODO: replace to the output of upload module
  assign status_busy_set = 1&#39;b0;

  // Tie unused
  logic unused_sub_sram_status;
  assign unused_sub_sram_status = ^{
    sub_sram_req[IoModeStatus],
    sub_sram_write[IoModeStatus],
    sub_sram_addr[IoModeStatus],
    sub_sram_wdata[IoModeStatus],
    sub_sram_rvalid[IoModeStatus],
    sub_sram_rdata[IoModeStatus],
    sub_sram_rerror[IoModeStatus]
  };
  assign sub_sram_req[IoModeStatus] = 1&#39;b0;
  assign sub_sram_write[IoModeStatus] = 1&#39;b0;
  assign sub_sram_addr[IoModeStatus] = &#39;0;
  assign sub_sram_wdata[IoModeStatus] = &#39;0;

  // End: Read Status ------------------------------------------------

  spid_jedec u_jedec (
    .clk_i (clk_spi_in_buf),
    .rst_ni(rst_spi_n),

    .clk_out_i(clk_spi_out_buf),

    .inclk_csb_asserted_pulse_i(csb_asserted_pulse_sckin),

    .sys_jedec_i(jedec_id),

    .io_mode_o(sub_iomode[IoModeJedec]),

    .sel_dp_i      (cmd_dp_sel),
    .cmd_info_i    (cmd_info_broadcast),
    .cmd_info_idx_i(cmd_info_idx_broadcast),

    .outclk_p2s_valid_o(sub_p2s_valid[IoModeJedec]),
    .outclk_p2s_byte_o (sub_p2s_data[IoModeJedec]),
    .outclk_p2s_sent_i (sub_p2s_sent[IoModeJedec])
  );
  // Tie unused
  logic unused_sub_sram_jedec;
  assign unused_sub_sram_jedec = ^{
    sub_sram_req[IoModeJedec],
    sub_sram_write[IoModeJedec],
    sub_sram_addr[IoModeJedec],
    sub_sram_wdata[IoModeJedec],
    sub_sram_rvalid[IoModeJedec],
    sub_sram_rdata[IoModeJedec],
    sub_sram_rerror[IoModeJedec]
  };
  assign sub_sram_req[IoModeJedec] = 1&#39;b0;
  assign sub_sram_write[IoModeJedec] = 1&#39;b0;
  assign sub_sram_addr[IoModeJedec] = &#39;0;
  assign sub_sram_wdata[IoModeJedec] = &#39;0;

  /////////////////////
  // SPI Passthrough //
  /////////////////////
  spi_passthrough #(
    .NumCmdInfo(spi_device_reg_pkg::NumCmdInfo)
  ) u_passthrough (
    .clk_i    (clk_spi_in_buf),
    .rst_ni   (rst_spi_n),
    .clk_out_i(clk_spi_out_buf),

    // Configurations
    .cfg_cmd_filter_i(cmd_filter),  //TODO

    .cfg_addr_mask_i (addr_swap_mask),  // TODO
    .cfg_addr_value_i(addr_swap_data),  // TODO

    .cfg_addr_4b_en_i(cfg_addr_4b_en),

    .cmd_info_i(cmd_info),

    .spi_mode_i(spi_mode),

    // Host SPI
    .host_sck_i (cio_sck_i),
    .host_csb_i (cio_csb_i),
    .host_s_i   (cio_sd_i),
    .host_s_o   (passthrough_sd),
    .host_s_en_o(passthrough_sd_en),

    // Passthrough to SPI_HOST HWIP
    .passthrough_o,
    .passthrough_i,

    .mailbox_hit_i(1&#39;b0),

    .event_cmd_filtered_o()
  );

  ////////////////////
  // Common modules //
  ////////////////////

  tlul_adapter_sram #(
    .SramAw     (SramAw),
    .SramDw     (SramDw),
    .Outstanding(1),
    .ByteAccess (0)
  ) u_tlul2sram (
    .clk_i,
    .rst_ni,

    .tl_i        (tl_sram_h2d),
    .tl_o        (tl_sram_d2h),
    .en_ifetch_i (tlul_pkg::InstrDis),
    .req_o       (mem_a_req),
    .req_type_o  (),
    .gnt_i       (mem_a_req),  //Always grant when request
    .we_o        (mem_a_write),
    .addr_o      (mem_a_addr),
    .wdata_o     (mem_a_wdata),
    .wmask_o     (),  // Not used
    .intg_error_o(),
    .rdata_i     (mem_a_rdata),
    .rvalid_i    (mem_a_rvalid),
    .rerror_i    (mem_a_rerror)
  );

  // SRAM Wrapper
  prim_ram_2p_async_adv #(
    .Depth(SramDepth),
    .Width(SramDw),  // 32 x 512 --&gt; 2kB
    .DataBitsPerMask(8),

    .EnableECC           (0),
    .EnableParity        (1),
    .EnableInputPipeline (0),
    .EnableOutputPipeline(0)
  ) u_memory_2p (
    .clk_a_i (clk_i),
    .rst_a_ni(rst_ni),

    .clk_b_i (sram_clk),
    .rst_b_ni(sram_rst_n),

    .a_req_i   (mem_a_req),
    .a_write_i (mem_a_write),
    .a_addr_i  (mem_a_addr),
    .a_wdata_i (mem_a_wdata),
    .a_wmask_i ({SramDw{1&#39;b1}}),
    .a_rvalid_o(mem_a_rvalid),
    .a_rdata_o (mem_a_rdata),
    .a_rerror_o(mem_a_rerror),

    .b_req_i   (mem_b_req),
    .b_write_i (mem_b_write),
    .b_addr_i  (mem_b_addr),
    .b_wdata_i (mem_b_wdata),
    .b_wmask_i ({SramDw{1&#39;b1}}),
    .b_rvalid_o(mem_b_rvalid),
    .b_rdata_o (mem_b_rdata),
    .b_rerror_o(mem_b_rerror),

    .cfg_i(ram_cfg_i)
  );

  // Register module
  logic [NumAlerts-1:0] alert_test, alerts;
  spi_device_reg_top u_reg (
    .clk_i,
    .rst_ni,

    .tl_i(tl_i),
    .tl_o(tl_o),

    .tl_win_o(tl_sram_h2d),
    .tl_win_i(tl_sram_d2h),

    .reg2hw,
    .hw2reg,

    .intg_err_o(alerts[0]),
    .devmode_i (1&#39;b1)
  );

  // Alerts
  assign alert_test = {reg2hw.alert_test.q &amp; reg2hw.alert_test.qe};

  for (genvar i = 0; i &lt; NumAlerts; i++) begin : gen_alert_tx
    prim_alert_sender #(
      .AsyncOn(AlertAsyncOn[i]),
      .IsFatal(1&#39;b1)
    ) u_prim_alert_sender (
      .clk_i,
      .rst_ni,
      .alert_test_i (alert_test[i]),
      .alert_req_i  (alerts[0]),
      .alert_ack_o  (),
      .alert_state_o(),
      .alert_rx_i   (alert_rx_i[i]),
      .alert_tx_o   (alert_tx_o[i])
    );
  end

  // make sure scanmode_i is never X (including during reset)
  `ASSERT_KNOWN(scanmodeKnown, scanmode_i, clk_i, 0)
  `ASSERT_KNOWN(CioSdoEnOKnown, cio_sd_en_o)

  `ASSERT_KNOWN(IntrRxfOKnown, intr_rxf_o)
  `ASSERT_KNOWN(IntrRxlvlOKnown, intr_rxlvl_o)
  `ASSERT_KNOWN(IntrTxlvlOKnown, intr_txlvl_o)
  `ASSERT_KNOWN(IntrRxerrOKnown, intr_rxerr_o)
  `ASSERT_KNOWN(IntrRxoverflowOKnown, intr_rxoverflow_o)
  `ASSERT_KNOWN(IntrTxunderflowOKnown, intr_txunderflow_o)

  `ASSERT_KNOWN(AlertKnownO_A, alert_tx_o)

endmodule
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-uart-dv-env-seq-lib-uart-base-vseq-sv">
<span id="error-hw-ip-uart-dv-env-seq-lib-uart-base-vseq-sv"></span><h2>hw/ip/uart/dv/env/seq_lib/uart_base_vseq.sv<a class="headerlink" href="#hw-ip-uart-dv-env-seq-lib-uart-base-vseq-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/uart/dv/env/seq_lib/uart_base_vseq.sv: Formatted output is lexically different from the input.    Please file a bug.  Details:
Mismatched token enums.  got: (&#39;)&#39;) (#41: &quot;)&quot;) vs. (MacroCallCloseToEndLine) (#746: &quot;)&quot;)
First mismatched token [150]: (&#39;)&#39;) (#41: &quot;)&quot;) vs. (MacroCallCloseToEndLine) (#746: &quot;)&quot;)
; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class uart_base_vseq extends cip_base_vseq #(
  .CFG_T              (uart_env_cfg),
  .RAL_T              (uart_reg_block),
  .COV_T              (uart_env_cov),
  .VIRTUAL_SEQUENCER_T(uart_virtual_sequencer)
);
  `uvm_object_utils(uart_base_vseq)

  // variables for dut initialization
  rand baud_rate_e           baud_rate;  // set baud rate
  rand bit                   en_tx;  // enable tx
  rand bit                   en_rx;  // enable rx
  rand bit                   en_parity;  // enable parity
  rand bit                   odd_parity;  // enable odd parity
  rand bit                   en_noise_filter;  // enable noise filter

  // glitch control
  rand uint                  uart_period_glitch_pct;

  // enable interrupts
  rand bit [NumUartIntr-1:0] en_intr;

  // random delays to access fifo/intr, may be controlled in extended seq
  rand uint                  dly_to_access_fifo;

  // various knobs to enable certain routines
  bit                        do_interrupt            = 1&#39;b1;

  constraint uart_period_glitch_pct_c {uart_period_glitch_pct inside {[0 : 10]};}

  constraint baud_rate_c {
    // when the uart frequency is very close to core freq, disable noise filter and glitch,
    // otherwise, not enough timing margin to predict status correctly in scb
    if (baud_rate == BaudRate1p5Mbps &amp;&amp; p_sequencer.cfg.clk_freq_mhz == ClkFreq24Mhz) {
      en_noise_filter == 0;
      uart_period_glitch_pct == 0;
    }
    // constrain nco not over nco.get_n_bits
    `CALC_NCO(baud_rate, p_sequencer.cfg.ral.ctrl.nco.get_n_bits(), p_sequencer.cfg.clk_freq_mhz)
    &lt; 2 ** p_sequencer.cfg.ral.ctrl.nco.get_n_bits();
  }

  constraint dly_to_access_fifo_c {
    // uart clk is slow, up to 2 ** 16 (65_536) slower than pclk
    // 1_000_000 is about 1.5 * 65_536
    dly_to_access_fifo dist {
      0                    :/ 1,
      [1 : 100]            :/ 1,
      [101 : 10_000]       :/ 8,
      [10_001 : 1_000_000] :/ 1
    };
  }

  `uvm_object_new

  virtual task dut_shutdown();
    super.dut_shutdown();
    // wait for tx and rx operations to complete
    `uvm_info(`gfn, &quot;waiting for idle&quot;, UVM_HIGH)
    cfg.m_uart_agent_cfg.vif.wait_for_idle();
    `uvm_info(`gfn, &quot;done waiting for idle&quot;, UVM_HIGH)
  endtask

  // setup basic uart features
  virtual task uart_init();
    int nco = get_nco(baud_rate, cfg.clk_freq_mhz, ral.ctrl.nco.get_n_bits());

    // we skip writting some CSRs at the last 1-2 uart cycles, when baud rate is 1.5Mbps, uart
    // cycle is small, need to reduce the TL delay, so that the write doesn&#39;t happen at the
    // ignore period
    if (baud_rate == BaudRate1p5Mbps &amp;&amp; p_sequencer.cfg.clk_freq_mhz == ClkFreq24Mhz) begin
      if (cfg.m_tl_agent_cfg.d_ready_delay_max &gt; 5) cfg.m_tl_agent_cfg.d_ready_delay_max = 5;
    end

    cfg.m_uart_agent_cfg.set_uart_period_glitch_pct(uart_period_glitch_pct);

    // cfg uart agent to set the baud rate &amp; parity
    cfg.m_uart_agent_cfg.set_baud_rate(baud_rate);
    cfg.m_uart_agent_cfg.set_parity(en_parity, odd_parity);
    ral.ctrl.tx.set(en_tx);
    ral.ctrl.rx.set(en_rx);
    ral.ctrl.nf.set(en_noise_filter);
    ral.ctrl.parity_en.set(en_parity);
    ral.ctrl.parity_odd.set(odd_parity);
    if (do_interrupt) `DV_CHECK_RANDOMIZE_FATAL(ral.ctrl.rxblvl)
    ral.ctrl.nco.set(nco);
    csr_update(ral.ctrl);

    if (do_interrupt) begin
      ral.intr_enable.set(en_intr);
      csr_update(ral.intr_enable);

      // from spec - timeout value may be reduced by 1.5 clock periods at some corner cases
      // need &gt;= char time + 2, so that receiving next character can reset the counter
      // before timer is expired
      `DV_CHECK_RANDOMIZE_WITH_FATAL(ral.timeout_ctrl.val,
                                     value inside {[10 + en_parity + 2 : 100]};)
      `DV_CHECK_RANDOMIZE_FATAL(ral.timeout_ctrl.en)
      csr_update(ral.timeout_ctrl);

      `DV_CHECK_RANDOMIZE_WITH_FATAL(ral.fifo_ctrl.rxilvl, value &lt;= 4;)
      `DV_CHECK_RANDOMIZE_FATAL(ral.fifo_ctrl.txilvl)
      csr_update(ral.fifo_ctrl);
    end
  endtask

  // clear fifos
  virtual task clear_fifos(bit clear_tx_fifo, bit clear_rx_fifo);
    ral.fifo_ctrl.rxrst.set(clear_rx_fifo);
    ral.fifo_ctrl.txrst.set(clear_tx_fifo);
    csr_update(ral.fifo_ctrl);
  endtask

  // set uart parity for the dut and the agent
  virtual task set_parity(bit en_parity, bit odd_parity);
    // cfg uart dut
    ral.ctrl.parity_en.set(en_parity);
    ral.ctrl.parity_odd.set(odd_parity);
    csr_update(ral.ctrl);
    // cfg uart agent
    cfg.m_uart_agent_cfg.set_parity(en_parity, odd_parity);
  endtask

  // set uart baud rate for the dut and the agent
  virtual task set_baud_rate(baud_rate_e baud_rate);
    int nco = get_nco(baud_rate, cfg.clk_freq_mhz, ral.ctrl.nco.get_n_bits());
    ral.ctrl.nco.set(nco);
    csr_update(ral.ctrl);
    // cfg uart agent
    cfg.m_uart_agent_cfg.set_baud_rate(baud_rate);
  endtask

  virtual task spinwait_txidle();
    if (ral.ctrl.tx.get_mirrored_value()) begin
      // use a very big timeout as it takes long time to flush all the items
      csr_spinwait(.ptr(ral.status.txidle), .exp_data(1&#39;b1), .timeout_ns(40_000_000),
                   .spinwait_delay_ns($urandom_range(0, 1000)));
    end
  endtask

  virtual task spinwait_rxidle();
    if (ral.ctrl.rx.get_mirrored_value()) begin
      csr_spinwait(.ptr(ral.status.rxidle), .exp_data(1&#39;b1),
                   .spinwait_delay_ns($urandom_range(0, 1000)));
    end
  endtask

  // task to send a byte of data out of dut
  virtual task send_tx_byte(byte data);
    csr_wr(.ptr(ral.wdata), .value(data));
  endtask

  // task to send a byte of data into dut, can override it to test error cases
  virtual task send_rx_byte(byte data);
    drive_rx_error_byte(.parity_err(0), .frame_err(0), .data(data));
  endtask

  // drive rx byte with parity_err or frame_err, data is random
  virtual task drive_rx_error_byte(bit parity_err, bit frame_err, byte data = $urandom);
    uart_seq send_rx_seq;
    `uvm_create_on(send_rx_seq, p_sequencer.uart_sequencer_h);
    `DV_CHECK_RANDOMIZE_WITH_FATAL(send_rx_seq,
                                   data == local::data;
                                   parity_err == local::parity_err;
                                   frame_err  == local::frame_err;)
    `uvm_send(send_rx_seq)
  endtask : drive_rx_error_byte

  // task to check if byte received is what was sent by the agent
  virtual task chk_rx_byte(logic [7:0] exp_data);
    bit [TL_DW-1:0] rdata;
    csr_rd(.ptr(ral.rdata), .value(rdata));
    // do check but only if rx is enabled
    if (ral.ctrl.rx.get_mirrored_value()) begin
      if (!cfg.under_reset) `DV_CHECK_EQ(rdata, exp_data)
    end
  endtask

  // task to read all the rx bytes
  virtual task read_all_rx_bytes();
    bit [TL_DW-1:0] rdata, fifo_status;

    csr_rd(.ptr(ral.fifo_status), .value(fifo_status));
    repeat (get_field_val(
        ral.fifo_status.rxlvl, fifo_status
    )) begin
      wait_ignored_period_and_read_rdata(rdata);
    end

    csr_rd(.ptr(ral.fifo_status), .value(fifo_status));

    `uvm_info(`gfn, &quot;read_all_rx_bytes is done&quot;, UVM_HIGH)
  endtask : read_all_rx_bytes

  // override this function to control RX fifo level
  virtual task rand_read_rx_byte(uint weight_to_skip);
    bit [TL_DW-1:0] rdata, fifo_status;
    int rxlvl;

    randcase
      1: begin  // read &amp; check one byte
        csr_rd(.ptr(ral.fifo_status), .value(fifo_status));
        rxlvl = get_field_val(ral.fifo_status.rxlvl, fifo_status);
        if (rxlvl &gt; 0) begin
          wait_ignored_period_and_read_rdata(rdata);
        end
      end
      1: begin  // read &amp; check some bytes
        csr_rd(.ptr(ral.fifo_status), .value(fifo_status));
        rxlvl = get_field_val(ral.fifo_status.rxlvl, fifo_status);
        if (rxlvl &gt; 0) begin
          repeat ($urandom_range(1, rxlvl)) wait_ignored_period_and_read_rdata(rdata);
        end
      end
      1: begin  // read &amp; check all rx bytes
        read_all_rx_bytes();
      end
      weight_to_skip: begin
      end
    endcase
  endtask : rand_read_rx_byte

  // read rx data from CSR rdata, but wait until it&#39;s not in igored period
  virtual task wait_ignored_period_and_read_rdata(ref bit [TL_DW-1:0] rdata);
    wait_when_in_ignored_period(.rx(1));
    csr_rd(.ptr(ral.rdata), .value(rdata));
  endtask

  // task to wait for all rx bytes to be sent
  virtual task wait_for_all_tx_bytes();
    bit [TL_DW-1:0] fifo_status, status;

    if (ral.ctrl.tx.get_mirrored_value()) begin
      do begin
        if (cfg.under_reset) break;
        `DV_CHECK_MEMBER_RANDOMIZE_FATAL(dly_to_access_fifo)
        cfg.clk_rst_vif.wait_clks(dly_to_access_fifo);
        csr_rd(.ptr(ral.fifo_status), .value(fifo_status));
        csr_rd(.ptr(ral.status), .value(status));
      end while (get_field_val(
          ral.fifo_status.txlvl, fifo_status
      ) &gt; 0 || get_field_val(
          ral.status.txidle, status
      ) == 0);
    end

    `uvm_info(`gfn, &quot;wait_for_all_tx_bytes is done&quot;, UVM_HIGH)
  endtask : wait_for_all_tx_bytes

  // task to wait for tx fifo not full
  virtual task wait_for_tx_fifo_not_full();
    bit [TL_DW-1:0] status;

    if (ral.ctrl.tx.get_mirrored_value()) begin
      `DV_CHECK_MEMBER_RANDOMIZE_FATAL(dly_to_access_fifo)
      csr_spinwait(.ptr(ral.status.txfull), .exp_data(1&#39;b0),
                   .spinwait_delay_ns(dly_to_access_fifo));
    end

    `uvm_info(`gfn, &quot;wait_for_tx_fifo_not_full is done&quot;, UVM_HIGH)
  endtask : wait_for_tx_fifo_not_full

  // task to wait for rx fifo not full, will be overriden in overflow test
  virtual task wait_for_rx_fifo_not_full();
    if (ral.ctrl.rx.get_mirrored_value()) begin
      `DV_CHECK_MEMBER_RANDOMIZE_FATAL(dly_to_access_fifo)
      csr_spinwait(.ptr(ral.status.rxfull), .exp_data(1&#39;b0), .spinwait_delay_ns(dly_to_access_fifo),
                   .timeout_ns(50_000_000));  // use longer timeout as uart freq is low
    end
    `uvm_info(`gfn, &quot;wait_for_rx_fifo_not_full is done&quot;, UVM_HIGH)
  endtask : wait_for_rx_fifo_not_full

  // in some corner cases, we can&#39;t drive when the uart item is almost done
  // wait for this period to pass
  virtual task wait_when_in_ignored_period(bit tx = 0, bit rx = 0);
    wait (!(
        (tx &amp;&amp; cfg.m_uart_agent_cfg.vif.uart_tx_clk_pulses inside `TX_IGNORED_PERIOD) ||
        (rx &amp;&amp; cfg.m_uart_agent_cfg.vif.uart_rx_clk_pulses inside `RX_IGNORED_PERIOD)
      ));
    `uvm_info(`gfn, &quot;wait_when_in_ignored_period is done&quot;, UVM_HIGH)
  endtask : wait_when_in_ignored_period

endclass : uart_base_vseq
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-pinmux-rtl-pinmux-wkup-sv">
<span id="error-hw-ip-pinmux-rtl-pinmux-wkup-sv"></span><h2>hw/ip/pinmux/rtl/pinmux_wkup.sv<a class="headerlink" href="#hw-ip-pinmux-rtl-pinmux-wkup-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/pinmux/rtl/pinmux_wkup.sv: Re-formatted text does not match formatted text; formatting failed to converge!  Please file a bug.
Original: --lines:
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
module pinmux_wkup import pinmux_pkg::*; import pinmux_reg_pkg::*; #(
  parameter int Cycles = 4
) (
  input                    clk_i,
  input                    rst_ni,
  // Always on clock / reset
  input                    clk_aon_i,
  input                    rst_aon_ni,
  // These signals get synchronized to the
  // slow AON clock within this module.
  // Note that wkup_en_i is assumed to be level encoded.
  input                    wkup_en_i,
  input                    filter_en_i,
  input wkup_mode_e        wkup_mode_i,
  input [WkupCntWidth-1:0] wkup_cnt_th_i,
  input                    pin_value_i,
  // Signals to/from cause register.
  // They are synched to/from the AON clock internally
  input                    wkup_cause_valid_i,
  input                    wkup_cause_data_i,
  output                   wkup_cause_data_o,
  // This signal is running on the AON clock
  // and is held high as long as the cause register
  // has not been cleared.
  output logic             aon_wkup_req_o
);

  ///////////////////////////
  // Input Synchronization //
  ///////////////////////////

  // Synchronize configuration to slow clock
  wkup_mode_e aon_wkup_mode_q;
  logic aon_filter_en_q;
  logic aon_wkup_en_d, aon_wkup_en_q;
  logic [WkupCntWidth-1:0] aon_wkup_cnt_th_q;

  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_config (
    .clk_i  ( clk_aon_i      ),
    .rst_ni ( rst_aon_ni     ),
    .d_i    ( wkup_en_i     ),
    .q_o    ( aon_wkup_en_d )
  );

  always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_sync
    if (!rst_aon_ni) begin
      aon_wkup_en_q     &lt;= 1&#39;b0;
      aon_wkup_mode_q   &lt;= Posedge;
      aon_filter_en_q   &lt;= 1&#39;b0;
      aon_wkup_cnt_th_q &lt;= &#39;0;
    end else begin
      aon_wkup_en_q &lt;= aon_wkup_en_d;
      // latch these when going into sleep. note that these
      // config signals should be stable at this point, since
      // SW has configured them many cycles ago. hence no
      // explicit multibit consistency check is performed.
      if (aon_wkup_en_d &amp; !aon_wkup_en_q) begin
        aon_wkup_mode_q   &lt;= wkup_mode_i;
        aon_filter_en_q   &lt;= filter_en_i;
        aon_wkup_cnt_th_q &lt;= wkup_cnt_th_i;
      end
    end
  end

  ////////////////////////////
  // Optional Signal Filter //
  ////////////////////////////

  // This uses a lower value for filtering than GPIO since
  // the always-on clock is slower. This can be disabled,
  // in which case the signal is just combinationally bypassed.
  logic aon_filter_out, aon_filter_out_d, aon_filter_out_q;
  prim_filter #(
    .Cycles(Cycles)
  ) i_prim_filter (
    .clk_i    ( clk_aon_i       ),
    .rst_ni   ( rst_aon_ni      ),
    .enable_i ( aon_filter_en_q ),
    .filter_i ( pin_value_i     ),
    .filter_o ( aon_filter_out  )
  );

  // Run this through a 2 stage synchronizer to
  // prevent metastability.
  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_filter (
    .clk_i  ( clk_aon_i  ),
    .rst_ni ( rst_aon_ni ),
    .d_i    ( aon_filter_out ),
    .q_o    ( aon_filter_out_d )
  );

  //////////////////////
  // Pattern Matching //
  //////////////////////

  logic aon_rising, aon_falling;
  assign aon_falling = ~aon_filter_out_d &amp;  aon_filter_out_q;
  assign aon_rising  =  aon_filter_out_d &amp; ~aon_filter_out_q;

  logic aon_cnt_en, aon_cnt_eq_th;
  logic [WkupCntWidth-1:0] aon_cnt_d, aon_cnt_q;
  assign aon_cnt_d = (aon_cnt_eq_th) ? &#39;0                :
                     (aon_cnt_en)    ?  aon_cnt_q + 1&#39;b1 : &#39;0;

  assign aon_cnt_eq_th = aon_cnt_q == aon_wkup_cnt_th_q;

  logic aon_wkup_pulse;
  always_comb begin : p_mode
    aon_wkup_pulse = 1&#39;b0;
    aon_cnt_en     = 1&#39;b0;
    if (aon_wkup_en_q) begin
      unique case (aon_wkup_mode_q)
        Negedge:   aon_wkup_pulse = aon_falling;
        Edge:      aon_wkup_pulse = aon_rising | aon_falling;
        HighTimed: begin
          aon_cnt_en = aon_filter_out_d;
          aon_wkup_pulse = aon_cnt_eq_th;
        end
        LowTimed: begin
          aon_cnt_en = ~aon_filter_out_d;
          aon_wkup_pulse = aon_cnt_eq_th;
        end
        // Default to rising
        default:   aon_wkup_pulse = aon_rising;
      endcase
    end
  end

  always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_aon_pattern
    if (!rst_aon_ni) begin
      aon_filter_out_q &lt;= 1&#39;b0;
      aon_cnt_q        &lt;= &#39;0;
    end else begin
      aon_filter_out_q &lt;= aon_filter_out_d;
      aon_cnt_q        &lt;= aon_cnt_d;
    end
  end

  ////////////////////
  // Cause register //
  ////////////////////

  // to AON domain
  logic aon_wkup_cause_valid, aon_wkup_cause_data;
  logic aon_wkup_cause_d, aon_wkup_cause_q;

  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_cause_in (
    .clk_i  ( clk_aon_i  ),
    .rst_ni ( rst_aon_ni ),
    .d_i    ( wkup_cause_data_i   ),
    .q_o    ( aon_wkup_cause_data )
  );

  prim_pulse_sync i_prim_pulse_sync_cause (
    .clk_src_i   ( clk_i                ),
    .rst_src_ni  ( rst_ni               ),
    .src_pulse_i ( wkup_cause_valid_i   ),
    .clk_dst_i   ( clk_aon_i            ),
    .rst_dst_ni  ( rst_aon_ni           ),
    .dst_pulse_o ( aon_wkup_cause_valid )
  );

  // note that aon_wkup_pulse will not be asserted when not in sleep mode
  assign aon_wkup_cause_d = (aon_wkup_cause_valid) ? aon_wkup_cause_q &amp; aon_wkup_cause_data :
                                                     aon_wkup_cause_q | aon_wkup_pulse;

  // output to power manager
  assign aon_wkup_req_o = aon_wkup_cause_q;

  // output to CSR
  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_cause_out (
    .clk_i,
    .rst_ni,
    .d_i    ( aon_wkup_cause_q  ),
    .q_o    ( wkup_cause_data_o )
  );

  always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_aon_cause
    if (!rst_aon_ni) begin
      aon_wkup_cause_q &lt;= 1&#39;b0;
    end else begin
      aon_wkup_cause_q &lt;= aon_wkup_cause_d;
    end
  end

endmodule : pinmux_wkup
Formatted:
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
module pinmux_wkup
  import pinmux_pkg::*;
  import pinmux_reg_pkg::*;
#(
  parameter int Cycles = 4
) (
  input                                 clk_i,
  input                                 rst_ni,
  // Always on clock / reset
  input                                 clk_aon_i,
  input                                 rst_aon_ni,
  // These signals get synchronized to the
  // slow AON clock within this module.
  // Note that wkup_en_i is assumed to be level encoded.
  input                                 wkup_en_i,
  input                                 filter_en_i,
  input  wkup_mode_e                    wkup_mode_i,
  input              [WkupCntWidth-1:0] wkup_cnt_th_i,
  input                                 pin_value_i,
  // Signals to/from cause register.
  // They are synched to/from the AON clock internally
  input                                 wkup_cause_valid_i,
  input                                 wkup_cause_data_i,
  output                                wkup_cause_data_o,
  // This signal is running on the AON clock
  // and is held high as long as the cause register
  // has not been cleared.
  output logic                          aon_wkup_req_o
);

  ///////////////////////////
  // Input Synchronization //
  ///////////////////////////

  // Synchronize configuration to slow clock
  wkup_mode_e aon_wkup_mode_q;
  logic aon_filter_en_q;
  logic aon_wkup_en_d, aon_wkup_en_q;
  logic [WkupCntWidth-1:0] aon_wkup_cnt_th_q;

  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_config (
    .clk_i (clk_aon_i),
    .rst_ni(rst_aon_ni),
    .d_i   (wkup_en_i),
    .q_o   (aon_wkup_en_d)
  );

  always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_sync
    if (!rst_aon_ni) begin
      aon_wkup_en_q     &lt;= 1&#39;b0;
      aon_wkup_mode_q   &lt;= Posedge;
      aon_filter_en_q   &lt;= 1&#39;b0;
      aon_wkup_cnt_th_q &lt;= &#39;0;
    end else begin
      aon_wkup_en_q &lt;= aon_wkup_en_d;
      // latch these when going into sleep. note that these
      // config signals should be stable at this point, since
      // SW has configured them many cycles ago. hence no
      // explicit multibit consistency check is performed.
      if (aon_wkup_en_d &amp; !aon_wkup_en_q) begin
        aon_wkup_mode_q   &lt;= wkup_mode_i;
        aon_filter_en_q   &lt;= filter_en_i;
        aon_wkup_cnt_th_q &lt;= wkup_cnt_th_i;
      end
    end
  end

  ////////////////////////////
  // Optional Signal Filter //
  ////////////////////////////

  // This uses a lower value for filtering than GPIO since
  // the always-on clock is slower. This can be disabled,
  // in which case the signal is just combinationally bypassed.
  logic aon_filter_out, aon_filter_out_d, aon_filter_out_q;
  prim_filter #(
    .Cycles(Cycles)
  ) i_prim_filter (
    .clk_i   (clk_aon_i),
    .rst_ni  (rst_aon_ni),
    .enable_i(aon_filter_en_q),
    .filter_i(pin_value_i),
    .filter_o(aon_filter_out)
  );

  // Run this through a 2 stage synchronizer to
  // prevent metastability.
  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_filter (
    .clk_i (clk_aon_i),
    .rst_ni(rst_aon_ni),
    .d_i   (aon_filter_out),
    .q_o   (aon_filter_out_d)
  );

  //////////////////////
  // Pattern Matching //
  //////////////////////

  logic aon_rising, aon_falling;
  assign aon_falling = ~aon_filter_out_d &amp; aon_filter_out_q;
  assign aon_rising  = aon_filter_out_d &amp; ~aon_filter_out_q;

  logic aon_cnt_en, aon_cnt_eq_th;
  logic [WkupCntWidth-1:0] aon_cnt_d, aon_cnt_q;
  assign aon_cnt_d     = (aon_cnt_eq_th) ? &#39;0 : (aon_cnt_en) ? aon_cnt_q + 1&#39;b1 : &#39;0;

  assign aon_cnt_eq_th = aon_cnt_q == aon_wkup_cnt_th_q;

  logic aon_wkup_pulse;
  always_comb begin : p_mode
    aon_wkup_pulse = 1&#39;b0;
    aon_cnt_en     = 1&#39;b0;
    if (aon_wkup_en_q) begin
      unique case (aon_wkup_mode_q)
        Negedge: aon_wkup_pulse = aon_falling;
        Edge:    aon_wkup_pulse = aon_rising | aon_falling;
        HighTimed: begin
          aon_cnt_en = aon_filter_out_d;
          aon_wkup_pulse = aon_cnt_eq_th;
        end
        LowTimed: begin
          aon_cnt_en = ~aon_filter_out_d;
          aon_wkup_pulse = aon_cnt_eq_th;
        end
        // Default to rising
        default: aon_wkup_pulse = aon_rising;
      endcase
    end
  end

  always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_aon_pattern
    if (!rst_aon_ni) begin
      aon_filter_out_q &lt;= 1&#39;b0;
      aon_cnt_q        &lt;= &#39;0;
    end else begin
      aon_filter_out_q &lt;= aon_filter_out_d;
      aon_cnt_q        &lt;= aon_cnt_d;
    end
  end

  ////////////////////
  // Cause register //
  ////////////////////

  // to AON domain
  logic aon_wkup_cause_valid, aon_wkup_cause_data;
  logic aon_wkup_cause_d, aon_wkup_cause_q;

  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_cause_in (
    .clk_i (clk_aon_i),
    .rst_ni(rst_aon_ni),
    .d_i   (wkup_cause_data_i),
    .q_o   (aon_wkup_cause_data)
  );

  prim_pulse_sync i_prim_pulse_sync_cause (
    .clk_src_i  (clk_i),
    .rst_src_ni (rst_ni),
    .src_pulse_i(wkup_cause_valid_i),
    .clk_dst_i  (clk_aon_i),
    .rst_dst_ni (rst_aon_ni),
    .dst_pulse_o(aon_wkup_cause_valid)
  );

  // note that aon_wkup_pulse will not be asserted when not in sleep mode
  assign aon_wkup_cause_d = (aon_wkup_cause_valid) ? aon_wkup_cause_q &amp; aon_wkup_cause_data :
                                                     aon_wkup_cause_q | aon_wkup_pulse;

  // output to power manager
  assign aon_wkup_req_o = aon_wkup_cause_q;

  // output to CSR
  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_cause_out (
    .clk_i,
    .rst_ni,
    .d_i(aon_wkup_cause_q),
    .q_o(wkup_cause_data_o)
  );

  always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_aon_cause
    if (!rst_aon_ni) begin
      aon_wkup_cause_q &lt;= 1&#39;b0;
    end else begin
      aon_wkup_cause_q &lt;= aon_wkup_cause_d;
    end
  end

endmodule : pinmux_wkup
Re-formatted:
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
module pinmux_wkup
  import pinmux_pkg::*;
  import pinmux_reg_pkg::*;
#(
  parameter int Cycles = 4
) (
  input                                 clk_i,
  input                                 rst_ni,
  // Always on clock / reset
  input                                 clk_aon_i,
  input                                 rst_aon_ni,
  // These signals get synchronized to the
  // slow AON clock within this module.
  // Note that wkup_en_i is assumed to be level encoded.
  input                                 wkup_en_i,
  input                                 filter_en_i,
  input  wkup_mode_e                    wkup_mode_i,
  input              [WkupCntWidth-1:0] wkup_cnt_th_i,
  input                                 pin_value_i,
  // Signals to/from cause register.
  // They are synched to/from the AON clock internally
  input                                 wkup_cause_valid_i,
  input                                 wkup_cause_data_i,
  output                                wkup_cause_data_o,
  // This signal is running on the AON clock
  // and is held high as long as the cause register
  // has not been cleared.
  output logic                          aon_wkup_req_o
);

  ///////////////////////////
  // Input Synchronization //
  ///////////////////////////

  // Synchronize configuration to slow clock
  wkup_mode_e aon_wkup_mode_q;
  logic aon_filter_en_q;
  logic aon_wkup_en_d, aon_wkup_en_q;
  logic [WkupCntWidth-1:0] aon_wkup_cnt_th_q;

  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_config (
    .clk_i (clk_aon_i),
    .rst_ni(rst_aon_ni),
    .d_i   (wkup_en_i),
    .q_o   (aon_wkup_en_d)
  );

  always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_sync
    if (!rst_aon_ni) begin
      aon_wkup_en_q     &lt;= 1&#39;b0;
      aon_wkup_mode_q   &lt;= Posedge;
      aon_filter_en_q   &lt;= 1&#39;b0;
      aon_wkup_cnt_th_q &lt;= &#39;0;
    end else begin
      aon_wkup_en_q &lt;= aon_wkup_en_d;
      // latch these when going into sleep. note that these
      // config signals should be stable at this point, since
      // SW has configured them many cycles ago. hence no
      // explicit multibit consistency check is performed.
      if (aon_wkup_en_d &amp; !aon_wkup_en_q) begin
        aon_wkup_mode_q   &lt;= wkup_mode_i;
        aon_filter_en_q   &lt;= filter_en_i;
        aon_wkup_cnt_th_q &lt;= wkup_cnt_th_i;
      end
    end
  end

  ////////////////////////////
  // Optional Signal Filter //
  ////////////////////////////

  // This uses a lower value for filtering than GPIO since
  // the always-on clock is slower. This can be disabled,
  // in which case the signal is just combinationally bypassed.
  logic aon_filter_out, aon_filter_out_d, aon_filter_out_q;
  prim_filter #(
    .Cycles(Cycles)
  ) i_prim_filter (
    .clk_i   (clk_aon_i),
    .rst_ni  (rst_aon_ni),
    .enable_i(aon_filter_en_q),
    .filter_i(pin_value_i),
    .filter_o(aon_filter_out)
  );

  // Run this through a 2 stage synchronizer to
  // prevent metastability.
  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_filter (
    .clk_i (clk_aon_i),
    .rst_ni(rst_aon_ni),
    .d_i   (aon_filter_out),
    .q_o   (aon_filter_out_d)
  );

  //////////////////////
  // Pattern Matching //
  //////////////////////

  logic aon_rising, aon_falling;
  assign aon_falling = ~aon_filter_out_d &amp; aon_filter_out_q;
  assign aon_rising  = aon_filter_out_d &amp; ~aon_filter_out_q;

  logic aon_cnt_en, aon_cnt_eq_th;
  logic [WkupCntWidth-1:0] aon_cnt_d, aon_cnt_q;
  assign aon_cnt_d     = (aon_cnt_eq_th) ? &#39;0 : (aon_cnt_en) ? aon_cnt_q + 1&#39;b1 : &#39;0;

  assign aon_cnt_eq_th = aon_cnt_q == aon_wkup_cnt_th_q;

  logic aon_wkup_pulse;
  always_comb begin : p_mode
    aon_wkup_pulse = 1&#39;b0;
    aon_cnt_en     = 1&#39;b0;
    if (aon_wkup_en_q) begin
      unique case (aon_wkup_mode_q)
        Negedge: aon_wkup_pulse = aon_falling;
        Edge:    aon_wkup_pulse = aon_rising | aon_falling;
        HighTimed: begin
aon_cnt_en = aon_filter_out_d;
aon_wkup_pulse = aon_cnt_eq_th;
end
        LowTimed: begin
aon_cnt_en = ~aon_filter_out_d;
aon_wkup_pulse = aon_cnt_eq_th;
end
        // Default to rising
        default: aon_wkup_pulse = aon_rising;
      endcase
    end
  end

  always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_aon_pattern
    if (!rst_aon_ni) begin
      aon_filter_out_q &lt;= 1&#39;b0;
      aon_cnt_q        &lt;= &#39;0;
    end else begin
      aon_filter_out_q &lt;= aon_filter_out_d;
      aon_cnt_q        &lt;= aon_cnt_d;
    end
  end

  ////////////////////
  // Cause register //
  ////////////////////

  // to AON domain
  logic aon_wkup_cause_valid, aon_wkup_cause_data;
  logic aon_wkup_cause_d, aon_wkup_cause_q;

  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_cause_in (
    .clk_i (clk_aon_i),
    .rst_ni(rst_aon_ni),
    .d_i   (wkup_cause_data_i),
    .q_o   (aon_wkup_cause_data)
  );

  prim_pulse_sync i_prim_pulse_sync_cause (
    .clk_src_i  (clk_i),
    .rst_src_ni (rst_ni),
    .src_pulse_i(wkup_cause_valid_i),
    .clk_dst_i  (clk_aon_i),
    .rst_dst_ni (rst_aon_ni),
    .dst_pulse_o(aon_wkup_cause_valid)
  );

  // note that aon_wkup_pulse will not be asserted when not in sleep mode
  assign aon_wkup_cause_d = (aon_wkup_cause_valid) ? aon_wkup_cause_q &amp; aon_wkup_cause_data :
                                                     aon_wkup_cause_q | aon_wkup_pulse;

  // output to power manager
  assign aon_wkup_req_o = aon_wkup_cause_q;

  // output to CSR
  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_cause_out (
    .clk_i,
    .rst_ni,
    .d_i(aon_wkup_cause_q),
    .q_o(wkup_cause_data_o)
  );

  always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_aon_cause
    if (!rst_aon_ni) begin
      aon_wkup_cause_q &lt;= 1&#39;b0;
    end else begin
      aon_wkup_cause_q &lt;= aon_wkup_cause_d;
    end
  end

endmodule : pinmux_wkup
Diffs are:
 // Copyright lowRISC contributors.
 // Licensed under the Apache License, Version 2.0, see LICENSE for details.
 // SPDX-License-Identifier: Apache-2.0
 //
 module pinmux_wkup
   import pinmux_pkg::*;
   import pinmux_reg_pkg::*;
 #(
   parameter int Cycles = 4
 ) (
   input                                 clk_i,
   input                                 rst_ni,
   // Always on clock / reset
   input                                 clk_aon_i,
   input                                 rst_aon_ni,
   // These signals get synchronized to the
   // slow AON clock within this module.
   // Note that wkup_en_i is assumed to be level encoded.
   input                                 wkup_en_i,
   input                                 filter_en_i,
   input  wkup_mode_e                    wkup_mode_i,
   input              [WkupCntWidth-1:0] wkup_cnt_th_i,
   input                                 pin_value_i,
   // Signals to/from cause register.
   // They are synched to/from the AON clock internally
   input                                 wkup_cause_valid_i,
   input                                 wkup_cause_data_i,
   output                                wkup_cause_data_o,
   // This signal is running on the AON clock
   // and is held high as long as the cause register
   // has not been cleared.
   output logic                          aon_wkup_req_o
 );

   ///////////////////////////
   // Input Synchronization //
   ///////////////////////////

   // Synchronize configuration to slow clock
   wkup_mode_e aon_wkup_mode_q;
   logic aon_filter_en_q;
   logic aon_wkup_en_d, aon_wkup_en_q;
   logic [WkupCntWidth-1:0] aon_wkup_cnt_th_q;

   prim_flop_2sync #(
     .Width(1)
   ) i_prim_flop_2sync_config (
     .clk_i (clk_aon_i),
     .rst_ni(rst_aon_ni),
     .d_i   (wkup_en_i),
     .q_o   (aon_wkup_en_d)
   );

   always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_sync
     if (!rst_aon_ni) begin
       aon_wkup_en_q     &lt;= 1&#39;b0;
       aon_wkup_mode_q   &lt;= Posedge;
       aon_filter_en_q   &lt;= 1&#39;b0;
       aon_wkup_cnt_th_q &lt;= &#39;0;
     end else begin
       aon_wkup_en_q &lt;= aon_wkup_en_d;
       // latch these when going into sleep. note that these
       // config signals should be stable at this point, since
       // SW has configured them many cycles ago. hence no
       // explicit multibit consistency check is performed.
       if (aon_wkup_en_d &amp; !aon_wkup_en_q) begin
         aon_wkup_mode_q   &lt;= wkup_mode_i;
         aon_filter_en_q   &lt;= filter_en_i;
         aon_wkup_cnt_th_q &lt;= wkup_cnt_th_i;
       end
     end
   end

   ////////////////////////////
   // Optional Signal Filter //
   ////////////////////////////

   // This uses a lower value for filtering than GPIO since
   // the always-on clock is slower. This can be disabled,
   // in which case the signal is just combinationally bypassed.
   logic aon_filter_out, aon_filter_out_d, aon_filter_out_q;
   prim_filter #(
     .Cycles(Cycles)
   ) i_prim_filter (
     .clk_i   (clk_aon_i),
     .rst_ni  (rst_aon_ni),
     .enable_i(aon_filter_en_q),
     .filter_i(pin_value_i),
     .filter_o(aon_filter_out)
   );

   // Run this through a 2 stage synchronizer to
   // prevent metastability.
   prim_flop_2sync #(
     .Width(1)
   ) i_prim_flop_2sync_filter (
     .clk_i (clk_aon_i),
     .rst_ni(rst_aon_ni),
     .d_i   (aon_filter_out),
     .q_o   (aon_filter_out_d)
   );

   //////////////////////
   // Pattern Matching //
   //////////////////////

   logic aon_rising, aon_falling;
   assign aon_falling = ~aon_filter_out_d &amp; aon_filter_out_q;
   assign aon_rising  = aon_filter_out_d &amp; ~aon_filter_out_q;

   logic aon_cnt_en, aon_cnt_eq_th;
   logic [WkupCntWidth-1:0] aon_cnt_d, aon_cnt_q;
   assign aon_cnt_d     = (aon_cnt_eq_th) ? &#39;0 : (aon_cnt_en) ? aon_cnt_q + 1&#39;b1 : &#39;0;

   assign aon_cnt_eq_th = aon_cnt_q == aon_wkup_cnt_th_q;

   logic aon_wkup_pulse;
   always_comb begin : p_mode
     aon_wkup_pulse = 1&#39;b0;
     aon_cnt_en     = 1&#39;b0;
     if (aon_wkup_en_q) begin
       unique case (aon_wkup_mode_q)
         Negedge: aon_wkup_pulse = aon_falling;
         Edge:    aon_wkup_pulse = aon_rising | aon_falling;
         HighTimed: begin
-          aon_cnt_en = aon_filter_out_d;
-          aon_wkup_pulse = aon_cnt_eq_th;
-        end
+aon_cnt_en = aon_filter_out_d;
+aon_wkup_pulse = aon_cnt_eq_th;
+end
         LowTimed: begin
-          aon_cnt_en = ~aon_filter_out_d;
-          aon_wkup_pulse = aon_cnt_eq_th;
-        end
+aon_cnt_en = ~aon_filter_out_d;
+aon_wkup_pulse = aon_cnt_eq_th;
+end
         // Default to rising
         default: aon_wkup_pulse = aon_rising;
       endcase
     end
   end

   always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_aon_pattern
     if (!rst_aon_ni) begin
       aon_filter_out_q &lt;= 1&#39;b0;
       aon_cnt_q        &lt;= &#39;0;
     end else begin
       aon_filter_out_q &lt;= aon_filter_out_d;
       aon_cnt_q        &lt;= aon_cnt_d;
     end
   end

   ////////////////////
   // Cause register //
   ////////////////////

   // to AON domain
   logic aon_wkup_cause_valid, aon_wkup_cause_data;
   logic aon_wkup_cause_d, aon_wkup_cause_q;

   prim_flop_2sync #(
     .Width(1)
   ) i_prim_flop_2sync_cause_in (
     .clk_i (clk_aon_i),
     .rst_ni(rst_aon_ni),
     .d_i   (wkup_cause_data_i),
     .q_o   (aon_wkup_cause_data)
   );

   prim_pulse_sync i_prim_pulse_sync_cause (
     .clk_src_i  (clk_i),
     .rst_src_ni (rst_ni),
     .src_pulse_i(wkup_cause_valid_i),
     .clk_dst_i  (clk_aon_i),
     .rst_dst_ni (rst_aon_ni),
     .dst_pulse_o(aon_wkup_cause_valid)
   );

   // note that aon_wkup_pulse will not be asserted when not in sleep mode
   assign aon_wkup_cause_d = (aon_wkup_cause_valid) ? aon_wkup_cause_q &amp; aon_wkup_cause_data :
                                                      aon_wkup_cause_q | aon_wkup_pulse;

   // output to power manager
   assign aon_wkup_req_o = aon_wkup_cause_q;

   // output to CSR
   prim_flop_2sync #(
     .Width(1)
   ) i_prim_flop_2sync_cause_out (
     .clk_i,
     .rst_ni,
     .d_i(aon_wkup_cause_q),
     .q_o(wkup_cause_data_o)
   );

   always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_aon_cause
     if (!rst_aon_ni) begin
       aon_wkup_cause_q &lt;= 1&#39;b0;
     end else begin
       aon_wkup_cause_q &lt;= aon_wkup_cause_d;
     end
   end

 endmodule : pinmux_wkup
; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
module pinmux_wkup
  import pinmux_pkg::*;
  import pinmux_reg_pkg::*;
#(
  parameter int Cycles = 4
) (
  input                                 clk_i,
  input                                 rst_ni,
  // Always on clock / reset
  input                                 clk_aon_i,
  input                                 rst_aon_ni,
  // These signals get synchronized to the
  // slow AON clock within this module.
  // Note that wkup_en_i is assumed to be level encoded.
  input                                 wkup_en_i,
  input                                 filter_en_i,
  input  wkup_mode_e                    wkup_mode_i,
  input              [WkupCntWidth-1:0] wkup_cnt_th_i,
  input                                 pin_value_i,
  // Signals to/from cause register.
  // They are synched to/from the AON clock internally
  input                                 wkup_cause_valid_i,
  input                                 wkup_cause_data_i,
  output                                wkup_cause_data_o,
  // This signal is running on the AON clock
  // and is held high as long as the cause register
  // has not been cleared.
  output logic                          aon_wkup_req_o
);

  ///////////////////////////
  // Input Synchronization //
  ///////////////////////////

  // Synchronize configuration to slow clock
  wkup_mode_e aon_wkup_mode_q;
  logic aon_filter_en_q;
  logic aon_wkup_en_d, aon_wkup_en_q;
  logic [WkupCntWidth-1:0] aon_wkup_cnt_th_q;

  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_config (
    .clk_i (clk_aon_i),
    .rst_ni(rst_aon_ni),
    .d_i   (wkup_en_i),
    .q_o   (aon_wkup_en_d)
  );

  always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_sync
    if (!rst_aon_ni) begin
      aon_wkup_en_q     &lt;= 1&#39;b0;
      aon_wkup_mode_q   &lt;= Posedge;
      aon_filter_en_q   &lt;= 1&#39;b0;
      aon_wkup_cnt_th_q &lt;= &#39;0;
    end else begin
      aon_wkup_en_q &lt;= aon_wkup_en_d;
      // latch these when going into sleep. note that these
      // config signals should be stable at this point, since
      // SW has configured them many cycles ago. hence no
      // explicit multibit consistency check is performed.
      if (aon_wkup_en_d &amp; !aon_wkup_en_q) begin
        aon_wkup_mode_q   &lt;= wkup_mode_i;
        aon_filter_en_q   &lt;= filter_en_i;
        aon_wkup_cnt_th_q &lt;= wkup_cnt_th_i;
      end
    end
  end

  ////////////////////////////
  // Optional Signal Filter //
  ////////////////////////////

  // This uses a lower value for filtering than GPIO since
  // the always-on clock is slower. This can be disabled,
  // in which case the signal is just combinationally bypassed.
  logic aon_filter_out, aon_filter_out_d, aon_filter_out_q;
  prim_filter #(
    .Cycles(Cycles)
  ) i_prim_filter (
    .clk_i   (clk_aon_i),
    .rst_ni  (rst_aon_ni),
    .enable_i(aon_filter_en_q),
    .filter_i(pin_value_i),
    .filter_o(aon_filter_out)
  );

  // Run this through a 2 stage synchronizer to
  // prevent metastability.
  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_filter (
    .clk_i (clk_aon_i),
    .rst_ni(rst_aon_ni),
    .d_i   (aon_filter_out),
    .q_o   (aon_filter_out_d)
  );

  //////////////////////
  // Pattern Matching //
  //////////////////////

  logic aon_rising, aon_falling;
  assign aon_falling = ~aon_filter_out_d &amp; aon_filter_out_q;
  assign aon_rising  = aon_filter_out_d &amp; ~aon_filter_out_q;

  logic aon_cnt_en, aon_cnt_eq_th;
  logic [WkupCntWidth-1:0] aon_cnt_d, aon_cnt_q;
  assign aon_cnt_d     = (aon_cnt_eq_th) ? &#39;0 : (aon_cnt_en) ? aon_cnt_q + 1&#39;b1 : &#39;0;

  assign aon_cnt_eq_th = aon_cnt_q == aon_wkup_cnt_th_q;

  logic aon_wkup_pulse;
  always_comb begin : p_mode
    aon_wkup_pulse = 1&#39;b0;
    aon_cnt_en     = 1&#39;b0;
    if (aon_wkup_en_q) begin
      unique case (aon_wkup_mode_q)
        Negedge: aon_wkup_pulse = aon_falling;
        Edge:    aon_wkup_pulse = aon_rising | aon_falling;
        HighTimed: begin
          aon_cnt_en = aon_filter_out_d;
          aon_wkup_pulse = aon_cnt_eq_th;
        end
        LowTimed: begin
          aon_cnt_en = ~aon_filter_out_d;
          aon_wkup_pulse = aon_cnt_eq_th;
        end
        // Default to rising
        default: aon_wkup_pulse = aon_rising;
      endcase
    end
  end

  always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_aon_pattern
    if (!rst_aon_ni) begin
      aon_filter_out_q &lt;= 1&#39;b0;
      aon_cnt_q        &lt;= &#39;0;
    end else begin
      aon_filter_out_q &lt;= aon_filter_out_d;
      aon_cnt_q        &lt;= aon_cnt_d;
    end
  end

  ////////////////////
  // Cause register //
  ////////////////////

  // to AON domain
  logic aon_wkup_cause_valid, aon_wkup_cause_data;
  logic aon_wkup_cause_d, aon_wkup_cause_q;

  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_cause_in (
    .clk_i (clk_aon_i),
    .rst_ni(rst_aon_ni),
    .d_i   (wkup_cause_data_i),
    .q_o   (aon_wkup_cause_data)
  );

  prim_pulse_sync i_prim_pulse_sync_cause (
    .clk_src_i  (clk_i),
    .rst_src_ni (rst_ni),
    .src_pulse_i(wkup_cause_valid_i),
    .clk_dst_i  (clk_aon_i),
    .rst_dst_ni (rst_aon_ni),
    .dst_pulse_o(aon_wkup_cause_valid)
  );

  // note that aon_wkup_pulse will not be asserted when not in sleep mode
  assign aon_wkup_cause_d = (aon_wkup_cause_valid) ? aon_wkup_cause_q &amp; aon_wkup_cause_data :
                                                     aon_wkup_cause_q | aon_wkup_pulse;

  // output to power manager
  assign aon_wkup_req_o = aon_wkup_cause_q;

  // output to CSR
  prim_flop_2sync #(
    .Width(1)
  ) i_prim_flop_2sync_cause_out (
    .clk_i,
    .rst_ni,
    .d_i(aon_wkup_cause_q),
    .q_o(wkup_cause_data_o)
  );

  always_ff @(posedge clk_aon_i or negedge rst_aon_ni) begin : p_aon_cause
    if (!rst_aon_ni) begin
      aon_wkup_cause_q &lt;= 1&#39;b0;
    end else begin
      aon_wkup_cause_q &lt;= aon_wkup_cause_d;
    end
  end

endmodule : pinmux_wkup
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-kmac-dv-env-kmac-env-cov-sv">
<span id="error-hw-ip-kmac-dv-env-kmac-env-cov-sv"></span><h2>hw/ip/kmac/dv/env/kmac_env_cov.sv<a class="headerlink" href="#hw-ip-kmac-dv-env-kmac-env-cov-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span> <span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">68</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;`XOF_CROSS_CG&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">103</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;:&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">168</span><span class="p">:</span><span class="mi">12</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;new&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">170</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endfunction&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">177</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;(&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">178</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endfunction&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">186</span><span class="p">:</span><span class="mi">16</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;:&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">187</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endgroup&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">349</span><span class="p">:</span><span class="mi">12</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;new&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">351</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;super&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">363</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;do&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">366</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">367</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;endfunction&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">370</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;super&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">374</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;if&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">377</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
<span class="n">opentitan</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">ip</span><span class="o">/</span><span class="n">kmac</span><span class="o">/</span><span class="n">dv</span><span class="o">/</span><span class="n">env</span><span class="o">/</span><span class="n">kmac_env_cov</span><span class="o">.</span><span class="n">sv</span><span class="p">:</span><span class="mi">379</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span> <span class="n">syntax</span> <span class="n">error</span><span class="p">,</span> <span class="n">rejected</span> <span class="s2">&quot;end&quot;</span> <span class="p">(</span><span class="n">syntax</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-kmac-dv-env-kmac-scoreboard-sv">
<span id="error-hw-ip-kmac-dv-env-kmac-scoreboard-sv"></span><h2>hw/ip/kmac/dv/env/kmac_scoreboard.sv<a class="headerlink" href="#hw-ip-kmac-dv-env-kmac-scoreboard-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/kmac/dv/env/kmac_scoreboard.sv: Formatted output is lexically different from the input.    Please file a bug.  Details:
Mismatched token enums.  got: (&#39;)&#39;) (#41: &quot;)&quot;) vs. (MacroCallCloseToEndLine) (#746: &quot;)&quot;)
First mismatched token [4281]: (&#39;)&#39;) (#41: &quot;)&quot;) vs. (MacroCallCloseToEndLine) (#746: &quot;)&quot;)
; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

`define KMAC_APP_VALID_TRANS(mode) \
    (cfg.m_kmac_app_agent_cfg[``mode``].vif.req_data_if.valid &amp;&amp; \
     cfg.m_kmac_app_agent_cfg[``mode``].vif.req_data_if.ready)

`define CALC_PARTIAL_MSG \
    (!in_kmac_app &amp;&amp; msg.size() % 8 &gt; 0) || \
      (in_kmac_app &amp;&amp; \
        (app_mode == AppKeymgr &amp;&amp; (kmac_app_msg.size() + 3) % 8 &gt; 0) || \
        (app_mode != AppKeymgr &amp;&amp; kmac_app_msg.size() % 8 &gt; 0))

class kmac_scoreboard extends cip_base_scoreboard #(
  .CFG_T(kmac_env_cfg),
  .RAL_T(kmac_reg_block),
  .COV_T(kmac_env_cov)
);
  `uvm_component_utils(kmac_scoreboard)

  // local variables

  bit do_check_digest = 1;

  // Represents the number of blocks that have been filled in sha3pad
  int num_blocks_filled = 0;

  // used solely for coverage sampling, indicates that keccak rounds are currently running
  bit in_keccak_rounds = 0;

  // Whenever the keccak rounds are running, the `complete` signal is raised at the end
  // for a single cycle to signal to sha3 control logic that the keccak engine is completed.
  //
  // There are some edge cases that may occur if a CmdProcess or a `kmac_app_last`is seen on this
  // &quot;complete&quot; cycle that need to be handled - this bit will be raised and lowered in conjunction
  // with the internal `complete` signal to allow the scb easier handling of these scenarios.
  bit keccak_complete_cycle = 0;

  // this bit goes high when KMAC has finished processing the
  // prefix and the secret keys (only in KMAC mode)
  bit prefix_and_keys_done = 0;

  // this bit tracks the beginning and end of a KMAC_APP operation
  bit in_kmac_app;

  // Indicates what application is using the app interface
  kmac_app_e app_mode;

  // this bit goes high for a cycle when a manual squeezing is requested
  bit req_manual_squeeze = 0;

  // this bit goes high a small delay after CmdProcess is requested,
  // used by fifo flushing logic to handle an edge case
  bit req_cmd_process_dly = 0;

  // This bit goes high if the fifo write pointer is incremented on the same cycle that
  // a CmdProcess is detected internally and the fifo starts to flush its contents
  bit incr_fifo_wr_in_process = 0;

  // This bit indicates that a CmdProcess has been seen while the KMAC is still processing
  // the prefix and secret keys (only used in KMAC mode)
  bit cmd_process_in_header = 0;

  // This bit indicates that the last block of a KMAC_APP request transaction has been sent
  // while the KMAC is still running keccak on a previous full set of blocks
  bit kmac_app_last_in_keccak;

  // This bit indicates that the last block of a KMAC_APP request transaction has been sent
  // while the KMAC is still processing the prefix and secret keys
  bit kmac_app_last_in_header = 0;

  // This bit is toggled for half a clock cycle every time a new block of data
  // is transmitted via kmac_app interface and received
  bit got_data_from_kmac_app = 0;

  // The CFG.entropy_ready field is only used to transition the entropy FSM into fetching entropy
  // from the reset state, so we can only rely on writes to CFG.entropy_ready to update internal
  // scoreboard state after a reset is seen.
  //
  // To that effect, we set this bit to 1 any time the scoreboard is reset, and will unset it
  // the first time that CFG.entropy_ready is updated.
  bit first_op_after_rst = 0;

  // CFG fields
  bit kmac_en;
  sha3_pkg::sha3_mode_e hash_mode;
  sha3_pkg::keccak_strength_e strength;
  entropy_mode_e entropy_mode = EntropyModeNone;
  bit entropy_fast_process;
  bit entropy_ready;

  // Set this bit when entropy_ready is 1 and entropy_mode is EntropyModeEdn,
  // to indicate that we are now waiting on the EDN to return valid entropy
  bit in_edn_fetch = 0;

  // This bit indicates that the KMAC is performing an entropy refresh
  bit refresh_entropy = 0;

  // CMD fields
  kmac_cmd_e unchecked_kmac_cmd = CmdNone;
  kmac_cmd_e checked_kmac_cmd = CmdNone;

  bit msg_digest_done;

  // SHA3 status bits
  bit sha3_idle;
  bit sha3_absorb;
  bit sha3_squeeze;

  // FIFO model variables
  bit [4:0] fifo_depth;
  bit fifo_empty;
  bit fifo_full;

  bit intr_kmac_done;
  bit intr_fifo_empty;
  bit intr_kmac_err;

  // Error tracking
  kmac_pkg::err_t kmac_err = &#39;{valid: 1&#39;b0, code: kmac_pkg::ErrNone, info: &#39;0};
  sha3_pkg::err_t sha3_err = &#39;{valid: 1&#39;b0, code: sha3_pkg::ErrNone, info: &#39;0};
  // Need to track the FSM in `kmac_app` and the mux select value,
  // these are used in App-related error reporting
  kmac_app_st_e app_st = StIdle;
  bit app_fsm_active = 0;
  app_mux_sel_e app_mux_sel = SelNone;

  // Need to track the FSM in `kmac_errchk` for error reporting
  kmac_err_st_e err_st = ErrStIdle;
  kmac_err_st_e err_st_next = ErrStIdle;

  // Variables to track the internal write/read pointers.
  //
  // One major difference between these and standard fifo pointers is that these
  // values will not loop back to 0 after hitting the max fifo depth.
  // These values will keep incrementing to keep some scoreboard logic simpler.
  int fifo_wr_ptr;
  int fifo_rd_ptr;

  // key length enum
  key_len_e key_len;

  keymgr_pkg::hw_key_req_t sideload_key;

  bit [keymgr_pkg::KmacDataIfWidth-1:0] kmac_app_block_data;
  bit [keymgr_pkg::KmacDataIfWidth/8-1:0] kmac_app_block_strb;
  int kmac_app_block_strb_size = 0;
  bit kmac_app_last;

  // secret keys
  //
  // max key size is 512-bits
  bit [KMAC_NUM_SHARES-1:0][KMAC_NUM_KEYS_PER_SHARE-1:0][31:0] keys;
  bit [KMAC_NUM_SHARES-1:0][KMAC_NUM_KEYS_PER_SHARE-1:0][31:0] keymgr_keys;

  // prefix words
  bit [31:0] prefix[KMAC_NUM_PREFIX_WORDS];

  // input message
  bit [7:0] msg[$];

  // input message from keymgr
  byte kmac_app_msg[$];

  // output digest from KMAC_APP intf (256 bits each)
  bit [keymgr_pkg::KeyWidth-1:0] kmac_app_digest_share0;
  bit [keymgr_pkg::KeyWidth-1:0] kmac_app_digest_share1;

  // output digests
  bit [7:0] digest_share0[];
  bit [7:0] digest_share1[];

  // This mask is used to mask reads from the state windows.
  // We need to make this a class variable as we set the mask value
  // during the address read phase, but then need its value to persist
  // through the data read phase.
  bit [TL_DBW-1:0] state_mask;

  // TLM fifos
  uvm_tlm_analysis_fifo #(kmac_app_item) kmac_app_rsp_fifo[kmac_pkg::NumAppIntf];
  uvm_tlm_analysis_fifo #(push_pull_agent_pkg::push_pull_item #(
    .HostDataWidth(kmac_app_agent_pkg::KMAC_REQ_DATA_WIDTH)
  )) kmac_app_req_fifo[kmac_pkg::NumAppIntf];

  `uvm_component_new

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    for (int i = 0; i &lt; kmac_pkg::NumAppIntf; i++) begin
      kmac_app_req_fifo[i] = new($sformatf(&quot;kmac_app_req_fifo[%0d]&quot;, i), this);
      kmac_app_rsp_fifo[i] = new($sformatf(&quot;kmac_app_rsp_fifo[%0d]&quot;, i), this);
    end
  endfunction

  function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
  endfunction

  task run_phase(uvm_phase phase);
    super.run_phase(phase);
    fork
      process_checked_kmac_cmd();
      detect_kmac_app_start();
      process_kmac_app_fsm();
      process_kmac_err_fsm();
      process_edn();
      process_prefix_and_keys();
      process_msgfifo_write();
      process_msgfifo_status();
      process_sha3_idle();
      process_sha3_absorb();
      process_sha3_squeeze();
      if (cfg.en_cov) sample_sha3_status();
      process_initial_digest();
      process_manual_digest_squeeze();
      process_intr_kmac_done();
      process_kmac_app_req_fifo();
      process_kmac_app_rsp_fifo();
      process_sideload_key();
    join_none
  endtask

  // This task spins forever and assigns `checked_kmac_cmd` to `unchecked_kmac_cmd`
  // with a 1 cycle delay.
  virtual task process_checked_kmac_cmd();
    @(negedge cfg.under_reset);
    forever begin
      wait(!cfg.under_reset);
      `DV_SPINWAIT_EXIT(@(unchecked_kmac_cmd);
          `uvm_info(`gfn, &quot;BEFORE LATCHING KMAC_CMD&quot;, UVM_HIGH)
          `uvm_info(`gfn, $sformatf(&quot;unchecked_kmac_cmd: %0s&quot;, unchecked_kmac_cmd.name()), UVM_HIGH)
          `uvm_info(`gfn, $sformatf(&quot;checked_kmac_cmd: %0s&quot;, checked_kmac_cmd.name()), UVM_HIGH)
          cfg.clk_rst_vif.wait_clks(1);
          checked_kmac_cmd = unchecked_kmac_cmd;
          `uvm_info(`gfn, &quot;AFTER LATCHING KMAC_CMD&quot;, UVM_HIGH)
          `uvm_info(`gfn, $sformatf(&quot;unchecked_kmac_cmd: %0s&quot;, unchecked_kmac_cmd.name()), UVM_HIGH)
          `uvm_info(`gfn, $sformatf(&quot;checked_kmac_cmd: %0s&quot;, checked_kmac_cmd.name()), UVM_HIGH)
          // If CmdDone is written, we know that a hash has completed.
          // So, we can set this to CmdNone one cycle later.
          cfg.clk_rst_vif.wait_clks(1);
          if (checked_kmac_cmd == CmdDone) begin
            checked_kmac_cmd = CmdNone;
          end, wait(cfg.under_reset);)
    end
  endtask

  // This task waits until an entropy request is sent,
  // then waits for valid entropy to be returned from EDN
  virtual task process_edn();
    push_pull_agent_pkg::push_pull_item #(.DeviceDataWidth(cip_base_pkg::EDN_DATA_WIDTH)) edn_item;
    @(negedge cfg.under_reset);
    forever begin
      wait(!cfg.under_reset);
      `DV_SPINWAIT_EXIT(forever begin
            @(posedge in_edn_fetch);
            // Entropy interface is native 32 bits - prim_edn_req component internally
            // does as many EDN fetches as necessary to fill up the required data bus size
            // of the &quot;host&quot;, in this case KMAC needs 64 bits of entropy so prim_edn_req
            // performs 2 fetches from the EDN network.
            repeat (kmac_pkg::MsgWidth / cip_base_pkg::EDN_BUS_WIDTH) begin
              edn_fifo.get(edn_item);
            end
            `uvm_info(`gfn, &quot;got all edn transactions&quot;, UVM_HIGH)
            // Receiving the last EDN sequence item is synchronized on the EDN clock,
            // so we need to synchronize into the KMAC clock domain.
            // This takes 4 clock cycles total, on the last cycle the entropy is marked as valid
            // to the keccak logic and any pending keccak rounds can begin.
            cfg.clk_rst_vif.wait_clks(4);
            in_edn_fetch = 0;
            `uvm_info(`gfn, &quot;dropped in_edn_fetch&quot;, UVM_HIGH)
            if (refresh_entropy) begin
              refresh_entropy = 0;
              `uvm_info(`gfn, &quot;dropped refresh_entropy&quot;, UVM_HIGH)
            end
            // after EDN request returns fresh entropy, it only becomes valid after 6 cycles:
            // - 5 to expand the entropy
            // - 1 to latch the entropy
            cfg.clk_rst_vif.wait_clks(CYCLES_TO_FILL_ENTROPY + 1);
          end, wait(cfg.under_reset);)
    end
  endtask

  // This task will check for any sideload keys that have been provided
  virtual task process_sideload_key();
    @(negedge cfg.under_reset);
    forever begin
      wait(!cfg.under_reset);
      `DV_SPINWAIT_EXIT(forever begin
            // Wait for a valid sideloaded key
            cfg.sideload_vif.wait_valid(logic&#39;(1&#39;b1));

            // Once valid sideload keys have been seen, update scoreboard state.
            //
            // Note: max size of sideloaded key is keymgr_pkg::KeyWidth

            sideload_key = cfg.sideload_vif.sideload_key;

            `uvm_info(`gfn, $sformatf(&quot;detected valid sideload_key: %0p&quot;, sideload_key), UVM_HIGH)

            for (int i = 0; i &lt; keymgr_pkg::KeyWidth / 32; i++) begin
              keymgr_keys[0][i] = sideload_key.key[0][i*32 +: 32];
              keymgr_keys[1][i] = sideload_key.key[1][i*32 +: 32];
            end

            // Sequence will drop the sideloaded key after scb can process the digest
            cfg.sideload_vif.wait_valid(logic&#39;(1&#39;b0));
          end, wait(cfg.under_reset);)
    end
  endtask

  // This task checks for the start of a KMAC_APP operation and updates scoreboard state accordingly.
  //
  // `process_kmac_app_req_fifo()` cannot be used for this purpose because the scb will only receive
  // a kmac_app_req item once the full request has been completed, which can consist of many
  // different request transactions.
  virtual task detect_kmac_app_start();
    @(negedge cfg.under_reset);
    forever begin
      `DV_SPINWAIT_EXIT(forever begin
            // If we are not in KMAC_APP mode, the next time we see valid is the start
            // of a KMAC_APP operation.
            //
            // Assume that application interface requests do not collide.
            `uvm_info(`gfn, &quot;waiting for new kmac_app request&quot;, UVM_HIGH)
            wait(!in_kmac_app &amp;&amp; app_fsm_active &amp;&amp;
                 (`KMAC_APP_VALID_TRANS(AppKeymgr) ||
                  `KMAC_APP_VALID_TRANS(AppLc) ||
                  `KMAC_APP_VALID_TRANS(AppRom)));
            in_kmac_app = 1;
            `uvm_info(`gfn, &quot;raised in_kmac_app&quot;, UVM_HIGH)

            // we need to choose the correct application interface
            if (`KMAC_APP_VALID_TRANS(AppKeymgr)) begin
              app_mode = AppKeymgr;
            end else if (`KMAC_APP_VALID_TRANS(AppLc)) begin
              app_mode = AppLc;
            end else if (`KMAC_APP_VALID_TRANS(AppRom)) begin
              app_mode = AppRom;
            end

            // sample sideload-related coverage
            if (cfg.en_cov) begin
              // Note that all arguments to the covergroup sample() function are the same,
              // this is due to the nature of the arguments that this function takes:
              //
              // - `en_sideload`: this bit indicates whether sideloading mode is active
              // - `in_kmac`    : this bit indicates whether we are operating in KMAC mode
              // - `app_keymgr` : this bit indicates whether we are using the Keymgr-specific App
              //                  interface
              //
              // Checking whether the current application mode is the AppKeymgr mode gives us
              // sufficient information for all three of these arguments due to the nature of this
              // particular interface.
              cov.sideload_cg.sample(app_mode == AppKeymgr,
                                     app_mode == AppKeymgr,
                                     app_mode == AppKeymgr);
            end

            @(posedge sha3_idle);
          end, wait(cfg.under_reset || kmac_err.code == ErrKeyNotValid);)
      if (cfg.under_reset) begin
        @(negedge cfg.under_reset);
      end
      if (kmac_err.code == ErrKeyNotValid) begin
        `uvm_info(`gfn, &quot;kmac_err.code is ErrKeyNotValid&quot;, UVM_HIGH)
        `uvm_info(`gfn, &quot;waiting for error to drop&quot;, UVM_HIGH)
        wait(kmac_err.code == ErrNone);
        `uvm_info(`gfn, &quot;ErrKeyNotValid has been handled&quot;, UVM_HIGH)
      end
      wait(!cfg.under_reset);
    end
  endtask

  // This task models the internal FSM of kmac_app module,
  // required for error handling SW output.
  virtual task process_kmac_app_fsm();
    @(negedge cfg.under_reset);
    forever begin
      wait(!cfg.under_reset);
      `DV_SPINWAIT_EXIT(forever begin
            app_mux_sel = SelNone;
            case (app_st)
              StIdle: begin
                if (!in_kmac_app &amp;&amp;
                    (cfg.m_kmac_app_agent_cfg[AppKeymgr].vif.req_data_if.valid ||
                     cfg.m_kmac_app_agent_cfg[AppLc].vif.req_data_if.valid ||
                     cfg.m_kmac_app_agent_cfg[AppRom].vif.req_data_if.valid)) begin
                  app_st = StAppCfg;
                  app_fsm_active = 1;
                end else if (checked_kmac_cmd == CmdStart) begin
                  app_st = StSw;
                end
              end
              StAppCfg: begin
                if (app_mode == AppKeymgr &amp;&amp; !cfg.sideload_vif.sideload_key.valid) begin
                  app_st = StKeyMgrErrKeyNotValid;
                end else begin
                  app_st = StAppMsg;
                end
              end
              StAppMsg: begin
                app_mux_sel = SelApp;
                if (kmac_app_last) begin
                  if (app_mode == AppKeymgr) begin
                    app_st = StAppOutLen;
                  end else begin
                    app_st = StAppProcess;
                  end
                end
              end
              StAppOutLen: begin
                app_mux_sel = SelOutLen;
                app_st = StAppProcess;
              end
              StAppProcess: begin
                app_st = StAppWait;
              end
              StAppWait: begin
                if (keccak_complete_cycle) begin
                  app_st = StIdle;
                  app_fsm_active = 0;
                end
              end
              StSw: begin
                app_mux_sel = SelSw;
                if (checked_kmac_cmd == CmdDone) begin
                  app_st = StIdle;
                  app_fsm_active = 0;
                end
              end
              StKeyMgrErrKeyNotValid: begin
                app_st = StError;
                app_fsm_active = 0;
                in_kmac_app = 0;

                kmac_err.valid = 1;
                kmac_err.code = kmac_pkg::ErrKeyNotValid;
                kmac_err.info = &#39;0;

                predict_err(.is_kmac_err(1));
              end
              StError: begin

                if (`gmv(ral.cfg.err_processed)) begin
                  app_st = StIdle;
                end else begin
                  app_st = StError;
                end

                // It&#39;s possible for SW to not clear the error until after the hash is done.
                // In this case the hash will be garbage data, so do not check it.
                if (cfg.m_kmac_app_agent_cfg[app_mode].vif.kmac_data_req.valid &amp;&amp;
                    cfg.m_kmac_app_agent_cfg[app_mode].vif.kmac_data_req.last) begin
                  do_check_digest = 0;
                end

              end
              default: begin
                app_st = StIdle;
                app_fsm_active = 0;
              end
            endcase
            cfg.clk_rst_vif.wait_clks(1);
            #0;
          end, wait(cfg.under_reset);)
    end
  endtask

  // This task simulates the error handling FSM in the KMAC,
  // as we need state information for error reporting.
  virtual task process_kmac_err_fsm();
    @(negedge cfg.under_reset);
    forever begin
      wait(!cfg.under_reset);
      `DV_SPINWAIT_EXIT(case (err_st)
            ErrStIdle: begin
              if (!app_fsm_active &amp;&amp; unchecked_kmac_cmd == CmdStart) begin
                err_st_next = ErrStMsgFeed;
                `uvm_info(`gfn, &quot;moving to ErrStMsgFeed&quot;, UVM_HIGH)
              end
            end
            ErrStMsgFeed: begin
              if (unchecked_kmac_cmd == CmdProcess) begin
                err_st_next = ErrStProcessing;
                `uvm_info(`gfn, &quot;moving to ErrStProcessing&quot;, UVM_HIGH)
              end
            end
            ErrStProcessing: begin
              if (msg_digest_done) begin
                err_st_next = ErrStAbsorbed;
                `uvm_info(`gfn, &quot;moving to ErrStAbsorbed&quot;, UVM_HIGH)
              end
            end
            ErrStAbsorbed: begin
              if (req_manual_squeeze) begin
                err_st_next = ErrStSqueezing;
                `uvm_info(`gfn, &quot;moving to ErrStSqueezing&quot;, UVM_HIGH)
              end else if (unchecked_kmac_cmd == CmdDone) begin
                err_st_next = ErrStIdle;
                `uvm_info(`gfn, &quot;moving to ErrStIdle&quot;, UVM_HIGH)
              end
            end
            ErrStSqueezing: begin
              if (msg_digest_done) begin
                err_st_next = ErrStAbsorbed;
                `uvm_info(`gfn, &quot;moving to ErrStAbsorbed&quot;, UVM_HIGH)
              end
            end
            default: begin
              err_st_next = ErrStIdle;
              `uvm_info(`gfn, &quot;moving to ErrStIdle&quot;, UVM_HIGH)
            end
          endcase
          cfg.clk_rst_vif.wait_clks(1);
          err_st = err_st_next;
          #0;, wait(cfg.under_reset);)
    end
  endtask

  // This task continuously checks the analysis_port of the push_pull_agent
  // in the kmac_app_agent, as we need to know every time a data block is sent
  // over the KMAC_APP interface.
  virtual task process_kmac_app_req_fifo();
    push_pull_agent_pkg::push_pull_item #(
      .HostDataWidth(kmac_app_agent_pkg::KMAC_REQ_DATA_WIDTH)
    ) kmac_app_block_item;
    forever begin
      wait(!cfg.under_reset);
      @(posedge in_kmac_app);
      `uvm_info(`gfn, $sformatf(&quot;req app_mode: %0s&quot;, app_mode.name()), UVM_HIGH)
      `DV_SPINWAIT_EXIT(forever begin
              kmac_app_req_fifo[app_mode].get(kmac_app_block_item);
              `uvm_info(`gfn,
                        $sformatf(&quot;Detected KMAC_APP data transfer:\n%0s&quot;,
                                  kmac_app_block_item.sprint()),
                        UVM_HIGH)
              {kmac_app_block_data, kmac_app_block_strb, kmac_app_last} = kmac_app_block_item.h_data;
              kmac_app_block_strb_size = $countones(kmac_app_block_strb);

              // sample coverage
              if (cfg.en_cov) begin
                cov.app_cg_wrappers[app_mode].sample(0,
                                                    kmac_app_block_strb,
                                                    0,
                                                    kmac_app_last,
                                                    in_keccak_rounds);
              end

              got_data_from_kmac_app = 1;
              while (kmac_app_block_strb &gt; 0) begin
                if (kmac_app_block_strb[0]) begin
                  kmac_app_msg.push_back(kmac_app_block_data[7:0]);
                end
                kmac_app_block_data = kmac_app_block_data &gt;&gt; 8;
                kmac_app_block_strb = kmac_app_block_strb &gt;&gt; 1;
              end
              `uvm_info(`gfn, $sformatf(&quot;kmac_app_msg: %0p&quot;, kmac_app_msg), UVM_HIGH)
              // drop `got_data_from_kmac_app` before the next cycle to avoid repeating
              // unnecessary state updates elsewhere in the scb
              cfg.clk_rst_vif.wait_n_clks(1);
              got_data_from_kmac_app = 0;
            end, wait(cfg.under_reset || !in_kmac_app);)
    end
  endtask

  // This task processes the `kmac_app_rsp_fifo`.
  //
  // This fifo is populated once the KMAC has sent the response digest to
  // complete the KMAC_APP request.
  // As such, `in_kmac_app` must always be 1 when a response item is seen, otherwise
  // something has gone horribly wrong.
  //
  // It is important to note that when in KMAC_APP mode, any messages/keys/commands sent
  // to the CSRs will not be considered as valid, so this task needs to take care of checking
  // the KMAC_APP digest and clearing internal state for the next hash operation.
  virtual task process_kmac_app_rsp_fifo();
    kmac_app_item kmac_app_rsp;
    @(negedge cfg.under_reset);
    forever begin
      wait(!cfg.under_reset);
      `DV_SPINWAIT_EXIT(forever begin
            wait(!cfg.under_reset);
            @(posedge in_kmac_app);
            `uvm_info(`gfn, $sformatf(&quot;rsp app_mode: %0s&quot;, app_mode.name()), UVM_HIGH)
            `DV_SPINWAIT_EXIT(
                kmac_app_rsp_fifo[app_mode].get(kmac_app_rsp);
                `uvm_info(`gfn,
                          $sformatf(&quot;Detected a KMAC_APP response:\n%0s&quot;,
                                    kmac_app_rsp.sprint()),
                          UVM_HIGH)

                // sample coverage
                if (cfg.en_cov) begin
                  cov.app_cg_wrappers[app_mode].sample(
                    kmac_app_rsp.byte_data_q.size() &lt;= keymgr_pkg::KmacDataIfWidth/8,
                    &#39;0,
                    kmac_app_rsp.rsp_error,
                    1,
                    0
                  );
                end

                // safety check that things are working properly and
                // no random KMAC_APP operations are seen
                `DV_CHECK_FATAL(in_kmac_app == 1,
                    &quot;in_kmac_app is not set, scoreboard has not picked up KMAC_APP request&quot;)

                // TODO error checks

                // assign digest values
                kmac_app_digest_share0 = kmac_app_rsp.rsp_digest_share0;
                kmac_app_digest_share1 = kmac_app_rsp.rsp_digest_share1;

                if (do_check_digest) check_digest();

                in_kmac_app = 0;
                `uvm_info(`gfn, &quot;dropped in_kmac_app&quot;, UVM_HIGH)

                clear_state();
                ,
                wait(!in_kmac_app);
            )
          end, wait(cfg.under_reset);)
    end
  endtask

  // This task updates the internal sha3_idle status field
  virtual task process_sha3_idle();
    @(negedge cfg.under_reset);
    forever begin
      wait(!cfg.under_reset);
      `DV_SPINWAIT_EXIT(forever begin
            // sha3_idle drops when CmdStart command is sent or a KMAC_APP op is detected
            @(posedge in_kmac_app or checked_kmac_cmd == CmdStart);
            sha3_idle = 0;
            `uvm_info(`gfn, &quot;dropped sha3_idle&quot;, UVM_HIGH)

            // sha3_idle goes high when either KMAC_APP op is complete or
            // CmdDone command is sent by SW
            @(negedge in_kmac_app or checked_kmac_cmd == CmdDone);
            sha3_idle = 1;
            `uvm_info(`gfn, &quot;raised sha3_idle&quot;, UVM_HIGH)
          end, wait(cfg.under_reset);)
    end
  endtask

  // This task updates the internal sha3_absorb status field
  virtual task process_sha3_absorb();
    @(negedge cfg.under_reset);
    forever begin
      wait(!cfg.under_reset);
      sha3_absorb = ral.status.sha3_absorb.get_reset();
      `DV_SPINWAIT_EXIT(forever begin
            // sha3_absorb should go high when CmdStart is written or
            // when KMAC_APP op is started
            @(posedge in_kmac_app or checked_kmac_cmd == CmdStart);
            sha3_absorb = 1;
            `uvm_info(`gfn, &quot;raised sha3_absorb&quot;, UVM_HIGH)

            // sha3_absorb should go low one cycle after KMAC has finished calculating digest
            @(posedge msg_digest_done);
            cfg.clk_rst_vif.wait_clks(1);
            sha3_absorb = 0;
            `uvm_info(`gfn, &quot;dropped sha3_absorb&quot;, UVM_HIGH)
          end, @(posedge cfg.under_reset or kmac_err.code == ErrKeyNotValid);)
    end
  endtask

  // This task updates the internal sha3_squeeze status field
  virtual task process_sha3_squeeze();
    bit is_kmac_app_op;

    @(negedge cfg.under_reset);
    forever begin
      wait(!cfg.under_reset);
      @(negedge sha3_idle);
      `DV_SPINWAIT_EXIT(forever begin
            // sha3_squeeze goes high one cycle after KMAC has finished calculating digest,
            @(posedge msg_digest_done);
            // latch whether we are doing a KMAC_APP op to accurately
            // determine when to raise sha3_squeeze
            is_kmac_app_op = in_kmac_app;
            // don&#39;t have to wait if manually squezing, squeeze status goes high immediately
            // since immediate transition back into processing state
            if (checked_kmac_cmd != CmdManualRun) begin
              cfg.clk_rst_vif.wait_clks(1);
            end
            sha3_squeeze = 1;
            `uvm_info(`gfn, &quot;raised sha3_squeeze&quot;, UVM_HIGH)

            // sha3_squeeze goes low in one of three cases:
            // - manual squeezing is requested
            // - KMAC_APP operation finishes
            // - CmdDone is written
            `DV_SPINWAIT_EXIT(
                @(posedge req_manual_squeeze);
                ,
                wait(checked_kmac_cmd == CmdDone || (is_kmac_app_op &amp;&amp; !in_kmac_app));
            )
            sha3_squeeze = 0;
            `uvm_info(`gfn, &quot;dropped sha3_squeeze&quot;, UVM_HIGH)
          end, @(posedge sha3_idle or posedge cfg.under_reset);)
    end
  endtask

  // This is a simple task that just polls for any changes in the SHA3 status bits and samples them
  virtual task sample_sha3_status();
    forever begin
      @(negedge cfg.under_reset);
      `DV_SPINWAIT_EXIT(forever begin
            @(sha3_idle or sha3_absorb or sha3_squeeze);
            #0;
            cov.sha3_status_cg.sample(sha3_idle, sha3_absorb, sha3_squeeze);
          end, @(posedge cfg.under_reset);)
    end
  endtask

  // This task handles asserting the `kmac_done` interrupt bit
  virtual task process_intr_kmac_done();
    @(negedge cfg.under_reset);
    forever begin
      wait(!cfg.under_reset);
      @(negedge sha3_idle);
      `DV_SPINWAIT_EXIT(wait(sha3_squeeze);
          // Done interrupt goes high 1 cycle after reaching sha3_squeeze state
          cfg.clk_rst_vif.wait_clks(1);
          #0;
          // only assert kmac_done intr when not in KMAC_APP mode
          if (!in_kmac_app) intr_kmac_done = 1;
          `uvm_info(`gfn, &quot;raised intr_kmac_done&quot;, UVM_HIGH),
                        // we stop processing the kmac_done interrupt when either:
          // - a reset occurs
          // - a KMAC_APP operation finishes
          // - more digest is manually squeezed
          // - CmdDone command is written
          @(posedge cfg.under_reset or negedge in_kmac_app or
            checked_kmac_cmd inside {CmdManualRun, CmdDone});)
    end
  endtask

  // This task implements a timing model to track processing of the KMAC header
  // (consisting of the prefix and secret keys), and asserts `prefix_and_keys_done` once
  // the processing is complete.
  // Naturally this only applies if KMAC mode is enabled.
  virtual task process_prefix_and_keys();
    @(negedge cfg.under_reset);
    forever begin
      wait(!cfg.under_reset);
      wait(!kmac_err.valid);
      `DV_SPINWAIT_EXIT(forever begin
            // Wait for KMAC to move out of IDLE state, meaning that:
            // - CmdStart has been issued
            // - KMAC_APP op has been started
            `DV_SPINWAIT_EXIT(
                @(negedge sha3_idle);
                ,
                wait(in_kmac_app == 1);
            )
            `uvm_info(`gfn, $sformatf(&quot;detected in_kmac_app: %0d&quot;, in_kmac_app), UVM_HIGH)

            // Only process prefix/key if using KMAC, or if using the application interface
            if (kmac_en || in_kmac_app) begin
              fork
                if (!in_kmac_app) begin : wait_cmd_process_header
                  // We need to be able to detect if a CmdProcess is asserted in the middle of
                  // processing the prefix and keys, as this changes the timing of how msgfifo
                  // is flushed
                  wait(checked_kmac_cmd == CmdProcess);
                  cmd_process_in_header = 1;
                  `uvm_info(`gfn, &quot;seen CmdProcess during prefix and key processing&quot;, UVM_HIGH)
                end : wait_cmd_process_header
                if (in_kmac_app) begin : wait_kmac_app_last_header
                  // We need to be able to detect if the last block of a KMAC_APP request is sent
                  // during processing of the prefix and secret keys, as this changes the timing
                  wait(kmac_app_last == 1);
                  kmac_app_last_in_header = 1;
                  `uvm_info(`gfn, &quot;seen kmac_app_last during prefix and key processing&quot;, UVM_HIGH)
                end
                begin : wait_process_header
                  // Denotes the number of keccak rounds we have to wait for to finish
                  // processing the header (prefix + secret keys).
                  //
                  // This is treated as a separate int variable because it is possible for us
                  // to have to wait only for 1 keccak round - this happens when the ROM or LC
                  // sends data through the application interface.
                  int num_keccak_rounds_in_header;

                  // If KMAC mode enabled, wait for the prefix and keys to be absorbed by keccak.
                  //
                  // Note that both absorptions will take the same number of cycles
                  `uvm_info(`gfn, &quot;starting to wait for prefix and key to be processed&quot;, UVM_HIGH)

                  // if in_kmac_app is detected, we have sampled it right before the
                  // rising clock edge in the same simulation timestep.
                  // We need to synchronize this to the clock edge to avoid having it be caught
                  // when we&#39;re waiting for sha3pad to process everything.
                  if (in_kmac_app) begin
                    cfg.clk_rst_vif.wait_clks(1);

                    // wait for prefix and keys if Keymgr is using KMAC hash
                    // since it sends in secret keys, but only wait for the prefix if
                    // ROM/LC is using KMAC hash, since they only run CShake hash
                    num_keccak_rounds_in_header = (app_mode == AppKeymgr) ? 2 : 1;
                  end else begin
                    // If not using application interface, always will be running KMAC hash,
                    // so wait for both prefix and keys to be processed
                    num_keccak_rounds_in_header = 2;
                  end

                  for (int i = 0; i &lt; num_keccak_rounds_in_header; i++) begin
                    // wait either 21 or 17 cycles for sha3pad logic to send the prefix/key
                    // to the keccak_round logic (this is the keccak rate)
                    cfg.clk_rst_vif.wait_clks(sha3_pkg::KeccakRate[strength]);
                    `uvm_info(`gfn, &quot;finished waiting for sha3pad process&quot;, UVM_HIGH)

                    // wait for the keccak logic to perform KECCAK_NUM_ROUNDS rounds
                    wait_keccak_rounds(.is_key_process(
                      (kmac_en &amp;&amp; entropy_fast_process) ? (i == 1) : 0));

                  end
                  prefix_and_keys_done = 1;
                  `uvm_info(`gfn, &quot;finished processing prefix and keys&quot;, UVM_HIGH)
                  // Ensure that we can correctly capture scenario where CmdProcess is seen on
                  // final cycle of prefix/key processing
                  #0;
                  disable wait_cmd_process_header;
                  disable wait_kmac_app_last_header;
                end : wait_process_header
              join
            end
            @(posedge sha3_idle);
          end, @(cfg.under_reset == 1 or posedge sha3_idle or kmac_err.code == ErrKeyNotValid);)
    end
  endtask

  // This task waits for the keccak logic to complete a full KECCAK_NUM_ROUNDS rounds
  //
  // This task must only be called after sha3pad logic has transmitted all KeccakRate
  // blocks to keccak logic.
  //
  // If unmasked configuration, each round of the keccak will take only a single cycle.
  //
  // If masked configuration, each round of the keccak can take a variable number of cycles.
  //
  // Disabling fast entropy means that the internal 320-bit entropy state needs to be &quot;refilled&quot; for
  // each round, adding a 5 cycle latency as 64-bits are &quot;filled&quot; at a time from the internal LFSR.
  // So, each round will take ENTROPY_FULL_EXPANSION_CYCLES (7) cycles.
  //
  // Enabling fast entropy means that entropy will only be fully expanded during processing
  // of the secret key block (only applicable for KMAC hashing), each of these rounds will be the
  // same length as before.
  // During non-key-processing keccak rounds, entropy will be reused rather than fully expanded to
  // improve performance, so each round will take ENTROPY_FAST_PROCESSING_CYCLES cycles.
  //
  // If SW entropy is used, the length of each cycle depends mostly on whether fast entropy
  // processing is enabled/disabled.
  // If new SW entropy is written in the middle of a keccak round, keccak will block until the
  // updates are complete and the fresh entropy is expanded.
  //
  // If entropy from the EDN is used, KMAC will automatically send a request to EDN after reset
  // for some fresh entropy.
  //
  // The very first keccak round (round 0) will block until EDN responds with fresh entropy and KMAC
  // internally expands it - the length of the remaining keccak rounds will depend on whether fast
  // entropy is enabled/disabled.
  //
  // After finishing a full hash operation, KMAC sends another request to EDN to refresh its
  // entropy.
  // Next time keccak rounds start round 0 will take the usual amount of cycles, but round 1
  // will block until the EDN request is fulfilled and fresh entropy is provided to the KMAC.
  //
  // The logic in this task is relatively straightforward and implements the described behavior
  // in the timing model.
  virtual task wait_keccak_rounds(bit is_key_process = 1&#39;b0, bit wait_for_run_latch = 1&#39;b1);
    int unsigned cycles_first_round = 0;
    int unsigned cycles_per_round = 0;

    // This bit is used to indicate that a full entropy expansion is necessary.
    // A full entropy expansion will occur on the very first time that keccak rounds run after the
    // design comes out of a reset, requiring that every round take the full 7 cycles (unless fast
    // processing is enabled).
    bit full_entropy_expansion = 0;

    in_keccak_rounds = 1;

    // insert zero delay to ensure all entropy-related updates have settled
    //
    // this also helps catch an edge case where EDN returns valid entropy
    // on the same timestep that this task starts on
    #0;

    `uvm_info(`gfn, &quot;entered wait_keccak_rounds&quot;, UVM_HIGH)

    // Keccak logic needs 1 cycle to latch internal control signal
    // after sha3pad finishes transmitting prefix/key data blocks
    if (wait_for_run_latch) cfg.clk_rst_vif.wait_clks(1);

    if (cfg.enable_masking) begin
      // If masking is enabled then entropy is used,
      // timing is more complex because of the various entropy features

      if (entropy_mode inside {EntropyModeSw, EntropyModeEdn}) begin

        // If using entropy from EDN, need to check whether the request is due to the request
        // being sent immediately out of reset once KMAC starts operation.
        if (entropy_mode == EntropyModeEdn) begin
          if (in_edn_fetch &amp;&amp; first_op_after_rst) begin
            full_entropy_expansion = 1;
          end
        end

        if (entropy_fast_process &amp;&amp; !is_key_process) begin
          // fast entropy enabled and we are not processing the secret keys
          cycles_per_round = ENTROPY_FAST_PROCESSING_CYCLES;
        end else if (full_entropy_expansion) begin
          cycles_per_round = ENTROPY_FULL_EXPANSION_CYCLES;
        end else begin
          // in the normal case, first round will take 3 cycles as expansion is handled during
          // sha3pad operation, and each following round takes 7 cycles for full entropy expansion
          cycles_first_round = ENTROPY_FAST_PROCESSING_CYCLES;
          cycles_per_round   = ENTROPY_FULL_EXPANSION_CYCLES;
        end
      end else begin
        // TODO : this is an error case
      end

    end else begin
      // If masking is disabled then no entropy is used,
      // so just wait KECCAK_NUM_ROUNDS cycles
      cycles_per_round = 1;
    end

    `uvm_info(`gfn, &quot;starting to wait for keccak&quot;, UVM_HIGH)

    `uvm_info(`gfn, $sformatf(&quot;cycles_first_round: %0d&quot;, cycles_first_round), UVM_HIGH)
    `uvm_info(`gfn, $sformatf(&quot;cycles_per_round: %0d&quot;, cycles_per_round), UVM_HIGH)

    `uvm_info(`gfn, $sformatf(&quot;full_entropy_expansion: %0d&quot;, full_entropy_expansion), UVM_HIGH)

    for (int i = 0; i &lt; KECCAK_NUM_ROUNDS; i++) begin
      if (i == 0) begin
        if (full_entropy_expansion) begin
          wait(in_edn_fetch == 0);
          cfg.clk_rst_vif.wait_clks(1 + ENTROPY_FULL_EXPANSION_CYCLES);
        end else begin
          bit fresh_entropy_ready = 0;
          // We need to be able to detect cases where fresh entropy is provided during the first
          // keccak round, so we spawn a subprocess `wait_fresh_entropy` to raise a signal bit if
          // this scenario is detected.
          //
          // If it is detected, we must wait for some extra cycles to allow the entropy to be
          // readied internally.
          fork
            begin : wait_fresh_entropy
              @(negedge in_edn_fetch);
              fresh_entropy_ready = 1;
              `uvm_info(`gfn, &quot;raised fresh_entropy_ready&quot;, UVM_HIGH)
            end : wait_fresh_entropy
            begin : wait_first_keccak_round
              if (cycles_first_round != 0) begin
                cfg.clk_rst_vif.wait_clks(cycles_first_round);
              end else begin
                cfg.clk_rst_vif.wait_clks(cycles_per_round);
              end
              disable wait_fresh_entropy;
            end : wait_first_keccak_round
          join
          if (fresh_entropy_ready) begin
            // 2 cycles total
            cfg.clk_rst_vif.wait_clks(2);
          end
        end
      end else if (i == 1 &amp;&amp; refresh_entropy) begin
        // If entropy is simply refreshed after the end of previous hashing operation,
        // keccak round 0 will run as normal, but round 1 will block until entropy is refreshed
        wait(refresh_entropy == 0);
        cfg.clk_rst_vif.wait_clks(1 + ENTROPY_FULL_EXPANSION_CYCLES);
      end else begin
        cfg.clk_rst_vif.wait_clks(cycles_per_round);
      end
    end

    // need to wait for one final cycle for sha3 wrapper logic to latch Keccak `complete` signal
    //
    // pulse `keccak_complete_cycle` to allow other parts of the scb to handle some edge cases
    keccak_complete_cycle = 1;
    cfg.clk_rst_vif.wait_clks(1);
    keccak_complete_cycle = 0;

    in_keccak_rounds = 0;

    `uvm_info(`gfn, &quot;finished waiting for keccak&quot;, UVM_HIGH)
  endtask

  // This task implements a timing model to correctly assert the `msg_digest_done`signal,
  // and also tracks the read interface to the msgfifo, as both are linked.
  //
  // An important thing to note is that out of all current application interfaces, only AppKeymgr
  // uses the full KMAC cipher, involving prefix, keys, encoded output length, etc...
  // Both the ROM and LC application interfaces use the explicit CShake cipher,
  // which (from a timing perspective) behaves almost identially to that of Shake cipher,
  // with the exception that CShake needs to wait for the prefix to be processed.
  virtual task process_initial_digest();
    bit do_increment;
    bit cmd_process_in_keccak_and_blocks_left;
    bit run_final_keccak;

    // Indicates whether the full message is an 8-byte multiple
    //
    // If AppKeymgr is being used, we need to add 3 to the full message
    // size, as KMAC will append the 3-byte encoded output length before
    // pushing into the msgfifo
    bit partial_msg;

    bit block_ready_after_flush_keccak = 0;

    bit cmd_process_after_prefix_and_small_msg;

    forever begin
      wait(!cfg.under_reset);
      `DV_SPINWAIT_EXIT(wait(sha3_idle == 0);, wait(in_kmac_app == 1);)

      // reset internal task state on each iteration
      do_increment = 0;
      cmd_process_in_keccak_and_blocks_left = 0;
      kmac_app_last_in_keccak = 0;
      cmd_process_after_prefix_and_small_msg = 0;

      // If KMAC mode enabled, the msgfifo will only be read from once
      // the prefix and keys have been processed.
      //
      // This is guaranteed to happen after sha3_idle goes low, as the prefix and keys only start
      // being processed once the DUT receives CmdStart command.
      if (kmac_en || in_kmac_app) begin
        @(posedge prefix_and_keys_done);

        // Though KMAC_APP mode will instantly start transmitting data to the msgfifo without a delay,
        // we still need to wait for a cycle to start incrementing the fifo pointers and
        // num_blocks_filled
        cfg.clk_rst_vif.wait_clks(1);

        if (!in_kmac_app) begin

          // There is a particularly tricky edge case where addr_phase_write of a CmdProcess command
          // is detected one cycle after KMAC finishes processing the prefix and secret keys.
          //
          // If this happens we need to directly increment fifo_rd_ptr and num_blocks_filled,
          // since we can only detect this scenario at the very end of the simulation timestep.
          //
          // Set `cmd_process_in_header` upon detecting this case so that we carry out
          // proper timing behavior.
          #0;
          if (checked_kmac_cmd == CmdProcess &amp;&amp; !cmd_process_in_header) begin
            `uvm_info(`gfn, &quot;detected CmdProcess 1 cycle after process prefix/key&quot;, UVM_HIGH)
            // if we hit this edge case but only have a single fifo entry,
            // need to wait for 4 cycles for fifo flushing
            if (msg.size() &gt; KMAC_FIFO_BYTES_PER_ENTRY) begin
              cmd_process_in_header = 1;
              fifo_rd_ptr++;
              num_blocks_filled++;
            end else if (`CALC_PARTIAL_MSG) begin
              cmd_process_after_prefix_and_small_msg = 1;
            end
            cfg.clk_rst_vif.wait_clks(1);
          end
        end
        `uvm_info(`gfn, &quot;finished waiting for prefix/key processing&quot;, UVM_HIGH)
      end

      `uvm_info(`gfn, &quot;starting to handle msgfifo writes&quot;, UVM_HIGH)

      `DV_SPINWAIT_EXIT(fork
            // This subprocess handles the control logic for when we are allowed
            // to increment the fifo_rd_ptr
            begin : process_msg_block
              // Starting immediately after either:
              //
              // - prefix and keys have been processed in KMAC mode,
              // - message has started being sent into the msgfifo
              //
              // Once we have a full set of blocks (21 or 17 blocks of 64-bits) of input message,
              // we must wait for this data to be process via a full keccak round before we can start
              // reading more data from the msgfifo
              forever begin
                do_increment = 0;
                run_final_keccak = 0;
                block_ready_after_flush_keccak = 0;
                partial_msg = 0;
                if (num_blocks_filled &lt; sha3_pkg::KeccakRate[strength]) begin
                  `uvm_info(`gfn,
                      $sformatf(&quot;not enough blocks filled yet %0d/%0d&quot;,
                                num_blocks_filled, sha3_pkg::KeccakRate[strength]),
                      UVM_HIGH)
                  if ((!in_kmac_app &amp;&amp; checked_kmac_cmd == CmdProcess) ||
                      (in_kmac_app &amp;&amp; kmac_app_last)) begin
                    `uvm_info(`gfn, &quot;detected CmdProcess&quot;, UVM_HIGH)

                    `uvm_info(`gfn, $sformatf(&quot;fifo_rd_ptr: %0d&quot;, fifo_rd_ptr), UVM_HIGH)
                    `uvm_info(`gfn, $sformatf(&quot;fifo_wr_ptr: %0d&quot;, fifo_wr_ptr), UVM_HIGH)
                    `uvm_info(`gfn, $sformatf(&quot;msg.size() : %0d&quot;, msg.size()), UVM_HIGH)

                    // On a size 0 input message, simply wait 2 cycles for flushing and then
                    // wait for keccak rounds to run
                    //
                    // Note that when using the KMAC_APP application interface the message
                    // cannot have size 0 so we can skip this condition entirely
                    if (!in_kmac_app &amp;&amp; msg.size() == 0) begin
                      `uvm_info(`gfn, &quot;zero size message&quot;, UVM_HIGH)
                      cfg.clk_rst_vif.wait_clks(3);
                      run_final_keccak = 1;
                    end else begin
                      // If we get here it means that we don&#39;t have a full set of blocks ready for
                      // the keccak logic.
                      // As a result, we must now wait until the fifo has been completely flushed
                      // and is completely empty.

                      // This bit is used to detect scenario when a new block is written to msgfifo
                      // during the 2 cycle flushing process, timing needs to change accordingly
                      bit incr_fifo_wr_in_flush = 0;

                      // Always enter this condition if not using the KMAC_APP interface.
                      //
                      // If using the KMAC_APP interface only enter this condition if:
                      // - ROM/LC application interface is being used
                      // - there are still pending data blocks that need to be processed
                      // - kmac_app_last is seen during keccak hashing of full data block
                      // - kmac_app_last is seen during processing of the prefix and secret key
                      if (!in_kmac_app || app_mode != AppKeymgr || !fifo_empty ||
                          kmac_app_last_in_keccak || kmac_app_last_in_header) begin
                        // This bit represents whether the fifo depthis 0 at this point in time
                        bit cmd_process_fifo_depth = (fifo_depth == 0);

                        // If all of the following conditions are NOT true:
                        //  - we are in KMAC_APP mode
                        //  - we&#39;ve seen CmdProcess during an earlier keccak run and still have
                        //    some data left in msgfifo/sha3pad
                        //  - we&#39;ve seen CmdProcess while processing prefix and secret keys
                        //    (only in KMAC mode)
                        //  - the input msg is longer than the total KeccakRate block size
                        // Wait for the msgfifo to be flushed, while simultaneously detecting
                        // for a msgfifo write during the flushing process
                        if (!in_kmac_app &amp;&amp; !cmd_process_in_keccak_and_blocks_left &amp;&amp;
                            !cmd_process_in_header &amp;&amp; cmd_process_fifo_depth) begin
                          // If fifo_wr_ptr increments on the same cycle that we start flushing,
                          // need to immediately increment fifo_rd_ptr to match.
                          if (incr_fifo_wr_in_process) begin
                            do_increment = 1;
                            num_blocks_filled++;
                          end
                          // This section waits several cycles for the flushing process to
                          // be completed, while also checking for an edge case where a fifo write
                          // goes through on the same cycle as the flush
                          fork
                            if (!incr_fifo_wr_in_process) begin : wait_fifo_wr_in_flush
                              // If the fifo write pointer is incremented while we are flushing,
                              // we need to wait for another 2 cycles for the data to be correctly
                              // latched by the flushing logic.
                              // We can also increment the fifo_rd_ptr and increment
                              // num_blocks_filled as a result.
                              @(fifo_wr_ptr);
                              incr_fifo_wr_in_flush = 1;
                              do_increment = 1;
                              num_blocks_filled++;
                              `uvm_info(`gfn, &quot;seen fifo_wr_ptr increment during flushing&quot;, UVM_HIGH)
                            end : wait_fifo_wr_in_flush

                            begin : wait_flush_cycles
                              // wait 2 cycles for the flushing process
                              `uvm_info(`gfn, &quot;waiting 2 cycles for flushing&quot;, UVM_HIGH)
                              cfg.clk_rst_vif.wait_clks(2);

                              // Extra 1 cycle delay introduced due to the latching of SW command
                              cfg.clk_rst_vif.wait_clks(1);
                              disable wait_fifo_wr_in_flush;
                            end : wait_flush_cycles
                          join

                          if (incr_fifo_wr_in_flush || incr_fifo_wr_in_process) begin
                            if (incr_fifo_wr_in_process) begin
                              do_increment = 1;
                              cfg.clk_rst_vif.wait_n_clks(1);
                              do_increment = 0;
                            end
                            cfg.clk_rst_vif.wait_clks(2);
                          end
                        end

                        // Wait for all remaining blocks in msgfifo to flush out to sha3pad
                        while (fifo_wr_ptr != fifo_rd_ptr) begin
                          do_increment = 1;

                          if (!(cmd_process_after_prefix_and_small_msg &amp;&amp;
                                incr_fifo_wr_in_process)) begin
                            num_blocks_filled++;
                          end

                          `uvm_info(`gfn,
                                    $sformatf(&quot;increment num_blocks_filled: %0d&quot;,
                                              num_blocks_filled),
                                    UVM_HIGH)
                          `uvm_info(`gfn, $sformatf(&quot;fifo_rd_ptr: %0d&quot;, fifo_rd_ptr), UVM_HIGH)
                          `uvm_info(`gfn, $sformatf(&quot;fifo_wr_ptr: %0d&quot;, fifo_wr_ptr), UVM_HIGH)

                          // wait until next timestep to ensure all state updates have settled
                          #1;
                          if (fifo_empty) begin
                            `uvm_info(`gfn, &quot;fifo is empty, exiting while loop&quot;, UVM_HIGH)
                            // If any of the following conditions are true:
                            //
                            //  - we&#39;ve seen CmdProcess during an earlier keccak run and still have
                            //    some data left in msgfifo/sha3pad
                            //  - we&#39;ve seen CmdProcess while processing prefix and secret keys
                            //    (only in KMAC mode)
                            //  - we are in KMAC_APP mode (meaning that kmac_app_last was seen
                            //    during prefix/key processing or during a
                            //    keccak data hashing round)
                            //
                            // Wait for the fifo to correctly transition through flush states,
                            // waiting an extra cycle delay if the `incr_fifo_wr_in_process`
                            // condition was met.
                            if (in_kmac_app || cmd_process_in_keccak_and_blocks_left ||
                                cmd_process_in_header || !cmd_process_fifo_depth) begin
                              cfg.clk_rst_vif.wait_clks(3);
                              if (incr_fifo_wr_in_process) begin
                                cfg.clk_rst_vif.wait_clks(1);
                              end
                              if (!in_kmac_app) begin // TODO
                                num_blocks_filled++;
                              end
                            end
                            break;
                          end else begin
                            // unset `do_increment` on the negedge to avoid infinite increments
                            cfg.clk_rst_vif.wait_n_clks(1);
                            do_increment = 0;
                          end
                          // If all blocks get filled up while we&#39;re flushing the fifo,
                          // run full keccak rounds on these blocks
                          if (num_blocks_filled == sha3_pkg::KeccakRate[strength]) begin

                            // Indicates whether the full message is an 8-byte multiple
                            //
                            // If AppKeymgr is being used, we need to add 3 to the full message
                            // size, as KMAC will append the 3-byte encoded output length before
                            // pushing into the msgfifo
                            partial_msg = `CALC_PARTIAL_MSG;

                            `uvm_info(`gfn,
                                      &quot;all blocks full while flushing fifo, running keccak rounds&quot;,
                                      UVM_HIGH)
                            `uvm_info(`gfn, $sformatf(&quot;partial_msg: %0d&quot;, partial_msg), UVM_HIGH)

                            // fifo_rd_ptr can keep incrementing as the keccak rounds start
                            // if there are still more blocks to be flushed.
                            //
                            // keep track of them and increment num_blocks_filled accordingly
                            // after keccak round has finished
                            block_ready_after_flush_keccak = (fifo_wr_ptr &gt; fifo_rd_ptr);

                            if (block_ready_after_flush_keccak &amp;&amp; partial_msg) begin
                              cfg.clk_rst_vif.wait_clks(1);
                              do_increment = 1;
                              cfg.clk_rst_vif.wait_n_clks(1);
                              do_increment = 0;
                            end

                            wait_keccak_rounds();
                            num_blocks_filled = 0;
                            cfg.clk_rst_vif.wait_clks(1);

                            if (block_ready_after_flush_keccak &amp;&amp; partial_msg) begin
                              cfg.clk_rst_vif.wait_clks(1);
                              num_blocks_filled++;
                            end

                            continue;
                          end
                          cfg.clk_rst_vif.wait_clks(1);
                        end
                      end else if (app_mode == AppKeymgr) begin
                        // if we get here, we are dealing with a KeyMgr application request,
                        // and `kmac_app_last` has been set.
                        //
                        // usually we will wait 4 cycles for a KMAC_APP op to finish flushing out the
                        // fifo and start runnning the rest of sha3pad process, with exception of
                        // some edge cases.
                        // use this bit to indicate when we should wait for these cycles.
                        bit wait_kmac_app_flush = 1;

                        // Similar timing logic as in `process_msgfifo_write()`
                        if (kmac_app_block_strb_size == keymgr_pkg::KmacDataIfWidth/8) begin
                          do_increment = 1;
                          num_blocks_filled++;
                          cfg.clk_rst_vif.wait_n_clks(1);
                          do_increment = 0;
                          if (num_blocks_filled == sha3_pkg::KeccakRate[strength]) begin
                            `uvm_info(`gfn,
                                      &quot;filled up blocks while processing full kmac_app_last block&quot;,
                                      UVM_HIGH)
                            wait_keccak_rounds();
                            num_blocks_filled = 0;
                            // if need to run keccak rounds, fifo_rd_ptr increments one cycle later
                            // to transmit encoded output length to sha3pad
                            cfg.clk_rst_vif.wait_clks(1);
                          end else begin
                            // in the normal scenario, fifo_rd_ptr will increment 2 cycles later
                            // to transmit encoded output length to sha3pad logic
                            cfg.clk_rst_vif.wait_clks(2);
                          end
                          // increment fifo_rd_ptr to account for the block of encoded output length
                          do_increment = 1;
                          cfg.clk_rst_vif.wait_n_clks(1);
                          do_increment = 0;
                        end else if (kmac_app_block_strb_size + 3 &lt;
                                     keymgr_pkg::KmacDataIfWidth/8) begin
                          cfg.clk_rst_vif.wait_clks(2);
                          do_increment = 1;
                          cfg.clk_rst_vif.wait_n_clks(1);
                          do_increment = 0;
                        end else if (kmac_app_block_strb_size + 3 &gt;=
                                     keymgr_pkg::KmacDataIfWidth/8) begin
                          cfg.clk_rst_vif.wait_clks(1);
                          do_increment = 1;
                          num_blocks_filled++;
                          cfg.clk_rst_vif.wait_n_clks(1);
                          do_increment = 0;
                          if (kmac_app_block_strb_size + 3 &gt; keymgr_pkg::KmacDataIfWidth/8) begin
                            cfg.clk_rst_vif.wait_clks(1);
                            do_increment = 1;
                            cfg.clk_rst_vif.wait_n_clks(1);
                            do_increment = 0;
                          end
                          if (num_blocks_filled == sha3_pkg::KeccakRate[strength]) begin
                            wait_kmac_app_flush = 0;
                            `uvm_info(`gfn,
                                      &quot;filled up blocks while processing overflow kmac_app_last block&quot;,
                                      UVM_HIGH)
                            wait_keccak_rounds();
                            num_blocks_filled = 0;
                            cfg.clk_rst_vif.wait_clks(2);
                            num_blocks_filled++;
                          end
                        end
                        // wait the 4 cycles for KMAC_APP flushing to finish
                        if (wait_kmac_app_flush) begin
                          cfg.clk_rst_vif.wait_clks(4);
                          num_blocks_filled++;
                        end
                      end

                      run_final_keccak = 1;
                    end

                    if (run_final_keccak) begin
                      `uvm_info(`gfn,
                          $sformatf(&quot;waiting %0d cycles for sha3pad&quot;,
                                    sha3_pkg::KeccakRate[strength] - num_blocks_filled),
                          UVM_HIGH)
                      cfg.clk_rst_vif.wait_clks(sha3_pkg::KeccakRate[strength] - num_blocks_filled);

                      wait_keccak_rounds();

                      num_blocks_filled = 0;

                      // signal that the initial hash round has been completed
                      `uvm_info(`gfn, &quot;raising msg_digest_done&quot;, UVM_HIGH)
                      msg_digest_done = 1;
                    end

                  end else begin
                    // we still don&#39;t have a full set of blocks to send to keccak yet.
                    //
                    // at this point, one of two things can happen:
                    //  1) more message can be written into the fifo, in which case we keep tracking
                    //  2) CmdProcess is written, meaning that we execute an earlier block of code
                    //     on the next cycle and flush out the remaining data to the keccak logic
                    //
                    // if another full block is written, increment the `num_blocks_filled` tracker
                    // and continue to the next cycle.
                    //
                    // Add a zero delay here to ensure all fifo-related state is correctly updated
                    #0;
                    `uvm_info(`gfn, &quot;don&#39;t have a full set of blocks yet&quot;, UVM_HIGH)
                    `uvm_info(`gfn,
                              $sformatf(&quot;num_blocks_filled: %0d&quot;,
                                        num_blocks_filled),
                              UVM_HIGH)
                    `uvm_info(`gfn, $sformatf(&quot;fifo_wr_ptr: %0d&quot;, fifo_wr_ptr), UVM_HIGH)
                    `uvm_info(`gfn, $sformatf(&quot;fifo_rd_ptr: %0d&quot;, fifo_rd_ptr), UVM_HIGH)
                    if (fifo_wr_ptr &gt; fifo_rd_ptr) begin
                      `uvm_info(`gfn, &quot;have enough to fill another block&quot;, UVM_HIGH)
                      num_blocks_filled++;
                      `uvm_info(`gfn,
                                $sformatf(&quot;increment num_blocks_filled: %0d&quot;,
                                          num_blocks_filled),
                                UVM_HIGH)
                      do_increment = 1;
                    end

                    // Unset do_increment to avoid infinitely incrementing it
                    cfg.clk_rst_vif.wait_n_clks(1);
                    do_increment = 0;

                    // If we now have a full set of blocks, do not wait a cycle to start running
                    // keccak, go straight to the next iteration of the loop and start running
                    // immediately.
                    if (num_blocks_filled == sha3_pkg::KeccakRate[strength]) begin
                      continue;
                    end
                  end
                end else if (num_blocks_filled == sha3_pkg::KeccakRate[strength]) begin
                  // If we have filled up an entire set of blocks, we must immediately send it off
                  // to the keccak logic for hashing to be performed.
                  //
                  // During the time that keccak logic is active, need to detect an incoming
                  // CmdProcess request (only if not in KMAC_APP mode).
                  // If we see a CmdProcess be written, we can assert `msg_digest_done`
                  // after the current hash is complete.

                  bit sw_process_seen_in_keccak = 0;

                  bit sw_process_and_keccak_complete = 0;

                  `uvm_info(`gfn,
                            &quot;filled up keccak input blocks, sending to keccak to process&quot;,
                            UVM_HIGH)

                  fork
                    begin : wait_for_cmd_process
                      wait(checked_kmac_cmd == CmdProcess);
                      sw_process_seen_in_keccak = 1;
                      `uvm_info(`gfn, &quot;raised sw_process_seen_in_keccak&quot;, UVM_HIGH)
                      if (keccak_complete_cycle) begin
                        sw_process_and_keccak_complete = 1;
                        `uvm_info(`gfn, &quot;raised sw_process_and_keccak_complete&quot;, UVM_HIGH)
                      end
                    end : wait_for_cmd_process

                    begin : wait_for_kmac_app_last
                      wait(kmac_app_last == 1);
                      kmac_app_last_in_keccak = 1;
                    end : wait_for_kmac_app_last

                    begin : keccak_process_blocks
                      // The logic to determine whether we have a message only partially filling up
                      // the final block is the exact same as earlier in the scb.
                      //
                      // Again, note that we add 3 to the message size when using AppKeymgr app
                      // interface to account for the KMAC internally appending the 24-bit encoded
                      // output length before pushing into msgfifo.
                      partial_msg = `CALC_PARTIAL_MSG;
                      do_increment = 0;
                      num_blocks_filled = 0;
                      #0;
                      if (checked_kmac_cmd == CmdProcess &amp;&amp; partial_msg) begin
                        do_increment = 1;
                        cfg.clk_rst_vif.wait_n_clks(1);
                        do_increment = 0;
                        // TODO - this still might be required.
                        //cfg.clk_rst_vif.wait_clks(1);
                      end
                      wait_keccak_rounds();

                      disable wait_for_cmd_process;
                      disable wait_for_kmac_app_last;
                    end : keccak_process_blocks
                  join

                  // zero delay to wait for fifo pointers and kmac_app status to settle
                  #0;

                  // handle edge case where kmac_app_last is detected on the same cycle
                  // that we finish waiting for the keccak rounds
                  if (in_kmac_app &amp;&amp; !kmac_app_last_in_keccak) begin
                    if (kmac_app_last) kmac_app_last_in_keccak = 1;
                  end

                  if (sw_process_seen_in_keccak) begin
                     `uvm_info(`gfn, &quot;detected sw_cmd_process during keccak operation&quot;, UVM_HIGH)
                    if (fifo_empty) begin
                      // we have seen CmdProcess be written during operation of the keccak logic,
                      // meaning that the message byte length is an exact multiple of the keccak
                      // block size.
                      //
                      // as a result, there will be one more round of sha3pad data transfer and keccak
                      // logic after this to account for the `pad10*1()` bytes.
                      //
                      // Wait 1 cycle for flushing
                      cfg.clk_rst_vif.wait_clks(1);
                      // If the SW CmdProcess is seen on the same cycle as the keccak complete
                      // signal asserting, need to wait an extra cycle before starting the
                      // final keccak rounds
                      if (sw_process_and_keccak_complete) begin
                        cfg.clk_rst_vif.wait_clks(1);
                        sw_process_and_keccak_complete = 0;
                      end
                      // Wait for sha3pad to transmit all blocks to the keccak logic
                      cfg.clk_rst_vif.wait_clks(sha3_pkg::KeccakRate[strength]);
                      wait_keccak_rounds();
                      // signal that the initial hash round has been completed
                      `uvm_info(`gfn, &quot;raising msg_digest_done&quot;, UVM_HIGH)
                      msg_digest_done = 1;
                    end else begin
                      // If CmdProcess has been issued during keccak processing but we still have
                      // data left in the fifo, blocks will continue being sent to the
                      // sha3pad on the next cycle until the msgfifo is empty.
                      cmd_process_in_keccak_and_blocks_left = 1;
                      `uvm_info(`gfn, &quot;we still have blocks left to process&quot;, UVM_HIGH)
                    end
                  end else if (kmac_app_last_in_keccak) begin
                    `uvm_info(`gfn, &quot;detected kmac_app_last during keccak operation&quot;, UVM_HIGH)
                  end else begin
                    `uvm_info(`gfn, &quot;did not detect sw_cmd_process during keccak operation, continue normal operation&quot;, UVM_HIGH)
                  end

                end else begin
                  `uvm_fatal(`gfn,
                      $sformatf(&quot;num_blocks_filled[%0d] &gt; KeccakRate[strength][%0d]&quot;,
                                num_blocks_filled, sha3_pkg::KeccakRate[strength]))
                end
                cfg.clk_rst_vif.wait_clks(1);
              end

            end : process_msg_block

            // This subprocess handles the actual incrementation of fifo_rd_ptr
            begin : increment_fifo_rd_ptr
              forever begin
                wait((fifo_wr_ptr &gt; fifo_rd_ptr) &amp;&amp; do_increment);

                fifo_rd_ptr++;
                `uvm_info(`gfn, $sformatf(&quot;incremented fifo_rd_ptr: %0d&quot;, fifo_rd_ptr), UVM_HIGH)
                cfg.clk_rst_vif.wait_clks(1);
              end
            end : increment_fifo_rd_ptr
          join,
                        @(cfg.under_reset == 1 or msg_digest_done == 1 or
            posedge kmac_err.code == ErrKeyNotValid);)
      wait(sha3_idle == 1);
    end
  endtask

  // This task handles updating the `msg_digest_done` value during any requested message squeezing,
  // not handled in `process_initial_digest()` as that is designed to just handle the initial
  // digest calculations and update the fifo pointers accordingly
  //
  // Note that squeezing more output can never happen during KMAC_APP operation
  virtual task process_manual_digest_squeeze();
    @(negedge cfg.under_reset);
    forever begin
      wait(!cfg.under_reset);
      @(negedge sha3_idle);
      `DV_SPINWAIT_EXIT(forever begin
            @(posedge req_manual_squeeze);
            msg_digest_done = 0;
            `uvm_info(`gfn, &quot;dropping msg_digest_done&quot;, UVM_HIGH)

            wait_keccak_rounds(.wait_for_run_latch(1&#39;b1));
            msg_digest_done = 1;
            `uvm_info(`gfn, &quot;raising msg_digest_done&quot;, UVM_HIGH)
          end, wait(cfg.under_reset);)
    end
  endtask

  // This task implements a timing model for the write interface to the msgfifo
  virtual task process_msgfifo_write();
    // This bit is used for in-process synchronization to indicate whether we have seen a CmdProcess
    // being issued and still more message remains in the FIFO
    bit cmd_process_write = 0;
    bit do_increment = 0;
    bit seen_kmac_app_trans_during_incr = 0;
    forever begin
      wait(!cfg.under_reset);
      `DV_SPINWAIT_EXIT(wait(sha3_idle == 0);, wait(in_kmac_app == 1);)
      `DV_SPINWAIT_EXIT(
          // This is a counter to keep track of data blocks that have been sent/completed
          // while the fifo is still full
          int num_blocks_seen_while_full = 0;

          forever begin
            // increment the write pointer by default
            do_increment = 1;

            seen_kmac_app_trans_during_incr = 0;

            if (in_kmac_app) begin
              // If executing a KMAC_APP op, the FIFO write pointer should increment every time
              // a new request item is sent from the application Host (otp_ctrl/rom_ctrl/keymgr),
              // as the app interfae mandates that each data transfer be at a 64-bit granularity.
              //
              // Note that we can still safely increment the fifo_wr_ptr on the KMAC_APP input
              // transaction where the `last` bit is set, as no more data will be sent until
              // either a reset is detected or until after the current transaction finishes.
              wait(got_data_from_kmac_app == 1);
              `uvm_info(`gfn, &quot;got data from kmac_app&quot;, UVM_HIGH)

              // Note that when using the app interface, 0x2_0001 is appended to the last msgfifo
              // block to be filled (the encoded output length - output fixed at 256b), so we need
              // to account for this when incrementing the fifo_wr_ptr.
              //
              // As a result, 4 scenarios can happen when last data beat sent on the KMAC_APP interface:
              //
              // - A full data block is sent as the last data beat.
              //   When this happens, fifo_wr_ptr is incremented after one cycle as normal,
              //   but then needs to be incremented again after 2 more cycles to account for
              //   the encoded output length (0x2_0001).
              // - Second scenario occurs when the final data block appended to encoded output
              //   length is &lt; 64bits.
              //   In this case, wait 1 cycle for appending the output length, then 2 cycles later
              //   fifo_wr_ptr is incremented.
              // - Third scenario occurs when final data block appended to encoded output length
              //   is exactly 64 bits.
              //   In this case, wait 1 cycle to append the output length, then 1 cyle later
              //   fifo_wwr_ptr is incremented.
              // - Final case is when the final data block appended to encoded output length is
              //   &gt;64bits.
              //   In this case, wait 1 cycle for appending the output length, then fifo_wr_ptr is
              //   incremented twice in a row on 2 consecutive cycles to account for the overflow.
              //
              // Note that since the encoded output length is 0x2_0001, the mask size necessary for
              // just this segment is 3.
              if (kmac_app_last) begin
                `uvm_info(`gfn, $sformatf(&quot;kmac_app_block_strb_size: %0d&quot;, kmac_app_block_strb_size), UVM_HIGH)
                `uvm_info(`gfn, &quot;kmac_app_last detected&quot;, UVM_HIGH)
                if (app_mode != AppKeymgr) begin
                  if (kmac_app_last_in_header || kmac_app_last_in_keccak) begin
                    cfg.clk_rst_vif.wait_clks(1);
                  end
                end else if (kmac_app_block_strb_size == keymgr_pkg::KmacDataIfWidth/8) begin
                  cfg.clk_rst_vif.wait_clks(1);
                  wait(fifo_wr_ptr - fifo_rd_ptr &lt; KMAC_FIFO_DEPTH);
                  fifo_wr_ptr++;
                  cfg.clk_rst_vif.wait_clks(1);
                end else if (kmac_app_block_strb_size + 3 &lt; keymgr_pkg::KmacDataIfWidth/8) begin
                  cfg.clk_rst_vif.wait_clks(2);
                end else if (kmac_app_block_strb_size + 3 == keymgr_pkg::KmacDataIfWidth/8) begin
                  cfg.clk_rst_vif.wait_clks(1);
                end else if (kmac_app_block_strb_size + 3 &gt; keymgr_pkg::KmacDataIfWidth/8) begin
                  cfg.clk_rst_vif.wait_clks(2);
                  wait(fifo_wr_ptr - fifo_rd_ptr &lt; KMAC_FIFO_DEPTH);
                  fifo_wr_ptr++;
                end
              end
            end else begin
              // If not executing a KMAC_APP op, the FIFO write pointer increments in two cases:
              // 1) When KMAC_FIFO_BYTES_PER_ENTRY bytes have been written to msgfifo.
              // 2) when CmdProcess is triggered and there is a non-zero amount of bytes in the msg,
              //    as CmdProcess signals the msg has finished, so need to account for remaining
              //    bytes.
              `uvm_info(`gfn, $sformatf(&quot;fifo_wr_ptr: %0d&quot;, fifo_wr_ptr), UVM_HIGH)
              wait((msg.size() &gt;= ((fifo_wr_ptr + 1) * KMAC_FIFO_BYTES_PER_ENTRY)) ||
                   (checked_kmac_cmd == CmdProcess &amp;&amp; msg.size % KMAC_FIFO_BYTES_PER_ENTRY &gt; 0));

              // If CmdProcess is written, no more message will be written to the fifo,
              // so we should only increment the write pointer if some bytes still have not been
              // processed (up to 1 word.
              //
              // e.g. if we are only able to write 3 bytes into a &quot;fresh&quot; fifo entry before writing
              //      CmdProcess, we should not increment the fifo write pointer as the entry is not
              //      overflowing.
              cmd_process_write = (checked_kmac_cmd == CmdProcess &amp;&amp; msg.size() &gt; 0);
              if (cmd_process_write) begin
                do_increment = (msg.size() &lt; fifo_wr_ptr * KMAC_FIFO_BYTES_PER_ENTRY) ? 0 : 1;
              end
            end

            num_blocks_seen_while_full = 0;

            if (do_increment) begin
              // If fifo is full, wait until it isn&#39;t
              if (fifo_wr_ptr - fifo_rd_ptr == KMAC_FIFO_DEPTH) begin
                `uvm_info(`gfn, &quot;waiting for fifo to not be full&quot;, UVM_HIGH)

                // Track how many data blocks are sent after the fifo has filled up
                // and before it clears up some entries
                `DV_SPINWAIT_EXIT(
                    if (in_kmac_app) begin
                      forever begin
                        wait(got_data_from_kmac_app == 1);
                        num_blocks_seen_while_full++;
                        `uvm_info(`gfn, &quot;incrementing num_blocks_seen_while_full&quot;, UVM_HIGH)
                        cfg.clk_rst_vif.wait_clks(1);
                      end
                    end else begin
                      forever cfg.clk_rst_vif.wait_clks(1);
                    end
                    ,
                    // wait for the fifo to not be full
                    wait(fifo_wr_ptr - fifo_rd_ptr &lt; KMAC_FIFO_DEPTH);
                    `uvm_info(`gfn, &quot;fifo no longer full&quot;, UVM_HIGH)
                )

                `uvm_info(`gfn, $sformatf(&quot;num_blocks_seen_while_full: %0d&quot;, num_blocks_seen_while_full), UVM_HIGH)
              end

              // it&#39;s necessary to spawn a forked process to detect a KMAC_APP transaction
              // that is sent on the same cycle the fifo_wr_ptr is incremented so the
              // scb can safely handle this edge case
              fork
                begin : detect_kmac_app_data_during_incr
                  @(posedge got_data_from_kmac_app);
                  seen_kmac_app_trans_during_incr = 1;
                end : detect_kmac_app_data_during_incr

                begin : update_fifo_wr_ptr
                  // update the fifo_wr_ptr
                  //
                  // need to update multiple consecutive cycles if the fifo becomes full
                  // but data is still being transmitted
                  repeat ((num_blocks_seen_while_full &gt; 0) ? num_blocks_seen_while_full : 1) begin
                    cfg.clk_rst_vif.wait_clks(1);
                    fifo_wr_ptr++;
                    `uvm_info(`gfn, $sformatf(&quot;incremented fifo_wr_ptr: %0d&quot;, fifo_wr_ptr), UVM_HIGH)
                  end

                  incr_fifo_wr_in_process = req_cmd_process_dly;
                  `uvm_info(`gfn,
                            $sformatf(&quot;seen fifo_wr_ptr increment during CmdProcess: %0d&quot;,
                                      incr_fifo_wr_in_process),
                            UVM_HIGH)
                  #0;
                  disable detect_kmac_app_data_during_incr;
                end : update_fifo_wr_ptr
              join

              if (seen_kmac_app_trans_during_incr) begin
                cfg.clk_rst_vif.wait_clks(1);
                fifo_wr_ptr++;
                `uvm_info(`gfn,
                          $sformatf(&quot;incremented fifo_wr_ptr due to a racing KMAC_APP transaction: %0d&quot;,
                                    fifo_wr_ptr),
                          UVM_HIGH)
                continue;
              end

            end
            cfg.clk_rst_vif.wait_clks(1);
          end,
                        @(cfg.under_reset == 1 or msg_digest_done == 1 or
            posedge kmac_err.code == ErrKeyNotValid);)
      `uvm_info(`gfn, &quot;msg is done, stopping processing fifo_wr_ptr&quot;, UVM_HIGH)
      wait(sha3_idle == 1);
    end
  endtask

  // This task implements a timing model to update fifo_empty, fifo_depth, fifo_full status
  virtual task process_msgfifo_status();
    forever begin
      wait(!cfg.under_reset);
      `DV_SPINWAIT_EXIT(fork
            forever begin : update_fifo_state
              @(fifo_wr_ptr, fifo_rd_ptr);

              // update the general fifo status fields
              fifo_depth = fifo_wr_ptr - fifo_rd_ptr;
              fifo_empty = (fifo_depth == 0);
              fifo_full  = fifo_depth == KMAC_FIFO_DEPTH;

              // sample coverage on the fifo status
              if (cfg.en_cov) begin
                cov.msgfifo_level_cg.sample(fifo_empty, fifo_full, fifo_depth,
                                            hash_mode, kmac_en);
              end

              `uvm_info(`gfn, $sformatf(&quot;fifo_depth: %0d&quot;, fifo_depth), UVM_HIGH)
              `uvm_info(`gfn, $sformatf(&quot;fifo_empty: %0d&quot;, fifo_empty), UVM_HIGH)
              `uvm_info(`gfn, $sformatf(&quot;fifo_full: %0d&quot;, fifo_full), UVM_HIGH)
            end : update_fifo_state

            forever begin : update_fifo_intr

              // fifo_empty interrupt will only be asserted if the fifo becomes empty
              // after its depth has been greater than 0 to prevent random assertions
              @(fifo_wr_ptr, fifo_rd_ptr);
              #1;
              if (fifo_wr_ptr &gt; fifo_rd_ptr) begin
                `uvm_info(`gfn, &quot;fifo_wr_ptr is greater than fifo_rd_ptr&quot;, UVM_HIGH)
                while (fifo_wr_ptr != fifo_rd_ptr) begin
                  cfg.clk_rst_vif.wait_clks(1);
                  #1;
                end
                `uvm_info(`gfn, &quot;fifo pointers are now equal&quot;, UVM_HIGH)
                fork
                  begin
                    cfg.clk_rst_vif.wait_clks(2);
                    if (!intr_fifo_empty) intr_fifo_empty = 1;
                    `uvm_info(`gfn, &quot;raised intr_fifo_empty&quot;, UVM_HIGH)
                  end
                join_none;
              end else begin
                continue;
              end
            end : update_fifo_intr
          join, @(posedge sha3_idle or posedge cfg.under_reset);)
    end
  endtask

  virtual task process_tl_access(tl_seq_item item, tl_channels_e channel, string ral_name);
    uvm_reg                    csr;
    dv_base_reg                check_locked_reg;

    string                     csr_name = &quot;&quot;;

    bit                        msgfifo_access;
    bit                        share0_access;
    bit                        share1_access;

    bit                        do_read_check = 1&#39;b1;
    bit                        write = item.is_write();
    uvm_reg_addr_t             csr_addr = ral.get_word_aligned_addr(item.a_addr);
    bit            [TL_AW-1:0] csr_addr_mask = ral.get_addr_mask();

    bit                        addr_phase_read = (!write &amp;&amp; channel == AddrChannel);
    bit                        addr_phase_write = (write &amp;&amp; channel == AddrChannel);
    bit                        data_phase_read = (!write &amp;&amp; channel == DataChannel);
    bit                        data_phase_write = (write &amp;&amp; channel == DataChannel);

    // if access was to a valid csr, get the csr handle
    if (csr_addr inside {cfg.ral_models[ral_name].csr_addrs}) begin
      csr = ral.default_map.get_reg_by_offset(csr_addr);
      `DV_CHECK_NE_FATAL(csr, null)
      `downcast(check_locked_reg, csr)

      csr_name = csr.get_name();

      // if incoming access is a write to valid csr, immediately make updates
      if (addr_phase_write) begin

        // following csrs are locked by CFG_REGWEN:
        // - cfg
        // - entropy_period
        // - entropy_seed_lower
        // - entropy_seed_upper
        // - key_len
        // if writes to these csrs are seen, must check that they are not locked first.
        if (ral.cfg_regwen.locks_reg_or_fld(check_locked_reg) &amp;&amp; `gmv(ral.cfg_regwen) == 0) return;

        void&#39;(csr.predict(.value(item.a_data), .kind(UVM_PREDICT_WRITE), .be(item.a_mask)));
      end
    end else if ((csr_addr &amp; csr_addr_mask) inside {[KMAC_FIFO_BASE : KMAC_FIFO_END]}) begin
      // msgfifo window
      msgfifo_access = 1;
    end else if ((csr_addr &amp; csr_addr_mask) inside {[KMAC_STATE_SHARE0_BASE:KMAC_STATE_SHARE0_END]}) begin
      // state window 0
      share0_access = 1;
    end else if ((csr_addr &amp; csr_addr_mask) inside {[KMAC_STATE_SHARE1_BASE:KMAC_STATE_SHARE1_END]}) begin
      // state window 1
      share1_access = 1;
    end else begin
      `uvm_fatal(`gfn, $sformatf(&quot;Access unexpected addr 0x%0h&quot;, csr_addr))
    end

    // process the csr req
    // for write, update local variable and fifo at address phase
    // for read, update predication at address phase and compare at data phase
    case (csr_name)
      // add individual case item for each csr
      &quot;intr_state&quot;: begin
        `uvm_info(`gfn, $sformatf(&quot;intr_kmac_done: %0d&quot;, intr_kmac_done), UVM_HIGH)
        `uvm_info(`gfn, $sformatf(&quot;intr_fifo_empty: %0d&quot;, intr_fifo_empty), UVM_HIGH)
        `uvm_info(`gfn, $sformatf(&quot;intr_kmac_err: %0d&quot;, intr_kmac_err), UVM_HIGH)

        if (data_phase_write) begin
          // clear internal state on a write
          if (item.a_data[KmacDone]) intr_kmac_done = 0;
          if (item.a_data[KmacFifoEmpty]) intr_fifo_empty = 0;
          if (item.a_data[KmacErr]) intr_kmac_err = 0;
        end else if (data_phase_read) begin
          // sample intr coverage
          if (cfg.en_cov) begin
            bit [       TL_DW-1:0] intr_en = `gmv(ral.intr_enable);
            bit [KmacNumIntrs-1:0] intr_exp = `gmv(ral.intr_state);
            foreach (intr_exp[i]) begin
              cov.intr_cg.sample(i, intr_en[i], item.d_data);
              cov.intr_pins_cg.sample(i, cfg.intr_vif.pins[i]);
            end
          end
        end else if (addr_phase_read) begin

          void&#39;(ral.intr_state.kmac_done.predict(.value(intr_kmac_done), .kind(UVM_PREDICT_READ)));
          void&#39;(ral.intr_state.kmac_err.predict(.value(intr_kmac_err), .kind(UVM_PREDICT_READ)));
          void&#39;(ral.intr_state.fifo_empty.predict(
              .value(intr_fifo_empty), .kind(UVM_PREDICT_READ)
          ));

        end
      end
      &quot;intr_enable&quot;: begin
        // no need to do anything here, functionality is tested in the automated intr tests,
        // and any issues here will become known if any checks on `intr_state` fail
      end
      &quot;intr_test&quot;: begin
        if (addr_phase_write) begin
          bit [TL_DW-1:0] intr_en = `gmv(ral.intr_enable);
          bit [KmacNumIntrs-1:0] intr_exp = item.a_data | `gmv(ral.intr_state);

          void&#39;(ral.intr_state.predict(.value(intr_exp), .kind(UVM_PREDICT_DIRECT)));

          // update internal interrupt tracking variables
          if (intr_exp[KmacDone]) intr_kmac_done = 1;
          if (intr_exp[KmacFifoEmpty]) intr_fifo_empty = 1;
          if (intr_exp[KmacErr]) intr_kmac_err = 1;

          // sample coverage
          if (cfg.en_cov) begin
            foreach (intr_exp[i]) begin
              cov.intr_test_cg.sample(i, item.a_data[i], intr_en[i], intr_exp[i]);
            end
          end
        end
      end
      &quot;cfg_regwen&quot;: begin
        // do nothing
      end
      &quot;cfg&quot;: begin
        if (addr_phase_write) begin
          // don&#39;t continue if the KMAC is currently operating
          if (!sha3_idle) begin
            return;
          end

          kmac_en = item.a_data[KmacEn];
          entropy_fast_process = item.a_data[KmacFastEntropy];
          entropy_ready = item.a_data[KmacEntropyReady];

          hash_mode = sha3_pkg::sha3_mode_e&#39;(item.a_data[KmacModeMSB:KmacModeLSB]);

          strength = sha3_pkg::keccak_strength_e&#39;(item.a_data[KmacStrengthMSB:KmacStrengthLSB]);

          entropy_mode = entropy_mode_e&#39;(item.a_data[KmacEntropyModeMSB:KmacEntropyModeLSB]);

          // sample sideload-related coverage
          if (cfg.en_cov) begin
            cov.sideload_cg.sample(item.a_data[KmacSideload], kmac_en, 0);
          end

          // Entropy mode configuration error
          if (cfg.enable_masking &amp;&amp; !(entropy_mode inside {EntropyModeSw, EntropyModeEdn})) begin
            kmac_err.valid = 1;
            kmac_err.code  = kmac_pkg::ErrIncorrectEntropyMode;
            kmac_err.info  = 24&#39;(entropy_mode);

            predict_err(.is_kmac_err(1));
          end

          // Mode/Strength configuration error
          if ((hash_mode inside {sha3_pkg::Shake, sha3_pkg::CShake} &amp;&amp;
                !(strength inside {sha3_pkg::L128, sha3_pkg::L256})) ||
               (hash_mode == sha3_pkg::Sha3 &amp;&amp;
                strength == sha3_pkg::L128)) begin
            kmac_err.valid = 1;
            kmac_err.code  = kmac_pkg::ErrUnexpectedModeStrength;
            kmac_err.info  = {8&#39;h2, 10&#39;h0, 2&#39;(hash_mode), 1&#39;b0, 3&#39;(strength)};

            predict_err(.is_kmac_err(1));

            // If the mode/strength are mis-configured, the IP will finish running a hash with the
            // incorrect configuration, producing a garbage digest that should not be checked.
            do_check_digest = 1&#39;b0;
          end

          if (entropy_mode == EntropyModeEdn &amp;&amp;
              item.a_data[KmacEntropyReady] &amp;&amp;
              first_op_after_rst) begin
            in_edn_fetch = cfg.enable_masking;
          end

          if (cfg.enable_masking &amp;&amp;
              entropy_mode == EntropyModeEdn &amp;&amp;
              item.a_data[KmacEntropyReady]) begin
            in_edn_fetch = 1;
            `uvm_info(`gfn, &quot;raised in_edn_fetch after reset&quot;, UVM_HIGH)
          end
        end
      end
      &quot;cmd&quot;: begin
        // Writing to CMD will always result in the KMAC doing something
        //
        // TODO - handle error cases
        if (addr_phase_write) begin
          if (app_fsm_active) begin
            if (kmac_cmd_e&#39;(item.a_data) != CmdNone) begin
              kmac_err.valid = 1;
              kmac_err.code  = kmac_pkg::ErrSwIssuedCmdInAppActive;
              kmac_err.info  = 24&#39;(item.a_data);

              predict_err(.is_kmac_err(1));
            end
          end else begin
            case (kmac_cmd_e&#39;(item.a_data))
              CmdStart: begin
                if (checked_kmac_cmd == CmdNone) begin
                  // the first 6B of the prefix (function name),
                  // need to check that it is &quot;KMAC&quot; when `kmac_en == 1`
                  bit [47:0] function_name_6B;
                  bit [TL_DW-1:0] prefix_val;

                  // msgfifo will now be written
                  unchecked_kmac_cmd = CmdStart;

                  function_name_6B[31:0] = `gmv(ral.prefix[0]);
                  prefix_val = `gmv(ral.prefix[1]);
                  function_name_6B[47:32] = prefix_val[15:0];

                  if (kmac_en &amp;&amp; function_name_6B != kmac_pkg::EncodedStringKMAC) begin
                    kmac_err.valid = 1;
                    kmac_err.code  = kmac_pkg::ErrIncorrectFunctionName;
                    kmac_err.info  = {8&#39;h1, 16&#39;h0};

                    // If incorrect function name is given, KMAC will finish the current hash
                    // operation and produce an incorrect digest, do not check this.
                    predict_err(.is_kmac_err(1));

                    do_check_digest = 0;
                  end
                end else begin  // SW sent wrong command

                  kmac_err.valid = 1;
                  kmac_err.code  = kmac_pkg::ErrSwCmdSequence;
                  kmac_err.info  = {6&#39;h1, 11&#39;h0, 3&#39;(err_st), item.a_data[3:0]};

                  predict_err(.is_kmac_err(1));
                end
              end
              CmdProcess: begin
                if (checked_kmac_cmd == CmdStart) begin
                  // kmac will now compute the digest
                  unchecked_kmac_cmd = CmdProcess;

                  // Raise this bit after a small delay to handle an edge case where
                  // fifo_wr_ptr and fifo_rd_ptr both increment on same cycle that CmdProcess
                  // is latched by internal scoreboard logic
                  #1 req_cmd_process_dly = 1;
                  `uvm_info(`gfn, &quot;raised req_cmd_process_dly&quot;, UVM_HIGH)
                end else begin  // SW sent wrong command

                  kmac_err.valid = 1;
                  kmac_err.code  = kmac_pkg::ErrSwCmdSequence;
                  kmac_err.info  = {6&#39;h1, 11&#39;h0, 3&#39;(err_st), item.a_data[3:0]};

                  predict_err(.is_kmac_err(1));
                end
              end
              CmdManualRun: begin
                if (checked_kmac_cmd inside {CmdProcess, CmdManualRun}) begin
                  // kmac will now squeeze more output data
                  unchecked_kmac_cmd = CmdManualRun;

                  req_manual_squeeze = 1;
                  `uvm_info(`gfn, &quot;raised req_manual_squeeze&quot;, UVM_HIGH)
                end else begin  // SW sent wrong command

                  kmac_err.valid = 1;
                  kmac_err.code  = kmac_pkg::ErrSwCmdSequence;
                  kmac_err.info  = {6&#39;h1, 11&#39;h0, 3&#39;(err_st), item.a_data[3:0]};

                  predict_err(.is_kmac_err(1));
                end
              end
              CmdDone: begin
                if (checked_kmac_cmd inside {CmdProcess, CmdManualRun}) begin
                  unchecked_kmac_cmd = CmdDone;

                  // sample coverage of message length
                  if (cfg.en_cov) begin
                    cov.msg_len_cg.sample(msg.size());
                  end

                  // Calculate the digest using DPI and check for correctness
                  if (do_check_digest) check_digest();

                  // Flush all scoreboard state to prepare for the next hash operation
                  clear_state();

                  // IDLE should go high one cycle after issuing Done cmd
                  //cfg.clk_rst_vif.wait_clks(1);
                  //sha3_idle = 1;

                end else begin  // SW sent wrong command

                  kmac_err.valid = 1;
                  kmac_err.code  = kmac_pkg::ErrSwCmdSequence;
                  kmac_err.info  = {6&#39;h1, 11&#39;h0, 3&#39;(err_st), item.a_data[3:0]};

                  predict_err(.is_kmac_err(1));
                end
              end
              CmdNone: begin
                // RTL internal value, doesn&#39;t actually do anything
              end
              default: begin
                `uvm_fatal(`gfn, $sformatf(&quot;%0d is an illegal CMD value&quot;, item.a_data))
              end
            endcase
          end
        end else begin
          // this bit will be set to 0 during the data phase of the write,
          // providing better detection of when exactly a manual squeeze command
          // has been requested
          req_manual_squeeze = 0;
          `uvm_info(`gfn, &quot;dropped req_manual_squeeze&quot;, UVM_HIGH)

          #1 req_cmd_process_dly = 0;
          `uvm_info(`gfn, &quot;dropped req_cmd_process_dly&quot;, UVM_HIGH)
        end
      end
      &quot;status&quot;: begin

        // TODO - in data_phase_read sample coverage

        if (addr_phase_read) begin
          bit [TL_DW-1:0] exp_status;

          exp_status[KmacStatusSha3Idle]    = sha3_idle;
          exp_status[KmacStatusSha3Absorb]  = sha3_absorb;
          exp_status[KmacStatusSha3Squeeze] = sha3_squeeze;

          exp_status[KmacStatusFifoDepthMSB : KmacStatusFifoDepthLSB] = fifo_depth;

          exp_status[KmacStatusFifoEmpty] = fifo_empty;
          exp_status[KmacStatusFifoFull]  = fifo_full;

          void&#39;(ral.status.predict(.value(exp_status), .kind(UVM_PREDICT_READ)));

        end
      end
      &quot;key_len&quot;: begin
        // TODO need to do error checking
        if (addr_phase_write) begin
          key_len = key_len_e&#39;(item.a_data);
        end
      end
      &quot;err_code&quot;: begin
        // TODO don&#39;t do anything rn, need implement the error checking
      end
      // TODO - entropy csrs
      default: begin
        // regex match the key_share csrs
        string full_idx;
        string split_idx [$];
        string key_share;
        string key_idx;

        // KEY_SHARE csrs
        if (!uvm_re_match(&quot;key_share*&quot;, csr_name)) begin
          full_idx = csr_name.substr(9, csr_name.len() - 1);
          str_utils_pkg::str_split(full_idx, split_idx, &quot;_&quot;);
          // safety check that the regex is working correctly
          `DV_CHECK_FATAL(split_idx.size() == 2, $sformatf(
                          &quot;%0s does not contain a correct key index!&quot;, full_idx))
          key_share = split_idx.pop_front();
          key_idx   = split_idx.pop_front();

          // If keys are being written, update the scoreboard state
          if (addr_phase_write) begin
            keys[key_share.atoi()][key_idx.atoi()] = item.a_data;
          end
          // PREFIX csrs
        end else if (!uvm_re_match(&quot;prefix_*&quot;, csr_name)) begin
          str_utils_pkg::str_split(csr_name, split_idx, &quot;_&quot;);
          full_idx = split_idx.pop_back();

          if (addr_phase_write) begin
            prefix[full_idx.atoi()] = item.a_data;
          end
        end
      end
    endcase

    ////////////////////////////////////////////
    // Process incoming writes to the msgfifo //
    ////////////////////////////////////////////
    //
    // One problem with the scoreboard only having access to the data written to the msgfifo
    // is that the message is post-fixed with the encoded output length if KMAC mode is used.
    //
    // However there is no way to access it other than to calculate the length of the seen digest.
    // Even though it is somewhat hacky, this is the approach we&#39;ll take.
    // If the length of the calculated output is incorrect for whatever reason (scoreboard error
    // or RTL error), then passing this value into the DPI model will result in an incorrect
    // digest comparison.
    if (msgfifo_access) begin
      if (addr_phase_write) begin
        if (in_kmac_app) begin
          kmac_err.valid = 1;
          kmac_err.code  = kmac_pkg::ErrSwPushedMsgFifo;
          kmac_err.info  = {8&#39;h0, 8&#39;(app_st), 8&#39;(app_mux_sel)};
          predict_err(.is_kmac_err(1));
        end else if (checked_kmac_cmd != CmdStart) begin
          // TODO
          //
          // If we get here we are writing to the msgfifo in an invalid state.
          // Implement error checking here.
        end else if (!cfg.under_reset) begin
          bit [7:0] full_data  [4];
          bit [7:0] masked_data[ ];

          {&lt;&lt;byte{full_data}} = item.a_data;

          `uvm_info(`gfn, $sformatf(&quot;item.a_data: 0x%0x&quot;, item.a_data), UVM_HIGH)
          `uvm_info(`gfn, $sformatf(&quot;item.a_mask: 0b%0b&quot;, item.a_mask), UVM_HIGH)
          `uvm_info(`gfn, $sformatf(&quot;full_data: %0p&quot;, full_data), UVM_HIGH)

          // sample coverage on the write mask
          if (cfg.en_cov) begin
            cov.msgfifo_write_mask_cg.sample(item.a_mask);
          end

          // All writes in big-endian order will be full-word,
          // so we can generalize this to a for-loop that reverses the byte order of each word.
          // This way we can also preserve little-endian ordering.
          for (int i = 0; i &lt; TL_DBW; i++) begin
            if (item.a_mask[i]) begin
              masked_data =
              `gmv(ral.cfg.msg_endianness)
              ? {
                full_data[i], masked_data
              } : {
                masked_data, full_data[i]
              };
            end
          end
          msg = {msg, masked_data};

          `uvm_info(`gfn, $sformatf(&quot;masked_data: %0p&quot;, masked_data), UVM_HIGH)
          `uvm_info(`gfn, $sformatf(&quot;msg: %0p&quot;, msg), UVM_HIGH)
        end
      end
      // indicate that the msgfifo access is now over
      msgfifo_access = 0;
    end

    ///////////////////////////////////////////////////
    // Process incoming reads from the digest window //
    ///////////////////////////////////////////////////

    if (share0_access || share1_access) begin
      bit [TL_DW-1:0] digest_word;
      bit [7:0] digest_byte;
      bit [TL_DBW-1:0] state_mask;

      `uvm_info(`gfn, $sformatf(&quot;share0: %0d&quot;, share0_access), UVM_HIGH)
      `uvm_info(`gfn, $sformatf(&quot;share1: %0d&quot;, share1_access), UVM_HIGH)

      if (data_phase_read) begin
        state_mask  = item.a_mask;
        digest_word = item.d_data;

        // sample coverage on state read mask
        if (cfg.en_cov) begin
          cov.state_read_mask_cg.sample(state_mask, share1_access);
        end

        `uvm_info(`gfn, $sformatf(&quot;state read mask: 0b%0b&quot;, state_mask), UVM_HIGH)
        `uvm_info(`gfn, $sformatf(&quot;digest_word: 0x%0x&quot;, digest_word), UVM_HIGH)

        if (`gmv(ral.cfg.state_endianness)) begin
          digest_word = {&lt;&lt;byte{digest_word}};
          state_mask  = {&lt;&lt;bit{state_mask}};

          `uvm_info(`gfn, $sformatf(&quot;endian-swapped digest word: 0x%0x&quot;, digest_word), UVM_HIGH)
          `uvm_info(`gfn, $sformatf(&quot;endian-swapped read mask: 0b%0b&quot;, state_mask), UVM_HIGH)
        end
        for (int i = 0; i &lt; TL_DBW; i++) begin
          if (state_mask[i]) begin
            digest_byte = digest_word[i*8+:8];
            `uvm_info(`gfn, $sformatf(&quot;digest_byte: 0x%0x&quot;, digest_byte), UVM_HIGH)

            if (share0_access) begin
              digest_share0 = {digest_share0, digest_byte};
              `uvm_info(`gfn, $sformatf(&quot;intermediate digest_share0: %0p&quot;, digest_share0), UVM_HIGH)
            end else if (share1_access) begin
              digest_share1 = {digest_share1, digest_byte};
              `uvm_info(`gfn, $sformatf(&quot;intermediate digest_share1: %0p&quot;, digest_share1), UVM_HIGH)
            end
          end
        end
      end

      // If we read the state digest in either CmdStart or CmdDone states,
      // we should read back all zeroes.
      // Check immediately and clear the digest arrays.
      if (checked_kmac_cmd inside {CmdNone, CmdStart, CmdDone}) begin
        foreach (digest_share0[i]) begin
          `DV_CHECK_EQ_FATAL(digest_share0[i], &#39;0, $sformatf(
                             &quot;Share 0 should be zero in state %0s&quot;, checked_kmac_cmd.name()))
          digest_share0 = {};
        end
        foreach (digest_share1[i]) begin
          `DV_CHECK_EQ_FATAL(digest_share1[i], &#39;0, $sformatf(
                             &quot;Share 1 should be zero in state %0s&quot;, checked_kmac_cmd.name()))
          digest_share1 = {};
        end
      end
      share0_access = 0;
      share1_access = 0;
    end

    // On reads, if do_read_check, is set, then check mirrored_value against item.d_data
    if (data_phase_read &amp;&amp; csr_name != &quot;&quot;) begin
      if (do_read_check) begin
        `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data, $sformatf(
                     &quot;reg name: %0s&quot;, csr.get_full_name()))
      end
      void&#39;(csr.predict(.value(item.d_data), .kind(UVM_PREDICT_READ)));
    end
  endtask : process_tl_access

  virtual function predict_err(bit is_sha3_err = 0, bit is_kmac_err = 0);
    // set interrupt
    if (!intr_kmac_err) intr_kmac_err = 1;
    `uvm_info(`gfn, &quot;raised intr_kmac_err&quot;, UVM_HIGH)
    if (is_sha3_err) `uvm_info(`gfn, $sformatf(&quot;sha3_err: %0p&quot;, sha3_err), UVM_HIGH)
    if (is_kmac_err) `uvm_info(`gfn, $sformatf(&quot;kmac_err: %0p&quot;, kmac_err), UVM_HIGH)

    // predict error CSR
    if (is_sha3_err) begin
      void&#39;(ral.err_code.predict(.value(TL_DW&#39;(sha3_err)), .kind(UVM_PREDICT_DIRECT)));
    end else if (is_kmac_err) begin
      void&#39;(ral.err_code.predict(.value(TL_DW&#39;(kmac_err)), .kind(UVM_PREDICT_DIRECT)));
    end

    kmac_err = &#39;{valid: 1&#39;b0, code: kmac_pkg::ErrNone, info: &#39;0};
    sha3_err = &#39;{valid: 1&#39;b0, code: sha3_pkg::ErrNone, info: &#39;0};
  endfunction

  virtual function void reset(string kind = &quot;HARD&quot;);
    super.reset(kind);

    clear_state();

    checked_kmac_cmd   = CmdNone;
    unchecked_kmac_cmd = CmdNone;

    first_op_after_rst = 1;

    num_blocks_filled  = 0;

    // status tracking bits
    sha3_idle          = ral.status.sha3_idle.get_reset();
    sha3_absorb        = ral.status.sha3_absorb.get_reset();
    sha3_squeeze       = ral.status.sha3_squeeze.get_reset();
    fifo_depth         = ral.status.fifo_depth.get_reset();
    fifo_empty         = ral.status.fifo_empty.get_reset();
    fifo_full          = ral.status.fifo_full.get_reset();
  endfunction

  // This function should be called to reset internal state to prepare for a new hash operation
  virtual function void clear_state();
    `uvm_info(`gfn, &quot;clearing scoreboard state&quot;, UVM_HIGH)

    if (first_op_after_rst) first_op_after_rst = 0;

    do_check_digest = 1;

    msg.delete();
    kmac_app_msg.delete();

    kmac_app_block_data      = &#39;0;
    kmac_app_block_strb      = &#39;0;
    kmac_app_block_strb_size = 0;
    kmac_app_last            = 0;
    got_data_from_kmac_app   = 0;

    prefix_and_keys_done     = 0;
    req_manual_squeeze       = 0;
    cmd_process_in_header    = 0;
    kmac_app_last_in_header  = 0;
    msg_digest_done          = 0;
    fifo_rd_ptr              = 0;
    fifo_wr_ptr              = 0;

    in_edn_fetch             = 0;
    refresh_entropy          = 0;

    kmac_err                 = &#39;{valid: 1&#39;b0, code: kmac_pkg::ErrNone, info: &#39;0};
    sha3_err                 = &#39;{valid: 1&#39;b0, code: sha3_pkg::ErrNone, info: &#39;0};

    app_st                   = StIdle;
    err_st                   = ErrStIdle;

    keys                     = &#39;0;
    keymgr_keys              = &#39;0;
    sideload_key             = &#39;0;
    prefix                   = &#39;{default: 0};
    digest_share0            = {};
    digest_share1            = {};

    kmac_app_digest_share0   = &#39;0;
    kmac_app_digest_share1   = &#39;0;
  endfunction

  // This function is called whenever a CmdDone command is issued to KMAC,
  // and will compare the seen digest against the digest calculated from the DPI model.
  //
  // Though we don&#39;t have direct access to the specified output length for XOF functions,
  // the last byte written to the msgfifo (only for XOFs) will be the number of preceding bytes
  // that encode the requested output length.
  // From this we can decode what the initially requested output length is.
  //
  // We also need to decode what the prefix is (only for KMAC), as only the encoded values
  // are written to the CSRs.  virtual function void check_digest();
  virtual function void check_digest();

    // Cast to an array so we can pass this into the DPI functions
    bit [7:0] msg_arr[];

    // Determines which kmac variant to use
    bit xof_en;

    // Set this to the calculated output length for XOFs
    int output_len_bytes;

    // Array to hold the digest read from the state windows
    bit [7:0] unmasked_digest[];

    // Array to hold the expected digest calculated by DPI model
    bit [7:0] dpi_digest[];

    // Function name and customization strings for KMAC operations
    string fname;
    string custom_str;

    // Use this to store the correct set of keys (SW-provided or sideloaded)
    bit [KMAC_NUM_SHARES-1:0][KMAC_NUM_KEYS_PER_SHARE-1:0][31:0] exp_keys;

    // The actual key used for KMAC operations
    bit [31:0] unmasked_key[$];

    // key byte-stream for the DPI model
    bit [7:0] dpi_key_arr[];

    // Intermediate array for streaming `unmasked_key` into `dpi_key_arr`
    bit [7:0] unmasked_key_bytes[];

    int key_word_len = get_key_size_words(key_len);
    int key_byte_len = get_key_size_bytes(key_len);

    `uvm_info(`gfn, $sformatf(&quot;key_word_len: %0d&quot;, key_word_len), UVM_HIGH)
    `uvm_info(`gfn, $sformatf(&quot;key_byte_len: %0d&quot;, key_byte_len), UVM_HIGH)

    // Calculate:
    // - the expected output length in bytes
    // - if we are using the xof version of kmac
    if (in_kmac_app) begin
      // KMAC_APP output will always be 384 bits (48 bytes)
      output_len_bytes = AppDigestW / 8;

      // xof_en is 1 when the padded output length is 0,
      // but this will never happen in KMAC_APP
      xof_en = 0;
    end else begin
      get_digest_len_and_xof(output_len_bytes, xof_en, msg);

      // quick check that the calculated output length is the same
      // as the number of bytes read from the digest window
      `DV_CHECK_EQ_FATAL(digest_share0.size(), output_len_bytes, $sformatf(
                         &quot;Calculated output length doesn&#39;t match actual output length!&quot;))
    end

    if (cfg.en_cov) begin
      // sample configuration coverage, as only now do we know which KMAC variant is used
      // (xof/non-xof)
      cov.sample_cfg(kmac_en, xof_en, strength, hash_mode, key_len, `gmv(ral.cfg.msg_endianness),
                     `gmv(ral.cfg.state_endianness), `gmv(ral.cfg.sideload), entropy_mode,
                     entropy_fast_process);

      // sample coverage on the digest length
      if (cfg.en_cov) begin
        cov.output_digest_len_cg.sample(output_len_bytes);
      end
    end


    `uvm_info(`gfn, $sformatf(&quot;output_len_bytes: %0d&quot;, output_len_bytes), UVM_HIGH)
    `uvm_info(`gfn, $sformatf(&quot;xof_en: %0d&quot;, xof_en), UVM_HIGH)

    // initialize arrays
    dpi_digest = new[output_len_bytes];
    unmasked_digest = new[output_len_bytes];

    /////////////////////////////////
    // Calculate the actual digest //
    /////////////////////////////////
    if (cfg.enable_masking) begin
      if (in_kmac_app) begin
        unmasked_digest = {&lt;&lt;byte{kmac_app_digest_share0^ kmac_app_digest_share1}};
      end else begin
        foreach (unmasked_digest[i]) begin
          unmasked_digest[i] = digest_share0[i] ^ digest_share1[i];
        end
      end
    end else begin
      if (in_kmac_app) begin
        unmasked_digest = {&lt;&lt;byte{kmac_app_digest_share0}};
      end else begin
        unmasked_digest = digest_share0;
      end
    end
    `uvm_info(`gfn, $sformatf(&quot;unmasked_digest: %0p&quot;, unmasked_digest), UVM_HIGH)

    ///////////////////////////////////////////////////////////
    // Calculate the expected digest using the DPI-C++ model //
    ///////////////////////////////////////////////////////////
    if (in_kmac_app) begin
      // kmac_app message is a byte array, cast to bit[7:0]
      msg_arr = new[kmac_app_msg.size()];
      foreach (kmac_app_msg[i]) begin
        msg_arr[i] = kmac_app_msg[i];
      end
    end else begin
      msg_arr = msg;
    end
    `uvm_info(`gfn, $sformatf(&quot;msg_arr for DPI mode: %0p&quot;, msg_arr), UVM_HIGH)

    case (hash_mode)
      ///////////
      // SHA-3 //
      ///////////
      sha3_pkg::Sha3: begin
        case (strength)
          sha3_pkg::L224: begin
            digestpp_dpi_pkg::c_dpi_sha3_224(msg_arr, msg_arr.size(), dpi_digest);
          end
          sha3_pkg::L256: begin
            digestpp_dpi_pkg::c_dpi_sha3_256(msg_arr, msg_arr.size(), dpi_digest);
          end
          sha3_pkg::L384: begin
            digestpp_dpi_pkg::c_dpi_sha3_384(msg_arr, msg_arr.size(), dpi_digest);
          end
          sha3_pkg::L512: begin
            digestpp_dpi_pkg::c_dpi_sha3_512(msg_arr, msg_arr.size(), dpi_digest);
          end
          default: begin
            `uvm_fatal(`gfn, $sformatf(&quot;strength[%0s] is not allowed for sha3&quot;, strength.name()))
          end
        endcase
      end
      ///////////
      // SHAKE //
      ///////////
      sha3_pkg::Shake: begin
        case (strength)
          sha3_pkg::L128: begin
            digestpp_dpi_pkg::c_dpi_shake128(msg_arr, msg_arr.size(), output_len_bytes, dpi_digest);
          end
          sha3_pkg::L256: begin
            digestpp_dpi_pkg::c_dpi_shake256(msg_arr, msg_arr.size(), output_len_bytes, dpi_digest);
          end
          default: begin
            `uvm_fatal(`gfn, $sformatf(&quot;strength[%0s] is not allowed for shake&quot;, strength.name()))
          end
        endcase
      end
      ////////////
      // CSHAKE //
      ////////////
      sha3_pkg::CShake: begin
        // Get the fname and custom_str string values from the writes to PREFIX csrs
        get_fname_and_custom_str(in_kmac_app, fname, custom_str);

        if (kmac_en) begin
          // Calculate the unmasked key
          exp_keys = `gmv(ral.cfg.sideload) ? keymgr_keys : keys;
          for (int i = 0; i &lt; key_word_len; i++) begin
            // Sideloaded keys are treated as two-share masked form by default, need to xor them
            if (cfg.enable_masking || `gmv(ral.cfg.sideload)) begin
              unmasked_key.push_back(exp_keys[0][i] ^ exp_keys[1][i]);
            end else begin
              unmasked_key.push_back(exp_keys[0][i]);
            end
            `uvm_info(`gfn, $sformatf(&quot;unmasked_key[%0d] = 0x%0x&quot;, i, unmasked_key[i]), UVM_HIGH)
          end

          // Convert the key array into a byte array for the DPI model
          unmasked_key_bytes = {&lt;&lt;32{unmasked_key}};
          dpi_key_arr = {&lt;&lt;byte{unmasked_key_bytes}};
          `uvm_info(`gfn, $sformatf(&quot;dpi_key_arr.size(): %0d&quot;, dpi_key_arr.size()), UVM_HIGH)
          `uvm_info(`gfn, $sformatf(&quot;dpi_key_arr: %0p&quot;, dpi_key_arr), UVM_HIGH)

          case (strength)
            sha3_pkg::L128: begin
              if (xof_en) begin
                digestpp_dpi_pkg::c_dpi_kmac128_xof(msg_arr, msg_arr.size(), dpi_key_arr,
                                                    dpi_key_arr.size(), custom_str,
                                                    output_len_bytes, dpi_digest);
              end else begin
                digestpp_dpi_pkg::c_dpi_kmac128(msg_arr, msg_arr.size(), dpi_key_arr,
                                                dpi_key_arr.size(), custom_str, output_len_bytes,
                                                dpi_digest);
              end
            end
            sha3_pkg::L256: begin
              if (xof_en) begin
                digestpp_dpi_pkg::c_dpi_kmac256_xof(msg_arr, msg_arr.size(), dpi_key_arr,
                                                    dpi_key_arr.size(), custom_str,
                                                    output_len_bytes, dpi_digest);
              end else begin
                digestpp_dpi_pkg::c_dpi_kmac256(msg_arr, msg_arr.size(), dpi_key_arr,
                                                dpi_key_arr.size(), custom_str, output_len_bytes,
                                                dpi_digest);
              end
            end
            default: begin
              `uvm_fatal(`gfn, $sformatf(&quot;strength[%0s] is not allowed for kmac&quot;, strength.name()))
            end
          endcase
        end else begin
          // regular cshake - used for otp_ctrl/rom_ctrl application interfaces
          case (strength)
            sha3_pkg::L128: begin
              digestpp_dpi_pkg::c_dpi_cshake128(msg_arr, fname, custom_str, msg_arr.size(),
                                                output_len_bytes, dpi_digest);
            end
            sha3_pkg::L256: begin
              digestpp_dpi_pkg::c_dpi_cshake256(msg_arr, fname, custom_str, msg_arr.size(),
                                                output_len_bytes, dpi_digest);
            end
            default: begin
              `uvm_fatal(`gfn, $sformatf(&quot;strength[%0s] is not allowed for cshake&quot;, strength.name()
                         ))
            end
          endcase
        end
      end
    endcase

    `uvm_info(`gfn, $sformatf(&quot;dpi_digest: %0p&quot;, dpi_digest), UVM_HIGH)

    /////////////////////////////////////////
    // Compare actual and expected digests //
    /////////////////////////////////////////
    for (int i = 0; i &lt; output_len_bytes; i++) begin
      `DV_CHECK_EQ_FATAL(unmasked_digest[i], dpi_digest[i], $sformatf(
                         &quot;Mismatch between unmasked_digest[%0d] and dpi_digest[%0d]&quot;, i, i))
    end

  endfunction

  // This function is used to calculate the requested digest length
  virtual function void get_digest_len_and_xof(ref int output_len, ref bit xof_en,
                                               ref bit [7:0] msg[$]);
    xof_en = 0;
    case (hash_mode)
      // For SHA3 hashes, the output length is the same as the security strength.
      sha3_pkg::Sha3: begin
        case (strength)
          sha3_pkg::L224: begin
            output_len = 224 / 8;  // 28
          end
          sha3_pkg::L256: begin
            output_len = 256 / 8;  // 32
          end
          sha3_pkg::L384: begin
            output_len = 384 / 8;  // 48
          end
          sha3_pkg::L512: begin
            output_len = 512 / 8;  // 64
          end
          default: begin
            `uvm_fatal(`gfn, $sformatf(&quot;strength[%0s] is not allowed for sha3&quot;, strength.name()))
          end
        endcase
      end
      // For Shake hashes, the output length isn&#39;t encoded anywhere,
      // so we just return the length of the state digest array.
      sha3_pkg::Shake: begin
        output_len = digest_share0.size();
      end
      // CShake is where things get more interesting.
      // We need to essentially decode the encoded output length that is
      // written to the msgfifo as a post-fix to the actual message.
      sha3_pkg::CShake: begin
        bit [MAX_ENCODE_WIDTH-1:0] full_len = &#39;0;
        // the very last byte written to msgfifo is the number of bytes that
        // when put together represent the encoded output length.
        bit [7:0] num_encoded_byte = msg.pop_back();

        for (int i = 0; i &lt; num_encoded_byte; i++) begin
          full_len[i*8+:8] = msg.pop_back();
        end

        // We should set xof_en if `right_encode(0)` was written to the msgfifo after the message.
        // right_encode(0) = &#39;{&#39;h0, &#39;h1}
        if (num_encoded_byte == 1 &amp;&amp; full_len == 0) begin
          xof_en = 1;
          // can&#39;t set  the output length to 0, so we fall back to the Shake behavior here
          output_len = digest_share0.size();
        end else begin
          output_len = full_len / 8;
        end
      end
    endcase
  endfunction

  // This function is used to calculate the fname and custom_str string values
  // from the data written to the PREFIX csrs
  //
  // Strings are encoded as:
  //  `encode_string(S) = left_encode(len(S)) || S`
  virtual function void get_fname_and_custom_str(bit en_kmac_app, ref string fname,
                                                 ref string custom_str);
    bit [7:0] prefix_bytes[$];
    // The very first byte of each encoded string represents the number of bytes
    // that make up the encoded string&#39;s length.
    bit [7:0] num_enc_bytes_of_str_len;

    bit [16:0] str_len;

    byte fname_arr[];
    byte custom_str_arr[];

    if (en_kmac_app &amp;&amp; kmac_pkg::AppCfg[app_mode].PrefixMode) begin
      prefix_bytes = {&lt;&lt;byte{kmac_pkg::AppCfg[app_mode].Prefix}};
    end else begin
      prefix_bytes = {&lt;&lt;32{prefix}};
      prefix_bytes = {&lt;&lt;byte{prefix_bytes}};
    end

    // sample coverage
    if (cfg.en_cov) begin
      foreach (prefix_bytes[i]) begin
        cov.prefix_range_cg.sample(byte&#39;(prefix_bytes[i]));
      end
    end

    `uvm_info(`gfn, $sformatf(&quot;prefix: %0p&quot;, prefix), UVM_HIGH)
    `uvm_info(`gfn, $sformatf(&quot;prefix_bytes: %0p&quot;, prefix_bytes), UVM_HIGH)

    // fname comes first in the PREFIX registers

    // This value should be 1
    num_enc_bytes_of_str_len = prefix_bytes.pop_front();
    `DV_CHECK_EQ(num_enc_bytes_of_str_len, 1, $sformatf(
                 &quot;Only one byte should be used to encode len(fname)&quot;))

    // The string length is always in terms of bits, need to convert to byte length
    str_len   = prefix_bytes.pop_front() / 8;

    fname_arr = new[str_len];
    for (int i = 0; i &lt; str_len; i++) begin
      fname_arr[i] = byte&#39;(prefix_bytes.pop_front());
    end

    // custom_str is next

    num_enc_bytes_of_str_len = prefix_bytes.pop_front();

    // convert string length to length in bytes
    for (int i = 0; i &lt; num_enc_bytes_of_str_len; i++) begin
      str_len[(num_enc_bytes_of_str_len-i-1)*8+:8] = prefix_bytes.pop_front();
    end
    str_len /= 8;

    custom_str_arr = new[str_len];
    for (int i = 0; i &lt; str_len; i++) begin
      custom_str_arr[i] = byte&#39;(prefix_bytes.pop_front());
    end

    // Convert the byte arrays into strings
    fname = str_utils_pkg::bytes_to_str(fname_arr);
    custom_str = str_utils_pkg::bytes_to_str(custom_str_arr);

    `uvm_info(`gfn, $sformatf(&quot;decoded fname: %0s&quot;, fname), UVM_HIGH)
    `uvm_info(`gfn, $sformatf(&quot;decoded custom_str: %0s&quot;, custom_str), UVM_HIGH)
  endfunction

  function void check_phase(uvm_phase phase);
    super.check_phase(phase);
    // post test checks - ensure that all local fifos and queues are empty
  endfunction

endclass

`undef CALC_PARTIAL_MSG

`undef KMAC_APP_VALID_TRANS
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
<div class="section" id="hw-ip-keymgr-dv-env-keymgr-scoreboard-sv">
<span id="error-hw-ip-keymgr-dv-env-keymgr-scoreboard-sv"></span><h2>hw/ip/keymgr/dv/env/keymgr_scoreboard.sv<a class="headerlink" href="#hw-ip-keymgr-dv-env-keymgr-scoreboard-sv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>opentitan/hw/ip/keymgr/dv/env/keymgr_scoreboard.sv: Formatted output is lexically different from the input.    Please file a bug.  Details:
Mismatched token enums.  got: (&#39;)&#39;) (#41: &quot;)&quot;) vs. (MacroCallCloseToEndLine) (#746: &quot;)&quot;)
First mismatched token [1112]: (&#39;)&#39;) (#41: &quot;)&quot;) vs. (MacroCallCloseToEndLine) (#746: &quot;)&quot;)
; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class keymgr_scoreboard extends cip_base_scoreboard #(
  .CFG_T(keymgr_env_cfg),
  .RAL_T(keymgr_reg_block),
  .COV_T(keymgr_env_cov)
);
  `uvm_component_utils(keymgr_scoreboard)
  `define CREATE_CMP_STR(VAR) \
    str = $sformatf(&quot;%0s\n %0s act: 0x%0h, exp: 0x%0h&quot;, str, `&quot;VAR`&quot;, act.``VAR, exp.``VAR);

  typedef struct packed {
    bit [keymgr_reg_pkg::NumSwBindingReg-1:0][TL_DW-1:0] SoftwareBinding;
    bit [keymgr_pkg::KeyWidth-1:0] HardwareRevisionSecret;
    bit [keymgr_pkg::DevIdWidth-1:0] DeviceIdentifier;
    bit [keymgr_pkg::HealthStateWidth-1:0] HealthMeasurement;
    bit [keymgr_pkg::KeyWidth-1:0] RomDigest;
    bit [keymgr_pkg::KeyWidth-1:0] DiversificationKey;
  } adv_creator_data_t;

  typedef struct packed {
    // some portions are unused, which are 0s
    bit [keymgr_pkg::AdvDataWidth-keymgr_pkg::KeyWidth-keymgr_pkg::SwBindingWidth-1:0] unused;
    bit [keymgr_reg_pkg::NumSwBindingReg-1:0][TL_DW-1:0] SoftwareBinding;
    bit [keymgr_pkg::KeyWidth-1:0] OwnerRootSecret;
  } adv_owner_int_data_t;

  typedef struct packed {
    // some portions are unused, which are 0s
    bit [keymgr_pkg::AdvDataWidth-keymgr_pkg::SwBindingWidth-1:0] unused;
    bit [keymgr_reg_pkg::NumSwBindingReg-1:0][TL_DW-1:0] SoftwareBinding;
  } adv_owner_data_t;

  typedef struct packed {
    bit [TL_DW-1:0] KeyVersion;
    bit [keymgr_reg_pkg::NumSaltReg-1:0][TL_DW-1:0] Salt;
    keymgr_pkg::seed_t KeyID;
    keymgr_pkg::seed_t SoftwareExportConstant;
  } gen_out_data_t;

  typedef enum int {
    UpdateSwOut,
    UpdateHwOut,
    UpdateInternalKey,
    NotUpdate
  } update_result_e;

  int adv_cnt = 0;

  // local variables
  keymgr_pkg::keymgr_working_state_e current_state;
  keymgr_pkg::keymgr_op_status_e current_op_status;
  bit is_kmac_rsp_err;
  bit is_kmac_invalid_data;
  bit is_sw_share_corrupted;

  // HW internal key, used for OP in current state
  key_shares_t current_internal_key[keymgr_cdi_type_e];
  keymgr_cdi_type_e current_cdi;

  // preserve value at TL read address phase and compare it at read data phase
  keymgr_pkg::keymgr_op_status_e addr_phase_op_status;
  bit addr_phase_cfg_regwen;
  keymgr_pkg::keymgr_working_state_e addr_phase_working_state;
  bit addr_phase_is_sw_share_corrupted;

  // TLM agent fifos
  uvm_tlm_analysis_fifo #(kmac_app_item) req_fifo;
  uvm_tlm_analysis_fifo #(kmac_app_item) rsp_fifo;

  // local queues to hold incoming packets pending comparison
  // store meaningful data, in non-working state, should not match to these data
  bit [keymgr_pkg::AdvDataWidth-1:0] adv_data_a_array[keymgr_cdi_type_e][
                                     keymgr_pkg::keymgr_working_state_e];
  bit [keymgr_pkg::IdDataWidth-1:0] id_data_a_array[keymgr_pkg::keymgr_working_state_e];
  bit [keymgr_pkg::GenDataWidth-1:0] sw_data_a_array[keymgr_pkg::keymgr_working_state_e];
  bit [keymgr_pkg::GenDataWidth-1:0] hw_data_a_array[keymgr_pkg::keymgr_working_state_e];

  `uvm_component_new

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    req_fifo = new(&quot;req_fifo&quot;, this);
    rsp_fifo = new(&quot;rsp_fifo&quot;, this);
  endfunction

  function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
  endfunction

  task run_phase(uvm_phase phase);
    super.run_phase(phase);
    fork
      forever begin
        kmac_app_item item;
        req_fifo.get(item);
        if (!cfg.en_scb) continue;
        process_kmac_data_req(item);
      end
      forever begin
        kmac_app_item item;
        rsp_fifo.get(item);
        if (!cfg.en_scb) continue;
        process_kmac_data_rsp(item);
      end
      forever begin
        wait(cfg.keymgr_vif.keymgr_en_sync2 != lc_ctrl_pkg::On);

        if (current_state != keymgr_pkg::StReset || current_op_status == keymgr_pkg::OpWip) begin
          wipe_hw_keys();
        end

        wait(cfg.keymgr_vif.keymgr_en_sync2 == lc_ctrl_pkg::On);
      end
    join_none
  endtask

  virtual function void process_kmac_data_req(kmac_app_item item);
    keymgr_pkg::keymgr_ops_e op = get_operation();

    // there must be a OP which causes the KMAC data req
    `DV_CHECK_EQ(current_op_status, keymgr_pkg::OpWip)

    if (!cfg.keymgr_vif.get_keymgr_en()) begin
      compare_invalid_data(item.byte_data_q);
      return;
    end

    case (op)
      keymgr_pkg::OpAdvance: begin

        case (current_state)
          keymgr_pkg::StInit: begin
            bit is_err = get_hw_invalid_input();
            compare_adv_creator_data(.cdi_type(current_cdi), .exp_match(!is_err),
                                     .byte_data_q(item.byte_data_q));
            if (is_err) compare_invalid_data(item.byte_data_q);
          end
          keymgr_pkg::StCreatorRootKey: begin
            bit is_err = get_hw_invalid_input();

            compare_adv_owner_int_data(.cdi_type(current_cdi), .exp_match(!is_err),
                                       .byte_data_q(item.byte_data_q));
            if (is_err) compare_invalid_data(item.byte_data_q);
          end
          keymgr_pkg::StOwnerIntKey: begin
            compare_adv_owner_data(current_cdi, item.byte_data_q);
          end
          keymgr_pkg::StOwnerKey, keymgr_pkg::StDisabled, keymgr_pkg::StInvalid: begin
            compare_invalid_data(item.byte_data_q);
          end
          default: `uvm_error(`gfn, $sformatf(&quot;Unexpected current_state: %0d&quot;, current_state))
        endcase
      end
      keymgr_pkg::OpGenId: begin
        if (get_is_kmac_data_correct()) compare_id_data(item.byte_data_q);
        else compare_invalid_data(item.byte_data_q);
      end
      keymgr_pkg::OpGenSwOut, keymgr_pkg::OpGenHwOut: begin
        if (get_is_kmac_data_correct()) compare_gen_out_data(item.byte_data_q);
        else compare_invalid_data(item.byte_data_q);
      end
      keymgr_pkg::OpDisable: begin
        compare_invalid_data(item.byte_data_q);
      end
      default: `uvm_fatal(`gfn, $sformatf(&quot;Unexpected operation: %0s&quot;, op.name))
    endcase
  endfunction

  virtual function void process_kmac_data_rsp(kmac_app_item item);
    update_result_e update_result;
    bit process_update;

    is_kmac_rsp_err = item.rsp_error;
    is_kmac_invalid_data = item.get_is_kmac_rsp_data_invalid();
    update_result = process_update_after_op_done();

    case (update_result)
      UpdateInternalKey: begin
        current_internal_key[current_cdi] = {item.rsp_digest_share1, item.rsp_digest_share0};
        cfg.keymgr_vif.store_internal_key(current_internal_key[current_cdi], current_state,
                                          current_cdi);

        `uvm_info(`gfn, $sformatf(
                  &quot;Update internal key 0x%0h for state %s %s&quot;,
                  current_internal_key[current_cdi],
                  current_state.name,
                  current_cdi.name
                  ), UVM_MEDIUM)
      end
      UpdateSwOut: begin
        bit [keymgr_pkg::Shares-1:0][DIGEST_SHARE_WORD_NUM-1:0][TL_DW-1:0] sw_share_output;

        sw_share_output = {item.rsp_digest_share1, item.rsp_digest_share0};
        foreach (sw_share_output[i, j]) begin
          string  csr_name = $sformatf(&quot;sw_share%0d_output_%0d&quot;, i, j);
          uvm_reg csr = ral.get_reg_by_name(csr_name);

          void&#39;(csr.predict(.value(sw_share_output[i][j]), .kind(UVM_PREDICT_DIRECT)));
          `uvm_info(`gfn, $sformatf(&quot;Predict %0s = 0x%0h&quot;, csr_name, sw_share_output[i][j]),
                    UVM_MEDIUM)
        end
      end
      UpdateHwOut: begin
        key_shares_t key_shares = {item.rsp_digest_share1, item.rsp_digest_share0};
        bit good_key = (get_err_code() == 0);
        keymgr_pkg::keymgr_key_dest_e dest = keymgr_pkg::keymgr_key_dest_e&#39;(
        `gmv(ral.control.dest_sel)
        );

        if (dest != keymgr_pkg::None) begin
          cfg.keymgr_vif.update_sideload_key(key_shares, current_state, current_cdi, dest,
                                             good_key);
          `uvm_info(`gfn, $sformatf(&quot;Update sideload key 0x%0h for %s&quot;, key_shares, dest.name),
                    UVM_MEDIUM)
        end
      end
      default: `uvm_info(`gfn, &quot;KMAC result isn&#39;t updated to any output&quot;, UVM_MEDIUM)
    endcase

    if (!cfg.keymgr_vif.get_keymgr_en()) current_state = keymgr_pkg::StInvalid;

    if (!(current_state inside {keymgr_pkg::StReset, keymgr_pkg::StInvalid}) &amp;&amp;
        get_operation() inside {keymgr_pkg::OpAdvance, keymgr_pkg::OpDisable}) begin
      current_cdi = get_adv_cdi_type();
      if (current_cdi &gt; 0) begin
        cfg.keymgr_vif.update_kdf_key(current_internal_key[current_cdi], current_state,
                                      get_is_kmac_key_correct());
      end
    end
  endfunction

  // update current_state, current_op_status, err_code, alert and return update_result for updating
  // internal key, HW/SW output
  virtual function update_result_e process_update_after_op_done();
    update_result_e update_result;
    keymgr_pkg::keymgr_ops_e op = get_operation();
    bit is_final_kdf;

    // for advance after StReset, it needs 2 KDF. Only update opt_status after the last one
    if (!(op inside {keymgr_pkg::OpAdvance, keymgr_pkg::OpDisable}) ||
        current_state == keymgr_pkg::StReset) begin
      is_final_kdf = 1;
    end else begin
      is_final_kdf = (adv_cnt == keymgr_pkg::CDIs - 1);
    end
    // op_status is updated one cycle after done. If SW reads at this edge, still return old value
    // delay half cycle to push the update available in next cycle
    fork
      begin
        cfg.clk_rst_vif.wait_n_clks(1);
        if (is_final_kdf) begin
          if (get_err_code()) current_op_status = keymgr_pkg::OpDoneFail;
          else current_op_status = keymgr_pkg::OpDoneSuccess;
        end
      end
    join_none

    if (is_final_kdf) process_error_n_alert();
    // IntrOpDone occurs after every KDF
    void&#39;(ral.intr_state.predict(.value(1 &lt;&lt; int&#39;(IntrOpDone))));

    case (current_state)
      keymgr_pkg::StInit, keymgr_pkg::StCreatorRootKey, keymgr_pkg::StOwnerIntKey,
          keymgr_pkg::StOwnerKey: begin

        case (op)
          keymgr_pkg::OpAdvance: begin
            if (get_fault_err()) begin
              current_state = keymgr_pkg::StDisabled;
              update_result = NotUpdate;
            end else if (get_op_err()) begin
              update_result = NotUpdate;
            end else begin
              // if it&#39;s StOwnerKey, it advacens to OpDisable. Key is just random value
              if (current_state == keymgr_pkg::StOwnerKey) update_result = NotUpdate;
              else update_result = UpdateInternalKey;

              if (adv_cnt != keymgr_pkg::CDIs - 1) begin
                adv_cnt++;
              end else begin
                adv_cnt = 0;
                update_state(get_next_state(current_state));
                // set sw_binding_regwen after advance OP
                void&#39;(ral.sw_binding_regwen.predict(.value(1)));
                ral.sw_binding_regwen.en.set_lockable_flds_access(.lock(0));
              end
            end
          end
          keymgr_pkg::OpDisable: begin
            update_result = UpdateInternalKey;
            if (adv_cnt != keymgr_pkg::CDIs - 1) begin
              adv_cnt++;
            end else begin
              adv_cnt = 0;
              update_state(keymgr_pkg::StDisabled);
            end
          end
          keymgr_pkg::OpGenId, keymgr_pkg::OpGenSwOut, keymgr_pkg::OpGenHwOut: begin
            // If only op error but no fault error, no update for output
            if (get_op_err() &amp;&amp; !get_fault_err()) begin
              update_result = NotUpdate;
            end else if (op == keymgr_pkg::OpGenHwOut) begin
              update_result = UpdateHwOut;
            end else begin
              update_result = UpdateSwOut;
            end
            if (get_fault_err()) update_state(keymgr_pkg::StDisabled);
          end
          default: `uvm_fatal(`gfn, $sformatf(&quot;Unexpected operation: %0s&quot;, op.name))
        endcase
      end
      keymgr_pkg::StDisabled, keymgr_pkg::StInvalid: begin
        case (op)
          keymgr_pkg::OpAdvance, keymgr_pkg::OpDisable: begin
            update_result = NotUpdate;
            if (adv_cnt != keymgr_pkg::CDIs - 1) begin
              adv_cnt++;
            end else begin
              adv_cnt = 0;
            end
          end
          keymgr_pkg::OpGenSwOut, keymgr_pkg::OpGenId: begin
            update_result = UpdateSwOut;
          end
          keymgr_pkg::OpGenHwOut: begin
            update_result = UpdateHwOut;
          end
          default: `uvm_fatal(`gfn, $sformatf(&quot;Unexpected operation: %0s&quot;, op.name))
        endcase
      end
      default: `uvm_fatal(`gfn, $sformatf(&quot;Unexpected current_state: %0s&quot;, current_state.name))
    endcase

    return update_result;
  endfunction

  virtual task process_tl_access(tl_seq_item item, tl_channels_e channel, string ral_name);
    dv_base_reg    dv_reg;
    uvm_reg        csr;
    bit            do_read_check = 1&#39;b1;
    bit            write = item.is_write();
    uvm_reg_addr_t csr_addr = ral.get_word_aligned_addr(item.a_addr);

    bit            addr_phase_read = (!write &amp;&amp; channel == AddrChannel);
    bit            addr_phase_write = (write &amp;&amp; channel == AddrChannel);
    bit            data_phase_read = (!write &amp;&amp; channel == DataChannel);
    bit            data_phase_write = (write &amp;&amp; channel == DataChannel);

    // if access was to a valid csr, get the csr handle
    if (csr_addr inside {cfg.ral_models[ral_name].csr_addrs}) begin
      csr = ral.default_map.get_reg_by_offset(csr_addr);
      `DV_CHECK_NE_FATAL(csr, null)
      `downcast(dv_reg, csr)
    end else begin
      `uvm_fatal(`gfn, $sformatf(&quot;Access unexpected addr 0x%0h&quot;, csr_addr))
    end

    // if incoming access is a write to a valid csr, then make updates right away
    if (addr_phase_write) begin
      // if OP WIP or keymgr_en=0, will clear cfg_regwen and below csr can&#39;t be written
      if ((current_op_status == keymgr_pkg::OpWip || !cfg.keymgr_vif.get_keymgr_en()) &amp;&amp;
          ral.cfg_regwen.locks_reg_or_fld(
              dv_reg
          )) begin
        `uvm_info(`gfn, $sformatf(&quot;Reg write to %0s is ignored due to cfg_regwen=0&quot;, csr.get_name()
                  ), UVM_MEDIUM)
        return;
      end else if (
          `gmv(ral.sw_binding_regwen)
          == 0 &amp;&amp; ral.sw_binding_regwen.locks_reg_or_fld(
              dv_reg
          )) begin
        `uvm_info(`gfn, $sformatf(
                  &quot;Reg write to %0s is ignored due to sw_binding_regwen=0&quot;, csr.get_name()),
                  UVM_MEDIUM)
        return;
      end else if (csr.get_name() == &quot;sw_binding_regwen&quot; &amp;&amp; current_state == keymgr_pkg::StReset)
      begin
        `uvm_info(`gfn, $sformatf(
                  &quot;Reg write to %0s is ignored due to state in StReset&quot;, csr.get_name()),
                  UVM_MEDIUM)
        return;
      end else begin
        void&#39;(csr.predict(.value(item.a_data), .kind(UVM_PREDICT_WRITE), .be(item.a_mask)));
      end
    end

    if (data_phase_write &amp;&amp; csr.get_name() == &quot;sw_binding_regwen&quot; &amp;&amp;
        current_state == keymgr_pkg::StReset) begin
      // in StReset, can&#39;t change sw_binding_regwen value
      // set related locked reg back to original_access as this is updated automatic in post_write
      #0;  // push below update to be done after post_write
      ral.sw_binding_regwen.en.set_lockable_flds_access(.lock(0));
    end

    // process the csr req
    // for write, update local variable and fifo at address phase
    // for read, update predication at address phase and compare at data phase
    case (csr.get_name())
      // add individual case item for each csr
      &quot;intr_state&quot;: begin
        if (data_phase_read) begin
          bit [TL_DW-1:0] intr_en = `gmv(ral.intr_enable);
          bit [NumKeyMgrIntr-1:0] intr_exp = `gmv(ral.intr_state);

          foreach (intr_exp[i]) begin
            keymgr_intr_e intr = keymgr_intr_e&#39;(i);

            `DV_CHECK_CASE_EQ(cfg.intr_vif.pins[i], (intr_en[i] &amp; intr_exp[i]), $sformatf(
                              &quot;Interrupt_pin: %0s&quot;, intr.name));
          end
        end
      end
      &quot;intr_enable&quot;, &quot;err_code&quot;, &quot;sw_binding_regwen&quot;: begin
        // no speical handle is needed
      end
      &quot;intr_test&quot;: begin
        if (write &amp;&amp; channel == AddrChannel) begin
          bit [TL_DW-1:0] intr_en = `gmv(ral.intr_enable);
          bit [NumKeyMgrIntr-1:0] intr_exp = `gmv(ral.intr_state) | item.a_data;

          void&#39;(ral.intr_state.predict(.value(intr_exp)));
          if (cfg.en_cov) begin
            foreach (intr_exp[i]) begin
              cov.intr_test_cg.sample(i, item.a_data[i], intr_en[i], intr_exp[i]);
            end
          end
        end
      end
      &quot;cfg_regwen&quot;: begin
        // Check in this block
        do_read_check = 1&#39;b0;

        // skip checking cfg_regwen value when it&#39;s advance OP in Reset, as it&#39;s hard to know what exact
        // time OP will complete
        if (current_state != keymgr_pkg::StReset || current_op_status != keymgr_pkg::OpWip) begin
          if (addr_phase_read) begin
            addr_phase_cfg_regwen = current_op_status != keymgr_pkg::OpWip &amp;&amp;
                               cfg.keymgr_vif.get_keymgr_en();
          end else if (data_phase_read) begin
            `DV_CHECK_EQ(item.d_data, addr_phase_cfg_regwen)
          end
        end
      end
      &quot;control&quot;: begin
        if (addr_phase_write) begin
          bit start = `gmv(ral.control.start);

          if (start) begin
            keymgr_pkg::keymgr_ops_e op = get_operation();
            current_op_status = keymgr_pkg::OpWip;

            `uvm_info(`gfn, $sformatf(&quot;At %s, %s is issued&quot;, current_state.name, op.name), UVM_LOW)

            // In StReset, OP doesn&#39;t trigger KDF, update result here for InvalidOp and update
            // status at `op_status`
            // For other states, update result after KDF is done at process_kmac_data_rsp
            case (current_state)
              keymgr_pkg::StReset: begin
                if (op == keymgr_pkg::OpAdvance) begin
                  // for advance to OwnerRootSecret, both KDF use same otp_key
                  current_internal_key[Sealing] = {
                    cfg.keymgr_vif.otp_key.key_share1, cfg.keymgr_vif.otp_key.key_share0
                  };
                  current_internal_key[Attestation] = current_internal_key[Sealing];
                  cfg.keymgr_vif.store_internal_key(current_internal_key[Sealing], current_state,
                                                    current_cdi);

                  // expect no EDN request is issued. After this advance is done, will have 2 reqs
                  `DV_CHECK_EQ(edn_fifo.is_empty(), 1)
                end else begin  // !OpAdvance
                  current_op_status = keymgr_pkg::OpDoneFail;
                  // No KDF issued, done interrupt/alert is triggered in next cycle
                  void&#39;(ral.intr_state.predict(.value(1 &lt;&lt; int&#39;(IntrOpDone))));
                  fork
                    begin
                      cfg.clk_rst_vif.wait_clks(1);
                      process_error_n_alert();
                    end
                  join_none
                end
                void&#39;(ral.intr_state.predict(.value(1 &lt;&lt; int&#39;(IntrOpDone))));
              end
              default: begin  // other than StReset and StDisabled
                bit good_key = get_is_kmac_key_correct();
                bit skip_clean_kmac_key = 0;

                if (current_state != keymgr_pkg::StReset &amp;&amp;
                    op inside {keymgr_pkg::OpAdvance, keymgr_pkg::OpDisable}) begin
                  skip_clean_kmac_key = 1;
                end

                if (op == keymgr_pkg::OpAdvance) begin
                  current_cdi = get_adv_cdi_type();
                end else begin
                  int cdi_sel = `gmv(ral.control.cdi_sel);
                  `downcast(current_cdi, cdi_sel)
                end
                // update kmac key for check
                cfg.keymgr_vif.update_kdf_key(current_internal_key[current_cdi], current_state,
                                              good_key);
              end
            endcase
            // start will be clear after OP is done
            void&#39;(ral.control.start.predict(.value(0), .kind(UVM_PREDICT_WRITE)));
          end  // start
        end  // addr_phase_write
      end
      &quot;working_state&quot;: begin
        // Check in this block
        do_read_check = 1&#39;b0;

        if (addr_phase_read) begin
          addr_phase_working_state = current_state;
        end else if (data_phase_read) begin
          // scb can&#39;t predict when advance from stReset is done, as it&#39;s updated internally and no
          // output to indicate that, skip checking it
          if (current_state != keymgr_pkg::StReset || current_op_status != keymgr_pkg::OpWip) begin
            keymgr_pkg::keymgr_working_state_e act_state;

            `downcast(act_state, item.d_data)
            `DV_CHECK_EQ(act_state, addr_phase_working_state)
          end
        end
      end
      &quot;op_status&quot;: begin
        // Check in this block
        do_read_check = 1&#39;b0;

        if (addr_phase_write) begin
          // W1C
          `downcast(current_op_status, int&#39;(current_op_status) &amp; ~item.a_data);
        end else if (addr_phase_read) begin
          addr_phase_op_status = current_op_status;
        end else if (data_phase_read) begin
          if (current_state == keymgr_pkg::StReset) begin
            // when advance from StReset to StInit, we don&#39;t know how long it will take, it&#39;s ok
            // when status is WIP or success
            `DV_CHECK_EQ(item.d_data inside {current_op_status, keymgr_pkg::OpDoneSuccess}, 1)
            if (item.d_data == keymgr_pkg::OpDoneSuccess) begin
              current_op_status = keymgr_pkg::OpDoneSuccess;
              current_state = get_next_state(current_state);
              void&#39;(ral.intr_state.predict(.value(1 &lt;&lt; int&#39;(IntrOpDone))));

              // keymgr should request 2 EDN data during advancing from StReset
              // function `used` returns the number of entries put into the FIFO
              `DV_CHECK_EQ(edn_fifo.used(), 2)
            end
          end else begin
            `DV_CHECK_EQ(item.d_data, addr_phase_op_status)
          end
        end
      end
      &quot;reseed_interval_shadowed&quot;: begin
        if (addr_phase_write) cfg.keymgr_vif.edn_interval = `gmv(ral.reseed_interval_shadowed.val);
      end
      default: begin
        if (!uvm_re_match(&quot;sw_share*&quot;, csr.get_name())) begin  // sw_share
          // if keymgr isn&#39;t On, SW output should be entropy and not match to predict value
          if (addr_phase_read) begin
            addr_phase_is_sw_share_corrupted = is_sw_share_corrupted;
          end else if (data_phase_read &amp;&amp; addr_phase_is_sw_share_corrupted) begin
            if (item.d_data != 0) begin
              do_read_check = 1&#39;b0;
              `DV_CHECK_NE(item.d_data, `gmv(csr))
            end
          end
        end else begin  // Not sw_share
          // TODO
          do_read_check = 1&#39;b0;
        end
      end
    endcase

    // On reads, if do_read_check, is set, then check mirrored_value against item.d_data
    if (data_phase_read) begin
      if (do_read_check) begin
        `DV_CHECK_EQ(item.d_data, `gmv(csr), $sformatf(&quot;reg name: %0s&quot;, csr.get_full_name()))
      end
      void&#39;(csr.predict(.value(item.d_data), .kind(UVM_PREDICT_READ)));
    end
  endtask

  virtual function bit [TL_DW-1:0] get_current_max_version();
    case (current_state)
      keymgr_pkg::StCreatorRootKey: return `gmv(ral.max_creator_key_ver_shadowed);
      keymgr_pkg::StOwnerIntKey:    return `gmv(ral.max_owner_int_key_ver_shadowed);
      keymgr_pkg::StOwnerKey:       return `gmv(ral.max_owner_key_ver_shadowed);
      // for the other state, max is 0
      default:                      return 0;
    endcase
  endfunction

  virtual function void process_error_n_alert();
    bit [TL_DW-1:0] err = get_err_code();
    void&#39;(ral.err_code.predict(err));

    if (get_fault_err()) set_exp_alert(&quot;fatal_fault_err&quot;, .is_fatal(1));
    if (get_op_err()) set_exp_alert(&quot;recov_operation_err&quot;);

    `uvm_info(`gfn, $sformatf(
              &quot;at %s, %s is issued and error code is &#39;b%0b&quot;, current_state, get_operation(), err),
              UVM_MEDIUM)
  endfunction

  virtual function bit [TL_DW-1:0] get_fault_err();
    bit [TL_DW-1:0] err = get_err_code();
    return err[keymgr_pkg::ErrInvalidOut] || err[keymgr_pkg::ErrInvalidStates];
  endfunction

  virtual function bit [TL_DW-1:0] get_op_err();
    bit [TL_DW-1:0] err = get_err_code();
    return err[keymgr_pkg::ErrInvalidOp] || err[keymgr_pkg::ErrInvalidIn];
  endfunction

  virtual function bit [TL_DW-1:0] get_err_code();
    bit [TL_DW-1:0] err_code;

    // if keymgr_en is off during an OP, suppress op err
    if (cfg.keymgr_vif.get_keymgr_en() || current_state == keymgr_pkg::StInvalid) begin
      err_code[keymgr_pkg::ErrInvalidOp] = get_op_error();
    end

    err_code[keymgr_pkg::ErrInvalidStates] = is_kmac_rsp_err | is_kmac_invalid_data;

    if (cfg.keymgr_vif.keymgr_en_sync2 == lc_ctrl_pkg::On) begin
      err_code[keymgr_pkg::ErrInvalidIn] = get_hw_invalid_input() | get_sw_invalid_input();
    end

    err_code[keymgr_pkg::ErrInvalidOut] = is_kmac_invalid_data;

    `uvm_info(`gfn, $sformatf(
              &quot;op_err = %0d, rsp_err = %0d, kmac_invalid =%0d, hw_invalid = %0d \
              sw_invalid = %0d, kmac_invalid_data = %0d&quot;,
              get_op_error(),
              is_kmac_rsp_err,
              is_kmac_invalid_data,
              get_hw_invalid_input(),
              get_sw_invalid_input(),
              is_kmac_invalid_data
              ), UVM_MEDIUM)
    return err_code;
  endfunction

  virtual function bit get_op_error();
    case (current_state)
      keymgr_pkg::StReset: begin
        if (get_operation() != keymgr_pkg::OpAdvance) begin
          return 1;
        end
      end
      keymgr_pkg::StInit: begin
        if (!(get_operation() inside {keymgr_pkg::OpAdvance, keymgr_pkg::OpDisable})) begin
          return 1;
        end
      end
      keymgr_pkg::StCreatorRootKey, keymgr_pkg::StOwnerIntKey, keymgr_pkg::StOwnerKey: begin
        // no operation error
      end
      keymgr_pkg::StDisabled, keymgr_pkg::StInvalid: begin
        return 1;
      end
      default: `uvm_fatal(`gfn, $sformatf(&quot;unexpected state %s&quot;, current_state.name))
    endcase
    return 0;
  endfunction

  virtual function bit get_sw_invalid_input();
    if (get_operation() inside {keymgr_pkg::OpGenSwOut, keymgr_pkg::OpGenHwOut}) begin
      return get_current_max_version() &lt; `gmv(ral.key_version);
    end else begin
      return 0;
    end
  endfunction

  // HW invalid input checks as following
  // When an advance operation is invoked:
  //   The working state key is checked for all 0&#39;s and all 1&#39;s.
  //   During Initialized state, creator seed, device ID and health state data is checked for all
  //   0&#39;s and all 1&#39;s.
  //   During CreatorRootKey state, the owner seed is checked for all 0&#39;s and all 1&#39;s.
  //   During all other states, nothing is explicitly checked.
  // When a generate output key operation is invoked:
  //   The working state key is checked for all 0&#39;s and all 1&#39;s.
  virtual function bit get_hw_invalid_input();
    bit is_err;

    if (current_internal_key[current_cdi] inside {0, &#39;1} &amp;&amp; current_state != keymgr_pkg::StReset)
    begin
      is_err = 1;
      `uvm_info(`gfn, $sformatf(&quot;internal key for %s %s is invalid&quot;, current_state, current_cdi),
                UVM_LOW)
    end

    if (get_operation() != keymgr_pkg::OpAdvance) return is_err;

    // TODO, expand all types of errors for adding coverage later
    case (current_state)
      keymgr_pkg::StInit: begin
        if (cfg.keymgr_vif.keymgr_div inside {0, &#39;1}) begin
          is_err = 1;
          `uvm_info(`gfn, &quot;HW invalid input on keymgr_div&quot;, UVM_LOW)
        end

        if (cfg.keymgr_vif.otp_device_id inside {0, &#39;1}) begin
          is_err = 1;
          `uvm_info(`gfn, &quot;HW invalid input on otp_device_id&quot;, UVM_LOW)
        end

        if (cfg.keymgr_vif.rom_digest.data inside {0, &#39;1}) begin
          is_err = 1;
          `uvm_info(`gfn, &quot;HW invalid input on rom_digest&quot;, UVM_LOW)
        end

        if (cfg.keymgr_vif.otp_key.key_share0 inside {0, &#39;1}) begin
          is_err = 1;
          `uvm_info(`gfn, &quot;HW invalid input on key_share0&quot;, UVM_LOW)
        end

        if (cfg.keymgr_vif.otp_key.key_share1 inside {0, &#39;1}) begin
          is_err = 1;
          `uvm_info(`gfn, &quot;HW invalid input on key_share1&quot;, UVM_LOW)
        end

        if (cfg.keymgr_vif.flash.seeds[flash_ctrl_pkg::CreatorSeedIdx] inside {0, &#39;1}) begin
          is_err = 1;
          `uvm_info(`gfn, &quot;HW invalid input on flash.seeds[CreatorSeedIdx]&quot;, UVM_LOW)
        end
      end
      keymgr_pkg::StCreatorRootKey: begin
        if (cfg.keymgr_vif.flash.seeds[flash_ctrl_pkg::OwnerSeedIdx] inside {0, &#39;1}) begin
          is_err = 1;
          `uvm_info(`gfn, &quot;HW invalid input on flash.seeds[OwnerSeedIdx]&quot;, UVM_LOW)
        end
      end
      default: ;
    endcase
    return is_err;
  endfunction

  // in normal operational states, invalid command etc lead to random data for gen-out OP
  virtual function bit get_is_kmac_data_correct();
    bit [TL_DW-1:0] err_code = get_err_code();
    keymgr_pkg::keymgr_ops_e op = get_operation();

    if (current_state inside {keymgr_pkg::StCreatorRootKey, keymgr_pkg::StOwnerIntKey,
                              keymgr_pkg::StOwnerKey}) begin
      return !(err_code[keymgr_pkg::ErrInvalidStates] |
               err_code[keymgr_pkg::ErrInvalidOut] |
               err_code[keymgr_pkg::ErrInvalidIn]  |
               !cfg.keymgr_vif.get_keymgr_en());
    end else begin
      return 0;
    end
  endfunction

  // Entering StDisable or invalid op leads to random key
  virtual function bit get_is_kmac_key_correct();
    bit [TL_DW-1:0] err_code = get_err_code();
    keymgr_pkg::keymgr_ops_e op = get_operation();

    if ((current_state == keymgr_pkg::StOwnerKey &amp;&amp; op == keymgr_pkg::OpAdvance) ||
        op == keymgr_pkg::OpDisable || !cfg.keymgr_vif.get_keymgr_en()) begin
      return 0;
    end else begin
      return !(err_code[keymgr_pkg::ErrInvalidOp]);
    end
  endfunction

  virtual function void compare_adv_creator_data(keymgr_cdi_type_e cdi_type, bit exp_match,
                                                 const ref byte byte_data_q[$]);
    adv_creator_data_t exp, act;
    string str = $sformatf(&quot;cdi_type: %s\n&quot;, cdi_type.name);

    if (exp_match) `DV_CHECK_EQ(byte_data_q.size, keymgr_pkg::AdvDataWidth / 8)
    act                        = {&lt;&lt;8{byte_data_q}};

    exp.DiversificationKey     = cfg.keymgr_vif.flash.seeds[flash_ctrl_pkg::CreatorSeedIdx];
    exp.RomDigest              = cfg.keymgr_vif.rom_digest.data;
    exp.HealthMeasurement      = cfg.keymgr_vif.keymgr_div;
    exp.DeviceIdentifier       = cfg.keymgr_vif.otp_device_id;
    exp.HardwareRevisionSecret = keymgr_pkg::RndCnstRevisionSeedDefault;

    get_sw_binding_mirrored_value(cdi_type, exp.SoftwareBinding);

    // The order of the string creation must match the design
    `CREATE_CMP_STR(DiversificationKey)
    `CREATE_CMP_STR(RomDigest)
    `CREATE_CMP_STR(HealthMeasurement)
    `CREATE_CMP_STR(DeviceIdentifier)
    `CREATE_CMP_STR(HardwareRevisionSecret)
    `CREATE_CMP_STR(SoftwareBinding)

    if (exp_match) begin
      `DV_CHECK_EQ(act, exp, str)
    end else begin
      `DV_CHECK_NE(act, exp, str)
    end

    if (exp_match) adv_data_a_array[Sealing][keymgr_pkg::StCreatorRootKey] = act;
  endfunction

  virtual function void compare_adv_owner_int_data(keymgr_cdi_type_e cdi_type, bit exp_match,
                                                   const ref byte byte_data_q[$]);
    adv_owner_int_data_t exp, act;
    string str = $sformatf(&quot;cdi_type: %s\n&quot;, cdi_type.name);

    act = {&lt;&lt;8{byte_data_q}};

    exp.OwnerRootSecret = cfg.keymgr_vif.flash.seeds[flash_ctrl_pkg::OwnerSeedIdx];
    get_sw_binding_mirrored_value(cdi_type, exp.SoftwareBinding);

    `CREATE_CMP_STR(unused)
    `CREATE_CMP_STR(OwnerRootSecret)
    for (int i = 0; i &lt; keymgr_reg_pkg::NumSwBindingReg; i++) begin
      `CREATE_CMP_STR(SoftwareBinding[i])
    end

    if (exp_match) begin
      `DV_CHECK_EQ(act, exp, str)
    end else begin
      `DV_CHECK_NE(act, exp, str)
    end

    if (exp_match) adv_data_a_array[Sealing][keymgr_pkg::StOwnerIntKey] = act;
  endfunction

  virtual function void compare_adv_owner_data(keymgr_cdi_type_e cdi_type,
                                               const ref byte byte_data_q[$]);
    adv_owner_data_t exp, act;
    string str = $sformatf(&quot;cdi_type: %s\n&quot;, cdi_type.name);

    act = {&lt;&lt;8{byte_data_q}};

    get_sw_binding_mirrored_value(cdi_type, exp.SoftwareBinding);

    `CREATE_CMP_STR(unused)
    for (int i = 0; i &lt; keymgr_reg_pkg::NumSwBindingReg; i++) begin
      `CREATE_CMP_STR(SoftwareBinding[i])
    end

    `DV_CHECK_EQ(act, exp, str)

    adv_data_a_array[Sealing][keymgr_pkg::StOwnerKey] = act;
  endfunction

  // for invalid OP, should not output any meaningful data to KMAC. Check the outputs aren&#39;t
  // matching to any of existing meaningful data
  virtual function void compare_invalid_data(const ref byte byte_data_q[$]);
    adv_owner_data_t act;

    act = {&lt;&lt;8{byte_data_q}};
    foreach (adv_data_a_array[i, j]) begin
      `DV_CHECK_NE(act, adv_data_a_array[i][j], $sformatf(
                   &quot;Adv data to state %0s for %0s&quot;, j.name, i.name))
    end
    foreach (id_data_a_array[i]) begin
      `DV_CHECK_NE(act, id_data_a_array[i], $sformatf(&quot;ID data at state %0s&quot;, i.name))
    end
    foreach (sw_data_a_array[i]) begin
      `DV_CHECK_NE(act, sw_data_a_array[i], $sformatf(&quot;SW data at state %0s&quot;, i.name))
    end
    foreach (hw_data_a_array[i]) begin
      `DV_CHECK_NE(act, hw_data_a_array[i], $sformatf(&quot;HW data at state %0s&quot;, i.name))
    end
    foreach (cfg.keymgr_vif.keys_a_array[state, cdi, dest]) begin
      `DV_CHECK_NE(act, cfg.keymgr_vif.keys_a_array[state][cdi][dest], $sformatf(
                   &quot;key at state %0s for %s %s&quot;, state.name, cdi.name, dest))
    end
  endfunction

  virtual function void compare_id_data(const ref byte byte_data_q[$]);
    bit [keymgr_pkg::IdDataWidth-1:0] act, exp;

    case (current_state)
      keymgr_pkg::StCreatorRootKey: exp = keymgr_pkg::RndCnstCreatorIdentitySeedDefault;
      keymgr_pkg::StOwnerIntKey: exp = keymgr_pkg::RndCnstOwnerIntIdentitySeedDefault;
      keymgr_pkg::StOwnerKey: exp = keymgr_pkg::RndCnstOwnerIdentitySeedDefault;
      default: `uvm_fatal(`gfn, $sformatf(&quot;unexpected state %s&quot;, current_state.name))
    endcase
    act = {&lt;&lt;8{byte_data_q}};

    `DV_CHECK_EQ(act, exp, $sformatf(&quot;Gen ID at %0s&quot;, current_state.name))

    id_data_a_array[current_state] = act;
  endfunction

  virtual function void compare_gen_out_data(const ref byte byte_data_q[$]);
    gen_out_data_t exp, act;
    keymgr_pkg::keymgr_ops_e op = get_operation();
    keymgr_pkg::keymgr_key_dest_e dest = keymgr_pkg::keymgr_key_dest_e&#39;(`gmv(ral.control.dest_sel));
    string str;

    act = {&lt;&lt;8{byte_data_q}};

    exp.KeyVersion = `gmv(ral.key_version);
    for (int i = 0; i &lt; keymgr_reg_pkg::NumSaltReg; i++) begin
      uvm_reg rg = ral.get_reg_by_name($sformatf(&quot;salt_%0d&quot;, i));
      exp.Salt[i] = `gmv(rg);
    end

    case (dest)
      keymgr_pkg::Kmac: exp.KeyID = keymgr_pkg::RndCnstKmacSeedDefault;
      keymgr_pkg::Hmac: exp.KeyID = keymgr_pkg::RndCnstHmacSeedDefault;
      keymgr_pkg::Aes: exp.KeyID = keymgr_pkg::RndCnstAesSeedDefault;
      keymgr_pkg::None: exp.KeyID = keymgr_pkg::RndCnstNoneSeedDefault;
      default: `uvm_fatal(`gfn, $sformatf(&quot;Unexpected dest_sel: %0s&quot;, dest.name))
    endcase

    case (op)
      keymgr_pkg::OpGenSwOut: begin
        exp.SoftwareExportConstant = keymgr_pkg::RndCnstSoftOutputSeedDefault;
        sw_data_a_array[current_state] = act;
      end
      keymgr_pkg::OpGenHwOut: begin
        exp.SoftwareExportConstant = keymgr_pkg::RndCnstHardOutputSeedDefault;
        hw_data_a_array[current_state] = act;
      end
      default: `uvm_fatal(`gfn, $sformatf(&quot;Unexpected operation: %0s&quot;, op.name))
    endcase

    `CREATE_CMP_STR(KeyVersion)
    `CREATE_CMP_STR(Salt)
    `CREATE_CMP_STR(KeyID)
    `CREATE_CMP_STR(SoftwareExportConstant)

    `DV_CHECK_EQ(act, exp, str)
  endfunction

  virtual function keymgr_cdi_type_e get_adv_cdi_type();
    `downcast(get_adv_cdi_type, adv_cnt)
  endfunction

  virtual function void get_sw_binding_mirrored_value(input keymgr_cdi_type_e cdi_type,
                                                      output bit [keymgr_reg_pkg::NumSwBindingReg-1:0][TL_DW-1:0] sw_binding);

    for (int i = 0; i &lt; keymgr_reg_pkg::NumSwBindingReg; i++) begin
      case (cdi_type)
        Sealing: sw_binding[i] = `gmv(ral.sealing_sw_binding[i]);
        Attestation: sw_binding[i] = `gmv(ral.attest_sw_binding[i]);
        default: `uvm_fatal(`gfn, $sformatf(&quot;Unsupported CDI type %s&quot;, cdi_type.name))
      endcase
    end
  endfunction

  // if it&#39;s not defined operation, treat as OpDisable
  virtual function keymgr_pkg::keymgr_ops_e get_operation();
    keymgr_pkg::keymgr_ops_e op;
    int op_int_val = `gmv(ral.control.operation);

    if (!$cast(op, op_int_val)) op = keymgr_pkg::OpDisable;
    return op;
  endfunction

  virtual function keymgr_pkg::keymgr_working_state_e get_next_state(
      keymgr_pkg::keymgr_working_state_e cur);
    if (!cfg.keymgr_vif.get_keymgr_en()) return keymgr_pkg::StInvalid;
    else return keymgr_env_pkg::get_next_state(cur);
  endfunction

  virtual function void update_state(keymgr_pkg::keymgr_working_state_e new_state, int cyc_dly = 1);
    fork
      begin
        // it takes 1 cycle to update state after rsp_done is set. add one more negedge to avoid
        // race condition
        cfg.clk_rst_vif.wait_n_clks(cyc_dly + 1);
        current_state = new_state;
      end
    join_none
  endfunction

  virtual function void wipe_hw_keys();
    if (current_op_status != keymgr_pkg::OpWip) begin
      // design takes 2 cycle to update state
      update_state(keymgr_pkg::StInvalid, .cyc_dly(2));
      `uvm_info(`gfn, &quot;Keymgr_en is Off, wipe secret and move state to Invalid&quot;, UVM_LOW)
    end
    fork
      begin
        // it takes 2 cycle to wipe sw_share. add one more negedge to avoid race condition
        cfg.clk_rst_vif.wait_n_clks(3);
        update_state(keymgr_pkg::StInvalid);
        is_sw_share_corrupted = 1;
      end
    join_none
  endfunction

  virtual function void reset(string kind = &quot;HARD&quot;);
    super.reset(kind);
    // reset local fifos queues and variables
    current_state         = keymgr_pkg::StReset;
    current_op_status     = keymgr_pkg::OpIdle;
    is_kmac_rsp_err       = 0;
    is_kmac_invalid_data  = 0;
    is_sw_share_corrupted = 0;
    req_fifo.flush();
    rsp_fifo.flush();
    current_internal_key.delete;
    adv_data_a_array.delete();
    id_data_a_array.delete();
    sw_data_a_array.delete();
    hw_data_a_array.delete();
    cfg.keymgr_vif.reset();
  endfunction

  function void check_phase(uvm_phase phase);
    super.check_phase(phase);
    // post test checks - ensure that all local fifos and queues are empty
    `DV_EOT_PRINT_TLM_FIFO_CONTENTS(kmac_app_item, req_fifo)
    `DV_EOT_PRINT_TLM_FIFO_CONTENTS(kmac_app_item, rsp_fifo)
  endfunction

  `undef CREATE_CMP_STR
endclass
&lt;&lt;EOF&gt;&gt;
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="examined_bugs.html" class="btn btn-neutral float-right" title="Incorrect formatting (39 entries)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="examined_confirmed.html" class="btn btn-neutral float-left" title="Correct formatting (39 entries)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2017-2021, The Verible Authors.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>